# Generated from SolidityParser.g4 by ANTLR 4.13.0
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys

if sys.version_info[1] > 5:
    from typing import TextIO
else:
    from typing.io import TextIO


def serializedATN():
    return [
        4, 1, 177, 1326, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7, 4, 2, 5, 7, 5, 2, 6,
        7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7,
        13, 2, 14, 7, 14, 2, 15, 7, 15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2,
        20, 7, 20, 2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 26, 7,
        26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7, 31, 2, 32, 7, 32, 2,
        33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7,
        39, 2, 40, 7, 40, 2, 41, 7, 41, 2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2,
        46, 7, 46, 2, 47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 7,
        52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 57, 2, 58, 7, 58, 2,
        59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62, 2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7,
        65, 2, 66, 7, 66, 2, 67, 7, 67, 2, 68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2,
        72, 7, 72, 2, 73, 7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
        78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83, 2, 84, 7, 84, 2,
        85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2, 89, 7, 89, 2, 90, 7, 90, 2, 91, 7,
        91, 2, 92, 7, 92, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 5, 0,
        199, 8, 0, 10, 0, 12, 0, 202, 9, 0, 1, 0, 1, 0, 1, 1, 1, 1, 4, 1, 208, 8, 1, 11, 1, 12, 1,
        209, 1, 1, 1, 1, 1, 2, 1, 2, 1, 2, 1, 2, 3, 2, 218, 8, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2,
        1, 2, 1, 2, 1, 2, 1, 2, 3, 2, 230, 8, 2, 1, 2, 1, 2, 1, 3, 1, 3, 1, 3, 3, 3, 237, 8, 3, 1, 4,
        1, 4, 1, 5, 1, 5, 1, 5, 1, 5, 5, 5, 245, 8, 5, 10, 5, 12, 5, 248, 9, 5, 1, 5, 1, 5, 1, 6, 3,
        6, 253, 8, 6, 1, 6, 1, 6, 1, 6, 3, 6, 258, 8, 6, 1, 6, 1, 6, 5, 6, 262, 8, 6, 10, 6, 12, 6,
        265, 9, 6, 1, 6, 1, 6, 1, 7, 1, 7, 1, 7, 3, 7, 272, 8, 7, 1, 7, 1, 7, 5, 7, 276, 8, 7, 10, 7,
        12, 7, 279, 9, 7, 1, 7, 1, 7, 1, 8, 1, 8, 1, 8, 1, 8, 5, 8, 287, 8, 8, 10, 8, 12, 8, 290, 9,
        8, 1, 8, 1, 8, 1, 9, 1, 9, 1, 9, 1, 9, 5, 9, 298, 8, 9, 10, 9, 12, 9, 301, 9, 9, 1, 10, 1, 10,
        3, 10, 305, 8, 10, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11,
        1, 11, 1, 11, 3, 11, 319, 8, 11, 1, 12, 1, 12, 1, 12, 1, 12, 1, 13, 1, 13, 1, 13, 1, 13,
        5, 13, 329, 8, 13, 10, 13, 12, 13, 332, 9, 13, 3, 13, 334, 8, 13, 1, 13, 1, 13, 1, 13,
        1, 13, 5, 13, 340, 8, 13, 10, 13, 12, 13, 343, 9, 13, 3, 13, 345, 8, 13, 1, 13, 3, 13,
        348, 8, 13, 1, 13, 1, 13, 1, 14, 1, 14, 1, 14, 5, 14, 355, 8, 14, 10, 14, 12, 14, 358,
        9, 14, 1, 15, 1, 15, 3, 15, 362, 8, 15, 1, 16, 1, 16, 1, 17, 1, 17, 1, 17, 5, 17, 369, 8,
        17, 10, 17, 12, 17, 372, 9, 17, 1, 18, 1, 18, 3, 18, 376, 8, 18, 1, 18, 3, 18, 379, 8,
        18, 1, 19, 1, 19, 1, 19, 3, 19, 384, 8, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1,
        19, 1, 19, 1, 19, 1, 19, 1, 19, 5, 19, 397, 8, 19, 10, 19, 12, 19, 400, 9, 19, 1, 19, 1,
        19, 1, 20, 1, 20, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 5, 21, 411, 8, 21, 10, 21, 12, 21,
        414, 9, 21, 1, 21, 1, 21, 3, 21, 418, 8, 21, 1, 22, 1, 22, 1, 22, 1, 22, 3, 22, 424, 8,
        22, 1, 22, 1, 22, 3, 22, 428, 8, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1,
        22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 5, 22, 447, 8, 22, 10,
        22, 12, 22, 450, 9, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 3, 22, 457, 8, 22, 1, 22, 1,
        22, 3, 22, 461, 8, 22, 1, 23, 1, 23, 1, 23, 1, 23, 3, 23, 467, 8, 23, 1, 23, 1, 23, 3, 23,
        471, 8, 23, 1, 23, 1, 23, 3, 23, 475, 8, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 3, 23, 482,
        8, 23, 1, 23, 1, 23, 3, 23, 486, 8, 23, 1, 24, 1, 24, 1, 24, 1, 24, 3, 24, 492, 8, 24, 1,
        24, 3, 24, 495, 8, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 5, 24, 504, 8, 24,
        10, 24, 12, 24, 507, 9, 24, 1, 24, 1, 24, 3, 24, 511, 8, 24, 1, 25, 1, 25, 1, 25, 1, 25,
        1, 25, 3, 25, 518, 8, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25,
        1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 5, 25, 536, 8, 25, 10, 25, 12, 25, 539,
        9, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 3, 25, 548, 8, 25, 1, 25, 1, 25,
        3, 25, 552, 8, 25, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26,
        1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 1, 26, 5, 26, 571, 8, 26, 10, 26, 12, 26, 574,
        9, 26, 1, 26, 1, 26, 3, 26, 578, 8, 26, 1, 27, 1, 27, 1, 27, 1, 27, 4, 27, 584, 8, 27, 11,
        27, 12, 27, 585, 1, 27, 1, 27, 1, 28, 1, 28, 1, 28, 1, 28, 1, 29, 1, 29, 1, 29, 1, 29, 1,
        29, 1, 29, 5, 29, 600, 8, 29, 10, 29, 12, 29, 603, 9, 29, 1, 29, 1, 29, 1, 30, 1, 30, 1,
        30, 1, 30, 1, 30, 1, 30, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1,
        31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 5, 31, 633, 8,
        31, 10, 31, 12, 31, 636, 9, 31, 1, 31, 1, 31, 1, 31, 3, 31, 641, 8, 31, 1, 31, 1, 31, 1,
        32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 33, 1, 33, 3, 33, 654, 8, 33, 1, 33, 3,
        33, 657, 8, 33, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 1, 34, 5, 34, 665, 8, 34, 10, 34, 12,
        34, 668, 9, 34, 3, 34, 670, 8, 34, 1, 34, 1, 34, 3, 34, 674, 8, 34, 1, 34, 1, 34, 1, 35,
        1, 35, 3, 35, 680, 8, 35, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 5, 36, 688, 8, 36, 10,
        36, 12, 36, 691, 9, 36, 3, 36, 693, 8, 36, 1, 36, 1, 36, 1, 36, 1, 37, 1, 37, 1, 38, 1,
        38, 1, 38, 1, 38, 1, 38, 1, 38, 3, 38, 706, 8, 38, 1, 38, 1, 38, 1, 38, 1, 38, 3, 38, 712,
        8, 38, 5, 38, 714, 8, 38, 10, 38, 12, 38, 717, 9, 38, 1, 38, 1, 38, 3, 38, 721, 8, 38,
        1, 38, 1, 38, 1, 38, 3, 38, 726, 8, 38, 1, 38, 3, 38, 729, 8, 38, 1, 38, 1, 38, 1, 39, 1,
        39, 1, 39, 1, 39, 1, 39, 3, 39, 738, 8, 39, 1, 39, 1, 39, 1, 39, 3, 39, 743, 8, 39, 1, 39,
        5, 39, 746, 8, 39, 10, 39, 12, 39, 749, 9, 39, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40,
        1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 3, 40, 763, 8, 40, 1, 41, 1, 41, 1, 41, 3, 41,
        768, 8, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 5, 41, 779, 8,
        41, 10, 41, 12, 41, 782, 9, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 3, 41, 789, 8, 41, 1,
        42, 1, 42, 3, 42, 793, 8, 42, 1, 42, 1, 42, 1, 43, 1, 43, 1, 44, 1, 44, 1, 44, 1, 44, 1,
        44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1,
        44, 3, 44, 817, 8, 44, 3, 44, 819, 8, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44,
        1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44,
        1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44,
        1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44,
        3, 44, 867, 8, 44, 1, 44, 1, 44, 1, 44, 1, 44, 3, 44, 873, 8, 44, 1, 44, 1, 44, 3, 44, 877,
        8, 44, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 3, 44, 884, 8, 44, 1, 44, 1, 44, 1, 44, 1, 44,
        1, 44, 5, 44, 891, 8, 44, 10, 44, 12, 44, 894, 9, 44, 3, 44, 896, 8, 44, 1, 44, 1, 44,
        1, 44, 1, 44, 1, 44, 5, 44, 903, 8, 44, 10, 44, 12, 44, 906, 9, 44, 1, 45, 1, 45, 1, 46,
        1, 46, 3, 46, 912, 8, 46, 1, 46, 1, 46, 3, 46, 916, 8, 46, 5, 46, 918, 8, 46, 10, 46, 12,
        46, 921, 9, 46, 1, 46, 1, 46, 1, 47, 1, 47, 1, 47, 1, 47, 5, 47, 929, 8, 47, 10, 47, 12,
        47, 932, 9, 47, 1, 47, 1, 47, 1, 48, 1, 48, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 3, 49, 943,
        8, 49, 1, 50, 1, 50, 1, 50, 1, 51, 1, 51, 1, 52, 4, 52, 951, 8, 52, 11, 52, 12, 52, 952,
        1, 53, 4, 53, 956, 8, 53, 11, 53, 12, 53, 957, 1, 54, 4, 54, 961, 8, 54, 11, 54, 12, 54,
        962, 1, 55, 1, 55, 1, 56, 1, 56, 1, 56, 5, 56, 970, 8, 56, 10, 56, 12, 56, 973, 9, 56,
        1, 56, 1, 56, 1, 57, 1, 57, 1, 57, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58,
        1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 3, 58, 993, 8, 58, 1, 59, 1, 59, 3, 59, 997, 8, 59, 1,
        60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 3, 60, 1006, 8, 60, 1, 61, 1, 61, 1, 61, 1,
        61, 3, 61, 1012, 8, 61, 1, 61, 1, 61, 3, 61, 1016, 8, 61, 1, 61, 3, 61, 1019, 8, 61, 1,
        61, 1, 61, 1, 61, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 63, 1, 63, 1, 63, 1, 63, 1,
        63, 1, 63, 1, 63, 1, 63, 1, 64, 1, 64, 1, 64, 1, 65, 1, 65, 1, 65, 1, 66, 1, 66, 1, 66, 1,
        66, 1, 66, 1, 66, 1, 66, 3, 66, 1051, 8, 66, 1, 66, 1, 66, 4, 66, 1055, 8, 66, 11, 66,
        12, 66, 1056, 1, 67, 1, 67, 3, 67, 1061, 8, 67, 1, 67, 1, 67, 1, 67, 1, 67, 3, 67, 1067,
        8, 67, 1, 67, 1, 67, 1, 68, 1, 68, 3, 68, 1073, 8, 68, 1, 68, 1, 68, 1, 69, 1, 69, 1, 69,
        1, 69, 1, 69, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 71, 1, 71, 3, 71, 1089, 8, 71, 1, 71,
        3, 71, 1092, 8, 71, 1, 71, 1, 71, 5, 71, 1096, 8, 71, 10, 71, 12, 71, 1099, 9, 71, 1,
        71, 1, 71, 1, 72, 1, 72, 1, 72, 1, 72, 5, 72, 1107, 8, 72, 10, 72, 12, 72, 1110, 9, 72,
        1, 72, 1, 72, 1, 73, 1, 73, 1, 73, 5, 73, 1117, 8, 73, 10, 73, 12, 73, 1120, 9, 73, 1,
        74, 1, 74, 5, 74, 1124, 8, 74, 10, 74, 12, 74, 1127, 9, 74, 1, 74, 1, 74, 1, 74, 1, 74,
        3, 74, 1133, 8, 74, 5, 74, 1135, 8, 74, 10, 74, 12, 74, 1138, 9, 74, 1, 74, 1, 74, 1,
        75, 1, 75, 1, 75, 3, 75, 1145, 8, 75, 1, 75, 1, 75, 1, 75, 1, 75, 3, 75, 1151, 8, 75, 1,
        75, 1, 75, 1, 76, 1, 76, 1, 76, 1, 77, 1, 77, 1, 77, 1, 77, 3, 77, 1162, 8, 77, 1, 77, 1,
        77, 1, 77, 3, 77, 1167, 8, 77, 1, 77, 1, 77, 1, 78, 1, 78, 3, 78, 1173, 8, 78, 1, 79, 1,
        79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 3, 79, 1186, 8, 79, 1,
        80, 1, 80, 5, 80, 1190, 8, 80, 10, 80, 12, 80, 1193, 9, 80, 1, 80, 1, 80, 1, 81, 1, 81,
        1, 81, 1, 81, 3, 81, 1201, 8, 81, 1, 81, 1, 81, 1, 81, 1, 81, 5, 81, 1207, 8, 81, 10, 81,
        12, 81, 1210, 9, 81, 1, 81, 1, 81, 3, 81, 1214, 8, 81, 3, 81, 1216, 8, 81, 1, 82, 1, 82,
        1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 4, 82, 1225, 8, 82, 11, 82, 12, 82, 1226, 1, 82, 1,
        82, 1, 82, 3, 82, 1232, 8, 82, 1, 83, 1, 83, 1, 83, 1, 83, 1, 84, 1, 84, 1, 84, 1, 84, 1,
        84, 1, 84, 1, 85, 1, 85, 1, 85, 1, 85, 1, 86, 1, 86, 1, 86, 4, 86, 1251, 8, 86, 11, 86,
        12, 86, 1252, 1, 86, 1, 86, 3, 86, 1257, 8, 86, 1, 86, 1, 86, 3, 86, 1261, 8, 86, 1, 87,
        1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 5, 87, 1269, 8, 87, 10, 87, 12, 87, 1272, 9, 87, 3,
        87, 1274, 8, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 5, 87, 1281, 8, 87, 10, 87, 12, 87,
        1284, 9, 87, 3, 87, 1286, 8, 87, 1, 87, 1, 87, 1, 88, 1, 88, 1, 88, 5, 88, 1293, 8, 88,
        10, 88, 12, 88, 1296, 9, 88, 1, 89, 1, 89, 1, 89, 1, 89, 1, 89, 5, 89, 1303, 8, 89, 10,
        89, 12, 89, 1306, 9, 89, 3, 89, 1308, 8, 89, 1, 89, 1, 89, 1, 90, 1, 90, 1, 91, 1, 91,
        1, 91, 1, 91, 1, 91, 3, 91, 1319, 8, 91, 1, 92, 1, 92, 1, 92, 3, 92, 1324, 8, 92, 1, 92,
        1, 299, 2, 78, 88, 93, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34,
        36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78,
        80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116,
        118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148,
        150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180,
        182, 184, 0, 18, 3, 0, 23, 23, 38, 38, 49, 50, 3, 0, 47, 47, 51, 51, 68, 68, 4, 0, 98,
        100, 104, 108, 110, 115, 117, 117, 3, 0, 10, 10, 42, 42, 57, 57, 3, 0, 16, 16, 105,
        105, 116, 119, 1, 0, 106, 108, 1, 0, 104, 105, 1, 0, 101, 103, 1, 0, 112, 115, 1, 0,
        110, 111, 1, 0, 118, 119, 1, 0, 83, 94, 5, 0, 21, 21, 29, 29, 31, 31, 55, 55, 130, 130,
        2, 0, 25, 25, 60, 60, 1, 0, 122, 123, 2, 0, 126, 126, 128, 128, 2, 0, 156, 156, 165,
        165, 2, 0, 147, 147, 154, 154, 1478, 0, 200, 1, 0, 0, 0, 2, 205, 1, 0, 0, 0, 4, 213, 1,
        0, 0, 0, 6, 233, 1, 0, 0, 0, 8, 238, 1, 0, 0, 0, 10, 240, 1, 0, 0, 0, 12, 252, 1, 0, 0, 0,
        14, 268, 1, 0, 0, 0, 16, 282, 1, 0, 0, 0, 18, 293, 1, 0, 0, 0, 20, 302, 1, 0, 0, 0, 22, 318,
        1, 0, 0, 0, 24, 320, 1, 0, 0, 0, 26, 324, 1, 0, 0, 0, 28, 351, 1, 0, 0, 0, 30, 359, 1, 0,
        0, 0, 32, 363, 1, 0, 0, 0, 34, 365, 1, 0, 0, 0, 36, 373, 1, 0, 0, 0, 38, 380, 1, 0, 0, 0,
        40, 403, 1, 0, 0, 0, 42, 405, 1, 0, 0, 0, 44, 419, 1, 0, 0, 0, 46, 462, 1, 0, 0, 0, 48, 487,
        1, 0, 0, 0, 50, 512, 1, 0, 0, 0, 52, 553, 1, 0, 0, 0, 54, 579, 1, 0, 0, 0, 56, 589, 1, 0,
        0, 0, 58, 593, 1, 0, 0, 0, 60, 606, 1, 0, 0, 0, 62, 612, 1, 0, 0, 0, 64, 644, 1, 0, 0, 0,
        66, 651, 1, 0, 0, 0, 68, 658, 1, 0, 0, 0, 70, 677, 1, 0, 0, 0, 72, 681, 1, 0, 0, 0, 74, 697,
        1, 0, 0, 0, 76, 699, 1, 0, 0, 0, 78, 737, 1, 0, 0, 0, 80, 762, 1, 0, 0, 0, 82, 764, 1, 0,
        0, 0, 84, 790, 1, 0, 0, 0, 86, 796, 1, 0, 0, 0, 88, 818, 1, 0, 0, 0, 90, 907, 1, 0, 0, 0,
        92, 909, 1, 0, 0, 0, 94, 924, 1, 0, 0, 0, 96, 935, 1, 0, 0, 0, 98, 942, 1, 0, 0, 0, 100,
        944, 1, 0, 0, 0, 102, 947, 1, 0, 0, 0, 104, 950, 1, 0, 0, 0, 106, 955, 1, 0, 0, 0, 108,
        960, 1, 0, 0, 0, 110, 964, 1, 0, 0, 0, 112, 966, 1, 0, 0, 0, 114, 976, 1, 0, 0, 0, 116,
        992, 1, 0, 0, 0, 118, 996, 1, 0, 0, 0, 120, 998, 1, 0, 0, 0, 122, 1007, 1, 0, 0, 0, 124,
        1023, 1, 0, 0, 0, 126, 1029, 1, 0, 0, 0, 128, 1037, 1, 0, 0, 0, 130, 1040, 1, 0, 0, 0,
        132, 1043, 1, 0, 0, 0, 134, 1058, 1, 0, 0, 0, 136, 1070, 1, 0, 0, 0, 138, 1076, 1, 0,
        0, 0, 140, 1081, 1, 0, 0, 0, 142, 1086, 1, 0, 0, 0, 144, 1102, 1, 0, 0, 0, 146, 1113,
        1, 0, 0, 0, 148, 1121, 1, 0, 0, 0, 150, 1150, 1, 0, 0, 0, 152, 1154, 1, 0, 0, 0, 154, 1157,
        1, 0, 0, 0, 156, 1172, 1, 0, 0, 0, 158, 1185, 1, 0, 0, 0, 160, 1187, 1, 0, 0, 0, 162, 1215,
        1, 0, 0, 0, 164, 1231, 1, 0, 0, 0, 166, 1233, 1, 0, 0, 0, 168, 1237, 1, 0, 0, 0, 170, 1243,
        1, 0, 0, 0, 172, 1247, 1, 0, 0, 0, 174, 1262, 1, 0, 0, 0, 176, 1289, 1, 0, 0, 0, 178, 1297,
        1, 0, 0, 0, 180, 1311, 1, 0, 0, 0, 182, 1318, 1, 0, 0, 0, 184, 1323, 1, 0, 0, 0, 186, 199,
        3, 2, 1, 0, 187, 199, 3, 4, 2, 0, 188, 199, 3, 76, 38, 0, 189, 199, 3, 12, 6, 0, 190, 199,
        3, 14, 7, 0, 191, 199, 3, 16, 8, 0, 192, 199, 3, 46, 23, 0, 193, 199, 3, 64, 32, 0, 194,
        199, 3, 54, 27, 0, 195, 199, 3, 58, 29, 0, 196, 199, 3, 60, 30, 0, 197, 199, 3, 72, 36,
        0, 198, 186, 1, 0, 0, 0, 198, 187, 1, 0, 0, 0, 198, 188, 1, 0, 0, 0, 198, 189, 1, 0, 0,
        0, 198, 190, 1, 0, 0, 0, 198, 191, 1, 0, 0, 0, 198, 192, 1, 0, 0, 0, 198, 193, 1, 0, 0,
        0, 198, 194, 1, 0, 0, 0, 198, 195, 1, 0, 0, 0, 198, 196, 1, 0, 0, 0, 198, 197, 1, 0, 0,
        0, 199, 202, 1, 0, 0, 0, 200, 198, 1, 0, 0, 0, 200, 201, 1, 0, 0, 0, 201, 203, 1, 0, 0,
        0, 202, 200, 1, 0, 0, 0, 203, 204, 5, 0, 0, 1, 204, 1, 1, 0, 0, 0, 205, 207, 5, 48, 0, 0,
        206, 208, 5, 173, 0, 0, 207, 206, 1, 0, 0, 0, 208, 209, 1, 0, 0, 0, 209, 207, 1, 0, 0,
        0, 209, 210, 1, 0, 0, 0, 210, 211, 1, 0, 0, 0, 211, 212, 5, 174, 0, 0, 212, 3, 1, 0, 0,
        0, 213, 229, 5, 35, 0, 0, 214, 217, 3, 8, 4, 0, 215, 216, 5, 5, 0, 0, 216, 218, 3, 96,
        48, 0, 217, 215, 1, 0, 0, 0, 217, 218, 1, 0, 0, 0, 218, 230, 1, 0, 0, 0, 219, 220, 3, 10,
        5, 0, 220, 221, 5, 29, 0, 0, 221, 222, 3, 8, 4, 0, 222, 230, 1, 0, 0, 0, 223, 224, 5, 106,
        0, 0, 224, 225, 5, 5, 0, 0, 225, 226, 3, 96, 48, 0, 226, 227, 5, 29, 0, 0, 227, 228, 3,
        8, 4, 0, 228, 230, 1, 0, 0, 0, 229, 214, 1, 0, 0, 0, 229, 219, 1, 0, 0, 0, 229, 223, 1,
        0, 0, 0, 230, 231, 1, 0, 0, 0, 231, 232, 5, 78, 0, 0, 232, 5, 1, 0, 0, 0, 233, 236, 3, 96,
        48, 0, 234, 235, 5, 5, 0, 0, 235, 237, 3, 96, 48, 0, 236, 234, 1, 0, 0, 0, 236, 237, 1,
        0, 0, 0, 237, 7, 1, 0, 0, 0, 238, 239, 5, 122, 0, 0, 239, 9, 1, 0, 0, 0, 240, 241, 5, 75,
        0, 0, 241, 246, 3, 6, 3, 0, 242, 243, 5, 95, 0, 0, 243, 245, 3, 6, 3, 0, 244, 242, 1, 0,
        0, 0, 245, 248, 1, 0, 0, 0, 246, 244, 1, 0, 0, 0, 246, 247, 1, 0, 0, 0, 247, 249, 1, 0,
        0, 0, 248, 246, 1, 0, 0, 0, 249, 250, 5, 76, 0, 0, 250, 11, 1, 0, 0, 0, 251, 253, 5, 2,
        0, 0, 252, 251, 1, 0, 0, 0, 252, 253, 1, 0, 0, 0, 253, 254, 1, 0, 0, 0, 254, 255, 5, 15,
        0, 0, 255, 257, 3, 96, 48, 0, 256, 258, 3, 18, 9, 0, 257, 256, 1, 0, 0, 0, 257, 258, 1,
        0, 0, 0, 258, 259, 1, 0, 0, 0, 259, 263, 5, 75, 0, 0, 260, 262, 3, 22, 11, 0, 261, 260,
        1, 0, 0, 0, 262, 265, 1, 0, 0, 0, 263, 261, 1, 0, 0, 0, 263, 264, 1, 0, 0, 0, 264, 266,
        1, 0, 0, 0, 265, 263, 1, 0, 0, 0, 266, 267, 5, 76, 0, 0, 267, 13, 1, 0, 0, 0, 268, 269,
        5, 37, 0, 0, 269, 271, 3, 96, 48, 0, 270, 272, 3, 18, 9, 0, 271, 270, 1, 0, 0, 0, 271,
        272, 1, 0, 0, 0, 272, 273, 1, 0, 0, 0, 273, 277, 5, 75, 0, 0, 274, 276, 3, 22, 11, 0, 275,
        274, 1, 0, 0, 0, 276, 279, 1, 0, 0, 0, 277, 275, 1, 0, 0, 0, 277, 278, 1, 0, 0, 0, 278,
        280, 1, 0, 0, 0, 279, 277, 1, 0, 0, 0, 280, 281, 5, 76, 0, 0, 281, 15, 1, 0, 0, 0, 282,
        283, 5, 40, 0, 0, 283, 284, 3, 96, 48, 0, 284, 288, 5, 75, 0, 0, 285, 287, 3, 22, 11,
        0, 286, 285, 1, 0, 0, 0, 287, 290, 1, 0, 0, 0, 288, 286, 1, 0, 0, 0, 288, 289, 1, 0, 0,
        0, 289, 291, 1, 0, 0, 0, 290, 288, 1, 0, 0, 0, 291, 292, 5, 76, 0, 0, 292, 17, 1, 0, 0,
        0, 293, 294, 5, 39, 0, 0, 294, 299, 3, 20, 10, 0, 295, 296, 5, 95, 0, 0, 296, 298, 3,
        20, 10, 0, 297, 295, 1, 0, 0, 0, 298, 301, 1, 0, 0, 0, 299, 300, 1, 0, 0, 0, 299, 297,
        1, 0, 0, 0, 300, 19, 1, 0, 0, 0, 301, 299, 1, 0, 0, 0, 302, 304, 3, 28, 14, 0, 303, 305,
        3, 26, 13, 0, 304, 303, 1, 0, 0, 0, 304, 305, 1, 0, 0, 0, 305, 21, 1, 0, 0, 0, 306, 319,
        3, 38, 19, 0, 307, 319, 3, 44, 22, 0, 308, 319, 3, 48, 24, 0, 309, 319, 3, 50, 25, 0,
        310, 319, 3, 52, 26, 0, 311, 319, 3, 54, 27, 0, 312, 319, 3, 58, 29, 0, 313, 319, 3,
        60, 30, 0, 314, 319, 3, 62, 31, 0, 315, 319, 3, 68, 34, 0, 316, 319, 3, 72, 36, 0, 317,
        319, 3, 76, 38, 0, 318, 306, 1, 0, 0, 0, 318, 307, 1, 0, 0, 0, 318, 308, 1, 0, 0, 0, 318,
        309, 1, 0, 0, 0, 318, 310, 1, 0, 0, 0, 318, 311, 1, 0, 0, 0, 318, 312, 1, 0, 0, 0, 318,
        313, 1, 0, 0, 0, 318, 314, 1, 0, 0, 0, 318, 315, 1, 0, 0, 0, 318, 316, 1, 0, 0, 0, 318,
        317, 1, 0, 0, 0, 319, 23, 1, 0, 0, 0, 320, 321, 3, 96, 48, 0, 321, 322, 5, 77, 0, 0, 322,
        323, 3, 88, 44, 0, 323, 25, 1, 0, 0, 0, 324, 347, 5, 71, 0, 0, 325, 330, 3, 88, 44, 0,
        326, 327, 5, 95, 0, 0, 327, 329, 3, 88, 44, 0, 328, 326, 1, 0, 0, 0, 329, 332, 1, 0, 0,
        0, 330, 328, 1, 0, 0, 0, 330, 331, 1, 0, 0, 0, 331, 334, 1, 0, 0, 0, 332, 330, 1, 0, 0,
        0, 333, 325, 1, 0, 0, 0, 333, 334, 1, 0, 0, 0, 334, 348, 1, 0, 0, 0, 335, 344, 5, 75, 0,
        0, 336, 341, 3, 24, 12, 0, 337, 338, 5, 95, 0, 0, 338, 340, 3, 24, 12, 0, 339, 337, 1,
        0, 0, 0, 340, 343, 1, 0, 0, 0, 341, 339, 1, 0, 0, 0, 341, 342, 1, 0, 0, 0, 342, 345, 1,
        0, 0, 0, 343, 341, 1, 0, 0, 0, 344, 336, 1, 0, 0, 0, 344, 345, 1, 0, 0, 0, 345, 346, 1,
        0, 0, 0, 346, 348, 5, 76, 0, 0, 347, 333, 1, 0, 0, 0, 347, 335, 1, 0, 0, 0, 348, 349, 1,
        0, 0, 0, 349, 350, 5, 72, 0, 0, 350, 27, 1, 0, 0, 0, 351, 356, 3, 96, 48, 0, 352, 353,
        5, 79, 0, 0, 353, 355, 3, 96, 48, 0, 354, 352, 1, 0, 0, 0, 355, 358, 1, 0, 0, 0, 356, 354,
        1, 0, 0, 0, 356, 357, 1, 0, 0, 0, 357, 29, 1, 0, 0, 0, 358, 356, 1, 0, 0, 0, 359, 361, 3,
        28, 14, 0, 360, 362, 3, 26, 13, 0, 361, 360, 1, 0, 0, 0, 361, 362, 1, 0, 0, 0, 362, 31,
        1, 0, 0, 0, 363, 364, 7, 0, 0, 0, 364, 33, 1, 0, 0, 0, 365, 370, 3, 36, 18, 0, 366, 367,
        5, 95, 0, 0, 367, 369, 3, 36, 18, 0, 368, 366, 1, 0, 0, 0, 369, 372, 1, 0, 0, 0, 370, 368,
        1, 0, 0, 0, 370, 371, 1, 0, 0, 0, 371, 35, 1, 0, 0, 0, 372, 370, 1, 0, 0, 0, 373, 375, 3,
        78, 39, 0, 374, 376, 3, 86, 43, 0, 375, 374, 1, 0, 0, 0, 375, 376, 1, 0, 0, 0, 376, 378,
        1, 0, 0, 0, 377, 379, 3, 96, 48, 0, 378, 377, 1, 0, 0, 0, 378, 379, 1, 0, 0, 0, 379, 37,
        1, 0, 0, 0, 380, 381, 5, 13, 0, 0, 381, 383, 5, 71, 0, 0, 382, 384, 3, 34, 17, 0, 383,
        382, 1, 0, 0, 0, 383, 384, 1, 0, 0, 0, 384, 385, 1, 0, 0, 0, 385, 398, 5, 72, 0, 0, 386,
        397, 3, 30, 15, 0, 387, 388, 4, 19, 0, 1, 388, 389, 5, 47, 0, 0, 389, 397, 6, 19, -1,
        0, 390, 391, 4, 19, 1, 1, 391, 392, 5, 38, 0, 0, 392, 397, 6, 19, -1, 0, 393, 394, 4,
        19, 2, 1, 394, 395, 5, 50, 0, 0, 395, 397, 6, 19, -1, 0, 396, 386, 1, 0, 0, 0, 396, 387,
        1, 0, 0, 0, 396, 390, 1, 0, 0, 0, 396, 393, 1, 0, 0, 0, 397, 400, 1, 0, 0, 0, 398, 396,
        1, 0, 0, 0, 398, 399, 1, 0, 0, 0, 399, 401, 1, 0, 0, 0, 400, 398, 1, 0, 0, 0, 401, 402,
        3, 112, 56, 0, 402, 39, 1, 0, 0, 0, 403, 404, 7, 1, 0, 0, 404, 41, 1, 0, 0, 0, 405, 417,
        5, 46, 0, 0, 406, 407, 5, 71, 0, 0, 407, 412, 3, 28, 14, 0, 408, 409, 5, 95, 0, 0, 409,
        411, 3, 28, 14, 0, 410, 408, 1, 0, 0, 0, 411, 414, 1, 0, 0, 0, 412, 410, 1, 0, 0, 0, 412,
        413, 1, 0, 0, 0, 413, 415, 1, 0, 0, 0, 414, 412, 1, 0, 0, 0, 415, 416, 5, 72, 0, 0, 416,
        418, 1, 0, 0, 0, 417, 406, 1, 0, 0, 0, 417, 418, 1, 0, 0, 0, 418, 43, 1, 0, 0, 0, 419, 423,
        5, 30, 0, 0, 420, 424, 3, 96, 48, 0, 421, 424, 5, 24, 0, 0, 422, 424, 5, 52, 0, 0, 423,
        420, 1, 0, 0, 0, 423, 421, 1, 0, 0, 0, 423, 422, 1, 0, 0, 0, 424, 425, 1, 0, 0, 0, 425,
        427, 5, 71, 0, 0, 426, 428, 3, 34, 17, 0, 427, 426, 1, 0, 0, 0, 427, 428, 1, 0, 0, 0, 428,
        429, 1, 0, 0, 0, 429, 448, 5, 72, 0, 0, 430, 431, 4, 22, 3, 1, 431, 432, 3, 32, 16, 0,
        432, 433, 6, 22, -1, 0, 433, 447, 1, 0, 0, 0, 434, 435, 4, 22, 4, 1, 435, 436, 3, 40,
        20, 0, 436, 437, 6, 22, -1, 0, 437, 447, 1, 0, 0, 0, 438, 447, 3, 30, 15, 0, 439, 440,
        4, 22, 5, 1, 440, 441, 5, 69, 0, 0, 441, 447, 6, 22, -1, 0, 442, 443, 4, 22, 6, 1, 443,
        444, 3, 42, 21, 0, 444, 445, 6, 22, -1, 0, 445, 447, 1, 0, 0, 0, 446, 430, 1, 0, 0, 0,
        446, 434, 1, 0, 0, 0, 446, 438, 1, 0, 0, 0, 446, 439, 1, 0, 0, 0, 446, 442, 1, 0, 0, 0,
        447, 450, 1, 0, 0, 0, 448, 446, 1, 0, 0, 0, 448, 449, 1, 0, 0, 0, 449, 456, 1, 0, 0, 0,
        450, 448, 1, 0, 0, 0, 451, 452, 5, 54, 0, 0, 452, 453, 5, 71, 0, 0, 453, 454, 3, 34, 17,
        0, 454, 455, 5, 72, 0, 0, 455, 457, 1, 0, 0, 0, 456, 451, 1, 0, 0, 0, 456, 457, 1, 0, 0,
        0, 457, 460, 1, 0, 0, 0, 458, 461, 5, 78, 0, 0, 459, 461, 3, 112, 56, 0, 460, 458, 1,
        0, 0, 0, 460, 459, 1, 0, 0, 0, 461, 45, 1, 0, 0, 0, 462, 466, 5, 30, 0, 0, 463, 467, 3,
        96, 48, 0, 464, 467, 5, 24, 0, 0, 465, 467, 5, 52, 0, 0, 466, 463, 1, 0, 0, 0, 466, 464,
        1, 0, 0, 0, 466, 465, 1, 0, 0, 0, 467, 468, 1, 0, 0, 0, 468, 470, 5, 71, 0, 0, 469, 471,
        3, 34, 17, 0, 470, 469, 1, 0, 0, 0, 470, 471, 1, 0, 0, 0, 471, 472, 1, 0, 0, 0, 472, 474,
        5, 72, 0, 0, 473, 475, 3, 40, 20, 0, 474, 473, 1, 0, 0, 0, 474, 475, 1, 0, 0, 0, 475, 481,
        1, 0, 0, 0, 476, 477, 5, 54, 0, 0, 477, 478, 5, 71, 0, 0, 478, 479, 3, 34, 17, 0, 479,
        480, 5, 72, 0, 0, 480, 482, 1, 0, 0, 0, 481, 476, 1, 0, 0, 0, 481, 482, 1, 0, 0, 0, 482,
        485, 1, 0, 0, 0, 483, 486, 5, 78, 0, 0, 484, 486, 3, 112, 56, 0, 485, 483, 1, 0, 0, 0,
        485, 484, 1, 0, 0, 0, 486, 47, 1, 0, 0, 0, 487, 488, 5, 43, 0, 0, 488, 494, 3, 96, 48,
        0, 489, 491, 5, 71, 0, 0, 490, 492, 3, 34, 17, 0, 491, 490, 1, 0, 0, 0, 491, 492, 1, 0,
        0, 0, 492, 493, 1, 0, 0, 0, 493, 495, 5, 72, 0, 0, 494, 489, 1, 0, 0, 0, 494, 495, 1, 0,
        0, 0, 495, 505, 1, 0, 0, 0, 496, 497, 4, 24, 7, 1, 497, 498, 5, 69, 0, 0, 498, 504, 6,
        24, -1, 0, 499, 500, 4, 24, 8, 1, 500, 501, 3, 42, 21, 0, 501, 502, 6, 24, -1, 0, 502,
        504, 1, 0, 0, 0, 503, 496, 1, 0, 0, 0, 503, 499, 1, 0, 0, 0, 504, 507, 1, 0, 0, 0, 505,
        503, 1, 0, 0, 0, 505, 506, 1, 0, 0, 0, 506, 510, 1, 0, 0, 0, 507, 505, 1, 0, 0, 0, 508,
        511, 5, 78, 0, 0, 509, 511, 3, 112, 56, 0, 510, 508, 1, 0, 0, 0, 510, 509, 1, 0, 0, 0,
        511, 49, 1, 0, 0, 0, 512, 513, 5, 24, 0, 0, 513, 517, 5, 71, 0, 0, 514, 515, 3, 34, 17,
        0, 515, 516, 6, 25, -1, 0, 516, 518, 1, 0, 0, 0, 517, 514, 1, 0, 0, 0, 517, 518, 1, 0,
        0, 0, 518, 519, 1, 0, 0, 0, 519, 537, 5, 72, 0, 0, 520, 521, 4, 25, 9, 1, 521, 522, 5,
        23, 0, 0, 522, 536, 6, 25, -1, 0, 523, 524, 4, 25, 10, 1, 524, 525, 3, 40, 20, 0, 525,
        526, 6, 25, -1, 0, 526, 536, 1, 0, 0, 0, 527, 536, 3, 30, 15, 0, 528, 529, 4, 25, 11,
        1, 529, 530, 5, 69, 0, 0, 530, 536, 6, 25, -1, 0, 531, 532, 4, 25, 12, 1, 532, 533, 3,
        42, 21, 0, 533, 534, 6, 25, -1, 0, 534, 536, 1, 0, 0, 0, 535, 520, 1, 0, 0, 0, 535, 523,
        1, 0, 0, 0, 535, 527, 1, 0, 0, 0, 535, 528, 1, 0, 0, 0, 535, 531, 1, 0, 0, 0, 536, 539,
        1, 0, 0, 0, 537, 535, 1, 0, 0, 0, 537, 538, 1, 0, 0, 0, 538, 547, 1, 0, 0, 0, 539, 537,
        1, 0, 0, 0, 540, 541, 4, 25, 13, 1, 541, 542, 5, 54, 0, 0, 542, 543, 5, 71, 0, 0, 543,
        544, 3, 34, 17, 0, 544, 545, 5, 72, 0, 0, 545, 548, 1, 0, 0, 0, 546, 548, 4, 25, 14, 1,
        547, 540, 1, 0, 0, 0, 547, 546, 1, 0, 0, 0, 548, 551, 1, 0, 0, 0, 549, 552, 5, 78, 0, 0,
        550, 552, 3, 112, 56, 0, 551, 549, 1, 0, 0, 0, 551, 550, 1, 0, 0, 0, 552, 51, 1, 0, 0,
        0, 553, 554, 5, 52, 0, 0, 554, 555, 5, 71, 0, 0, 555, 572, 5, 72, 0, 0, 556, 557, 4, 26,
        15, 1, 557, 558, 5, 23, 0, 0, 558, 571, 6, 26, -1, 0, 559, 560, 4, 26, 16, 1, 560, 561,
        5, 47, 0, 0, 561, 571, 6, 26, -1, 0, 562, 571, 3, 30, 15, 0, 563, 564, 4, 26, 17, 1, 564,
        565, 5, 69, 0, 0, 565, 571, 6, 26, -1, 0, 566, 567, 4, 26, 18, 1, 567, 568, 3, 42, 21,
        0, 568, 569, 6, 26, -1, 0, 569, 571, 1, 0, 0, 0, 570, 556, 1, 0, 0, 0, 570, 559, 1, 0,
        0, 0, 570, 562, 1, 0, 0, 0, 570, 563, 1, 0, 0, 0, 570, 566, 1, 0, 0, 0, 571, 574, 1, 0,
        0, 0, 572, 570, 1, 0, 0, 0, 572, 573, 1, 0, 0, 0, 573, 577, 1, 0, 0, 0, 574, 572, 1, 0,
        0, 0, 575, 578, 5, 78, 0, 0, 576, 578, 3, 112, 56, 0, 577, 575, 1, 0, 0, 0, 577, 576,
        1, 0, 0, 0, 578, 53, 1, 0, 0, 0, 579, 580, 5, 59, 0, 0, 580, 581, 3, 96, 48, 0, 581, 583,
        5, 75, 0, 0, 582, 584, 3, 56, 28, 0, 583, 582, 1, 0, 0, 0, 584, 585, 1, 0, 0, 0, 585, 583,
        1, 0, 0, 0, 585, 586, 1, 0, 0, 0, 586, 587, 1, 0, 0, 0, 587, 588, 5, 76, 0, 0, 588, 55,
        1, 0, 0, 0, 589, 590, 3, 78, 39, 0, 590, 591, 3, 96, 48, 0, 591, 592, 5, 78, 0, 0, 592,
        57, 1, 0, 0, 0, 593, 594, 5, 20, 0, 0, 594, 595, 3, 96, 48, 0, 595, 596, 5, 75, 0, 0, 596,
        601, 3, 96, 48, 0, 597, 598, 5, 95, 0, 0, 598, 600, 3, 96, 48, 0, 599, 597, 1, 0, 0, 0,
        600, 603, 1, 0, 0, 0, 601, 599, 1, 0, 0, 0, 601, 602, 1, 0, 0, 0, 602, 604, 1, 0, 0, 0,
        603, 601, 1, 0, 0, 0, 604, 605, 5, 76, 0, 0, 605, 59, 1, 0, 0, 0, 606, 607, 5, 62, 0, 0,
        607, 608, 3, 96, 48, 0, 608, 609, 5, 39, 0, 0, 609, 610, 3, 80, 40, 0, 610, 611, 5, 78,
        0, 0, 611, 61, 1, 0, 0, 0, 612, 634, 3, 78, 39, 0, 613, 614, 4, 31, 19, 1, 614, 615, 5,
        50, 0, 0, 615, 633, 6, 31, -1, 0, 616, 617, 4, 31, 20, 1, 617, 618, 5, 49, 0, 0, 618,
        633, 6, 31, -1, 0, 619, 620, 4, 31, 21, 1, 620, 621, 5, 38, 0, 0, 621, 633, 6, 31, -1,
        0, 622, 623, 4, 31, 22, 1, 623, 624, 5, 12, 0, 0, 624, 633, 6, 31, -1, 0, 625, 626, 4,
        31, 23, 1, 626, 627, 3, 42, 21, 0, 627, 628, 6, 31, -1, 0, 628, 633, 1, 0, 0, 0, 629,
        630, 4, 31, 24, 1, 630, 631, 5, 34, 0, 0, 631, 633, 6, 31, -1, 0, 632, 613, 1, 0, 0, 0,
        632, 616, 1, 0, 0, 0, 632, 619, 1, 0, 0, 0, 632, 622, 1, 0, 0, 0, 632, 625, 1, 0, 0, 0,
        632, 629, 1, 0, 0, 0, 633, 636, 1, 0, 0, 0, 634, 632, 1, 0, 0, 0, 634, 635, 1, 0, 0, 0,
        635, 637, 1, 0, 0, 0, 636, 634, 1, 0, 0, 0, 637, 640, 3, 96, 48, 0, 638, 639, 5, 83, 0,
        0, 639, 641, 3, 88, 44, 0, 640, 638, 1, 0, 0, 0, 640, 641, 1, 0, 0, 0, 641, 642, 1, 0,
        0, 0, 642, 643, 5, 78, 0, 0, 643, 63, 1, 0, 0, 0, 644, 645, 3, 78, 39, 0, 645, 646, 5,
        12, 0, 0, 646, 647, 3, 96, 48, 0, 647, 648, 5, 83, 0, 0, 648, 649, 3, 88, 44, 0, 649,
        650, 5, 78, 0, 0, 650, 65, 1, 0, 0, 0, 651, 653, 3, 78, 39, 0, 652, 654, 5, 36, 0, 0, 653,
        652, 1, 0, 0, 0, 653, 654, 1, 0, 0, 0, 654, 656, 1, 0, 0, 0, 655, 657, 3, 96, 48, 0, 656,
        655, 1, 0, 0, 0, 656, 657, 1, 0, 0, 0, 657, 67, 1, 0, 0, 0, 658, 659, 5, 22, 0, 0, 659,
        660, 3, 96, 48, 0, 660, 669, 5, 71, 0, 0, 661, 666, 3, 66, 33, 0, 662, 663, 5, 95, 0,
        0, 663, 665, 3, 66, 33, 0, 664, 662, 1, 0, 0, 0, 665, 668, 1, 0, 0, 0, 666, 664, 1, 0,
        0, 0, 666, 667, 1, 0, 0, 0, 667, 670, 1, 0, 0, 0, 668, 666, 1, 0, 0, 0, 669, 661, 1, 0,
        0, 0, 669, 670, 1, 0, 0, 0, 670, 671, 1, 0, 0, 0, 671, 673, 5, 72, 0, 0, 672, 674, 5, 4,
        0, 0, 673, 672, 1, 0, 0, 0, 673, 674, 1, 0, 0, 0, 674, 675, 1, 0, 0, 0, 675, 676, 5, 78,
        0, 0, 676, 69, 1, 0, 0, 0, 677, 679, 3, 78, 39, 0, 678, 680, 3, 96, 48, 0, 679, 678, 1,
        0, 0, 0, 679, 680, 1, 0, 0, 0, 680, 71, 1, 0, 0, 0, 681, 682, 5, 21, 0, 0, 682, 683, 3,
        96, 48, 0, 683, 692, 5, 71, 0, 0, 684, 689, 3, 70, 35, 0, 685, 686, 5, 95, 0, 0, 686,
        688, 3, 70, 35, 0, 687, 685, 1, 0, 0, 0, 688, 691, 1, 0, 0, 0, 689, 687, 1, 0, 0, 0, 689,
        690, 1, 0, 0, 0, 690, 693, 1, 0, 0, 0, 691, 689, 1, 0, 0, 0, 692, 684, 1, 0, 0, 0, 692,
        693, 1, 0, 0, 0, 693, 694, 1, 0, 0, 0, 694, 695, 5, 72, 0, 0, 695, 696, 5, 78, 0, 0, 696,
        73, 1, 0, 0, 0, 697, 698, 7, 2, 0, 0, 698, 75, 1, 0, 0, 0, 699, 720, 5, 67, 0, 0, 700, 721,
        3, 28, 14, 0, 701, 702, 5, 75, 0, 0, 702, 705, 3, 28, 14, 0, 703, 704, 5, 5, 0, 0, 704,
        706, 3, 74, 37, 0, 705, 703, 1, 0, 0, 0, 705, 706, 1, 0, 0, 0, 706, 715, 1, 0, 0, 0, 707,
        708, 5, 95, 0, 0, 708, 711, 3, 28, 14, 0, 709, 710, 5, 5, 0, 0, 710, 712, 3, 74, 37, 0,
        711, 709, 1, 0, 0, 0, 711, 712, 1, 0, 0, 0, 712, 714, 1, 0, 0, 0, 713, 707, 1, 0, 0, 0,
        714, 717, 1, 0, 0, 0, 715, 713, 1, 0, 0, 0, 715, 716, 1, 0, 0, 0, 716, 718, 1, 0, 0, 0,
        717, 715, 1, 0, 0, 0, 718, 719, 5, 76, 0, 0, 719, 721, 1, 0, 0, 0, 720, 700, 1, 0, 0, 0,
        720, 701, 1, 0, 0, 0, 721, 722, 1, 0, 0, 0, 722, 725, 5, 28, 0, 0, 723, 726, 5, 106, 0,
        0, 724, 726, 3, 78, 39, 0, 725, 723, 1, 0, 0, 0, 725, 724, 1, 0, 0, 0, 726, 728, 1, 0,
        0, 0, 727, 729, 5, 31, 0, 0, 728, 727, 1, 0, 0, 0, 728, 729, 1, 0, 0, 0, 729, 730, 1, 0,
        0, 0, 730, 731, 5, 78, 0, 0, 731, 77, 1, 0, 0, 0, 732, 733, 6, 39, -1, 0, 733, 738, 3,
        80, 40, 0, 734, 738, 3, 82, 41, 0, 735, 738, 3, 154, 77, 0, 736, 738, 3, 28, 14, 0, 737,
        732, 1, 0, 0, 0, 737, 734, 1, 0, 0, 0, 737, 735, 1, 0, 0, 0, 737, 736, 1, 0, 0, 0, 738,
        747, 1, 0, 0, 0, 739, 740, 10, 1, 0, 0, 740, 742, 5, 73, 0, 0, 741, 743, 3, 88, 44, 0,
        742, 741, 1, 0, 0, 0, 742, 743, 1, 0, 0, 0, 743, 744, 1, 0, 0, 0, 744, 746, 5, 74, 0, 0,
        745, 739, 1, 0, 0, 0, 746, 749, 1, 0, 0, 0, 747, 745, 1, 0, 0, 0, 747, 748, 1, 0, 0, 0,
        748, 79, 1, 0, 0, 0, 749, 747, 1, 0, 0, 0, 750, 763, 5, 3, 0, 0, 751, 752, 4, 40, 26, 1,
        752, 753, 5, 3, 0, 0, 753, 763, 5, 47, 0, 0, 754, 763, 5, 7, 0, 0, 755, 763, 5, 58, 0,
        0, 756, 763, 5, 9, 0, 0, 757, 763, 5, 56, 0, 0, 758, 763, 5, 66, 0, 0, 759, 763, 5, 27,
        0, 0, 760, 763, 5, 26, 0, 0, 761, 763, 5, 63, 0, 0, 762, 750, 1, 0, 0, 0, 762, 751, 1,
        0, 0, 0, 762, 754, 1, 0, 0, 0, 762, 755, 1, 0, 0, 0, 762, 756, 1, 0, 0, 0, 762, 757, 1,
        0, 0, 0, 762, 758, 1, 0, 0, 0, 762, 759, 1, 0, 0, 0, 762, 760, 1, 0, 0, 0, 762, 761, 1,
        0, 0, 0, 763, 81, 1, 0, 0, 0, 764, 765, 5, 30, 0, 0, 765, 767, 5, 71, 0, 0, 766, 768, 3,
        34, 17, 0, 767, 766, 1, 0, 0, 0, 767, 768, 1, 0, 0, 0, 768, 769, 1, 0, 0, 0, 769, 780,
        5, 72, 0, 0, 770, 771, 4, 41, 27, 1, 771, 772, 3, 32, 16, 0, 772, 773, 6, 41, -1, 0, 773,
        779, 1, 0, 0, 0, 774, 775, 4, 41, 28, 1, 775, 776, 3, 40, 20, 0, 776, 777, 6, 41, -1,
        0, 777, 779, 1, 0, 0, 0, 778, 770, 1, 0, 0, 0, 778, 774, 1, 0, 0, 0, 779, 782, 1, 0, 0,
        0, 780, 778, 1, 0, 0, 0, 780, 781, 1, 0, 0, 0, 781, 788, 1, 0, 0, 0, 782, 780, 1, 0, 0,
        0, 783, 784, 5, 54, 0, 0, 784, 785, 5, 71, 0, 0, 785, 786, 3, 34, 17, 0, 786, 787, 5,
        72, 0, 0, 787, 789, 1, 0, 0, 0, 788, 783, 1, 0, 0, 0, 788, 789, 1, 0, 0, 0, 789, 83, 1,
        0, 0, 0, 790, 792, 3, 78, 39, 0, 791, 793, 3, 86, 43, 0, 792, 791, 1, 0, 0, 0, 792, 793,
        1, 0, 0, 0, 793, 794, 1, 0, 0, 0, 794, 795, 3, 96, 48, 0, 795, 85, 1, 0, 0, 0, 796, 797,
        7, 3, 0, 0, 797, 87, 1, 0, 0, 0, 798, 799, 6, 44, -1, 0, 799, 800, 5, 47, 0, 0, 800, 819,
        3, 26, 13, 0, 801, 802, 5, 62, 0, 0, 802, 803, 5, 71, 0, 0, 803, 804, 3, 78, 39, 0, 804,
        805, 5, 72, 0, 0, 805, 819, 1, 0, 0, 0, 806, 807, 7, 4, 0, 0, 807, 819, 3, 88, 44, 19,
        808, 809, 5, 44, 0, 0, 809, 819, 3, 78, 39, 0, 810, 819, 3, 92, 46, 0, 811, 819, 3, 94,
        47, 0, 812, 817, 3, 96, 48, 0, 813, 817, 3, 98, 49, 0, 814, 817, 3, 100, 50, 0, 815,
        817, 3, 80, 40, 0, 816, 812, 1, 0, 0, 0, 816, 813, 1, 0, 0, 0, 816, 814, 1, 0, 0, 0, 816,
        815, 1, 0, 0, 0, 817, 819, 1, 0, 0, 0, 818, 798, 1, 0, 0, 0, 818, 801, 1, 0, 0, 0, 818,
        806, 1, 0, 0, 0, 818, 808, 1, 0, 0, 0, 818, 810, 1, 0, 0, 0, 818, 811, 1, 0, 0, 0, 818,
        816, 1, 0, 0, 0, 819, 904, 1, 0, 0, 0, 820, 821, 10, 17, 0, 0, 821, 822, 5, 109, 0, 0,
        822, 903, 3, 88, 44, 17, 823, 824, 10, 16, 0, 0, 824, 825, 7, 5, 0, 0, 825, 903, 3, 88,
        44, 17, 826, 827, 10, 15, 0, 0, 827, 828, 7, 6, 0, 0, 828, 903, 3, 88, 44, 16, 829, 830,
        10, 14, 0, 0, 830, 831, 7, 7, 0, 0, 831, 903, 3, 88, 44, 15, 832, 833, 10, 13, 0, 0, 833,
        834, 5, 100, 0, 0, 834, 903, 3, 88, 44, 14, 835, 836, 10, 12, 0, 0, 836, 837, 5, 99,
        0, 0, 837, 903, 3, 88, 44, 13, 838, 839, 10, 11, 0, 0, 839, 840, 5, 98, 0, 0, 840, 903,
        3, 88, 44, 12, 841, 842, 10, 10, 0, 0, 842, 843, 7, 8, 0, 0, 843, 903, 3, 88, 44, 11,
        844, 845, 10, 9, 0, 0, 845, 846, 7, 9, 0, 0, 846, 903, 3, 88, 44, 10, 847, 848, 10, 8,
        0, 0, 848, 849, 5, 97, 0, 0, 849, 903, 3, 88, 44, 9, 850, 851, 10, 7, 0, 0, 851, 852,
        5, 96, 0, 0, 852, 903, 3, 88, 44, 8, 853, 854, 10, 6, 0, 0, 854, 855, 5, 80, 0, 0, 855,
        856, 3, 88, 44, 0, 856, 857, 5, 77, 0, 0, 857, 858, 3, 88, 44, 6, 858, 903, 1, 0, 0, 0,
        859, 860, 10, 5, 0, 0, 860, 861, 3, 90, 45, 0, 861, 862, 3, 88, 44, 5, 862, 903, 1, 0,
        0, 0, 863, 864, 10, 26, 0, 0, 864, 866, 5, 73, 0, 0, 865, 867, 3, 88, 44, 0, 866, 865,
        1, 0, 0, 0, 866, 867, 1, 0, 0, 0, 867, 868, 1, 0, 0, 0, 868, 903, 5, 74, 0, 0, 869, 870,
        10, 25, 0, 0, 870, 872, 5, 73, 0, 0, 871, 873, 3, 88, 44, 0, 872, 871, 1, 0, 0, 0, 872,
        873, 1, 0, 0, 0, 873, 874, 1, 0, 0, 0, 874, 876, 5, 77, 0, 0, 875, 877, 3, 88, 44, 0, 876,
        875, 1, 0, 0, 0, 876, 877, 1, 0, 0, 0, 877, 878, 1, 0, 0, 0, 878, 903, 5, 74, 0, 0, 879,
        880, 10, 24, 0, 0, 880, 883, 5, 79, 0, 0, 881, 884, 3, 96, 48, 0, 882, 884, 5, 3, 0, 0,
        883, 881, 1, 0, 0, 0, 883, 882, 1, 0, 0, 0, 884, 903, 1, 0, 0, 0, 885, 886, 10, 23, 0,
        0, 886, 895, 5, 75, 0, 0, 887, 892, 3, 24, 12, 0, 888, 889, 5, 95, 0, 0, 889, 891, 3,
        24, 12, 0, 890, 888, 1, 0, 0, 0, 891, 894, 1, 0, 0, 0, 892, 890, 1, 0, 0, 0, 892, 893,
        1, 0, 0, 0, 893, 896, 1, 0, 0, 0, 894, 892, 1, 0, 0, 0, 895, 887, 1, 0, 0, 0, 895, 896,
        1, 0, 0, 0, 896, 897, 1, 0, 0, 0, 897, 903, 5, 76, 0, 0, 898, 899, 10, 22, 0, 0, 899, 903,
        3, 26, 13, 0, 900, 901, 10, 18, 0, 0, 901, 903, 7, 10, 0, 0, 902, 820, 1, 0, 0, 0, 902,
        823, 1, 0, 0, 0, 902, 826, 1, 0, 0, 0, 902, 829, 1, 0, 0, 0, 902, 832, 1, 0, 0, 0, 902,
        835, 1, 0, 0, 0, 902, 838, 1, 0, 0, 0, 902, 841, 1, 0, 0, 0, 902, 844, 1, 0, 0, 0, 902,
        847, 1, 0, 0, 0, 902, 850, 1, 0, 0, 0, 902, 853, 1, 0, 0, 0, 902, 859, 1, 0, 0, 0, 902,
        863, 1, 0, 0, 0, 902, 869, 1, 0, 0, 0, 902, 879, 1, 0, 0, 0, 902, 885, 1, 0, 0, 0, 902,
        898, 1, 0, 0, 0, 902, 900, 1, 0, 0, 0, 903, 906, 1, 0, 0, 0, 904, 902, 1, 0, 0, 0, 904,
        905, 1, 0, 0, 0, 905, 89, 1, 0, 0, 0, 906, 904, 1, 0, 0, 0, 907, 908, 7, 11, 0, 0, 908,
        91, 1, 0, 0, 0, 909, 911, 5, 71, 0, 0, 910, 912, 3, 88, 44, 0, 911, 910, 1, 0, 0, 0, 911,
        912, 1, 0, 0, 0, 912, 919, 1, 0, 0, 0, 913, 915, 5, 95, 0, 0, 914, 916, 3, 88, 44, 0, 915,
        914, 1, 0, 0, 0, 915, 916, 1, 0, 0, 0, 916, 918, 1, 0, 0, 0, 917, 913, 1, 0, 0, 0, 918,
        921, 1, 0, 0, 0, 919, 917, 1, 0, 0, 0, 919, 920, 1, 0, 0, 0, 920, 922, 1, 0, 0, 0, 921,
        919, 1, 0, 0, 0, 922, 923, 5, 72, 0, 0, 923, 93, 1, 0, 0, 0, 924, 925, 5, 73, 0, 0, 925,
        930, 3, 88, 44, 0, 926, 927, 5, 95, 0, 0, 927, 929, 3, 88, 44, 0, 928, 926, 1, 0, 0, 0,
        929, 932, 1, 0, 0, 0, 930, 928, 1, 0, 0, 0, 930, 931, 1, 0, 0, 0, 931, 933, 1, 0, 0, 0,
        932, 930, 1, 0, 0, 0, 933, 934, 5, 74, 0, 0, 934, 95, 1, 0, 0, 0, 935, 936, 7, 12, 0, 0,
        936, 97, 1, 0, 0, 0, 937, 943, 3, 104, 52, 0, 938, 943, 3, 110, 55, 0, 939, 943, 3, 102,
        51, 0, 940, 943, 3, 106, 53, 0, 941, 943, 3, 108, 54, 0, 942, 937, 1, 0, 0, 0, 942, 938,
        1, 0, 0, 0, 942, 939, 1, 0, 0, 0, 942, 940, 1, 0, 0, 0, 942, 941, 1, 0, 0, 0, 943, 99, 1,
        0, 0, 0, 944, 945, 3, 110, 55, 0, 945, 946, 5, 45, 0, 0, 946, 101, 1, 0, 0, 0, 947, 948,
        7, 13, 0, 0, 948, 103, 1, 0, 0, 0, 949, 951, 7, 14, 0, 0, 950, 949, 1, 0, 0, 0, 951, 952,
        1, 0, 0, 0, 952, 950, 1, 0, 0, 0, 952, 953, 1, 0, 0, 0, 953, 105, 1, 0, 0, 0, 954, 956,
        5, 125, 0, 0, 955, 954, 1, 0, 0, 0, 956, 957, 1, 0, 0, 0, 957, 955, 1, 0, 0, 0, 957, 958,
        1, 0, 0, 0, 958, 107, 1, 0, 0, 0, 959, 961, 5, 124, 0, 0, 960, 959, 1, 0, 0, 0, 961, 962,
        1, 0, 0, 0, 962, 960, 1, 0, 0, 0, 962, 963, 1, 0, 0, 0, 963, 109, 1, 0, 0, 0, 964, 965,
        7, 15, 0, 0, 965, 111, 1, 0, 0, 0, 966, 971, 5, 75, 0, 0, 967, 970, 3, 116, 58, 0, 968,
        970, 3, 114, 57, 0, 969, 967, 1, 0, 0, 0, 969, 968, 1, 0, 0, 0, 970, 973, 1, 0, 0, 0, 971,
        969, 1, 0, 0, 0, 971, 972, 1, 0, 0, 0, 972, 974, 1, 0, 0, 0, 973, 971, 1, 0, 0, 0, 974,
        975, 5, 76, 0, 0, 975, 113, 1, 0, 0, 0, 976, 977, 5, 64, 0, 0, 977, 978, 3, 112, 56, 0,
        978, 115, 1, 0, 0, 0, 979, 993, 3, 112, 56, 0, 980, 993, 3, 118, 59, 0, 981, 993, 3,
        120, 60, 0, 982, 993, 3, 122, 61, 0, 983, 993, 3, 124, 62, 0, 984, 993, 3, 126, 63,
        0, 985, 993, 3, 128, 64, 0, 986, 993, 3, 130, 65, 0, 987, 993, 3, 132, 66, 0, 988, 993,
        3, 136, 68, 0, 989, 993, 3, 138, 69, 0, 990, 993, 3, 140, 70, 0, 991, 993, 3, 142, 71,
        0, 992, 979, 1, 0, 0, 0, 992, 980, 1, 0, 0, 0, 992, 981, 1, 0, 0, 0, 992, 982, 1, 0, 0,
        0, 992, 983, 1, 0, 0, 0, 992, 984, 1, 0, 0, 0, 992, 985, 1, 0, 0, 0, 992, 986, 1, 0, 0,
        0, 992, 987, 1, 0, 0, 0, 992, 988, 1, 0, 0, 0, 992, 989, 1, 0, 0, 0, 992, 990, 1, 0, 0,
        0, 992, 991, 1, 0, 0, 0, 993, 117, 1, 0, 0, 0, 994, 997, 3, 150, 75, 0, 995, 997, 3, 152,
        76, 0, 996, 994, 1, 0, 0, 0, 996, 995, 1, 0, 0, 0, 997, 119, 1, 0, 0, 0, 998, 999, 5, 33,
        0, 0, 999, 1000, 5, 71, 0, 0, 1000, 1001, 3, 88, 44, 0, 1001, 1002, 5, 72, 0, 0, 1002,
        1005, 3, 116, 58, 0, 1003, 1004, 5, 18, 0, 0, 1004, 1006, 3, 116, 58, 0, 1005, 1003,
        1, 0, 0, 0, 1005, 1006, 1, 0, 0, 0, 1006, 121, 1, 0, 0, 0, 1007, 1008, 5, 28, 0, 0, 1008,
        1011, 5, 71, 0, 0, 1009, 1012, 3, 118, 59, 0, 1010, 1012, 5, 78, 0, 0, 1011, 1009,
        1, 0, 0, 0, 1011, 1010, 1, 0, 0, 0, 1012, 1015, 1, 0, 0, 0, 1013, 1016, 3, 152, 76, 0,
        1014, 1016, 5, 78, 0, 0, 1015, 1013, 1, 0, 0, 0, 1015, 1014, 1, 0, 0, 0, 1016, 1018,
        1, 0, 0, 0, 1017, 1019, 3, 88, 44, 0, 1018, 1017, 1, 0, 0, 0, 1018, 1019, 1, 0, 0, 0,
        1019, 1020, 1, 0, 0, 0, 1020, 1021, 5, 72, 0, 0, 1021, 1022, 3, 116, 58, 0, 1022, 123,
        1, 0, 0, 0, 1023, 1024, 5, 70, 0, 0, 1024, 1025, 5, 71, 0, 0, 1025, 1026, 3, 88, 44,
        0, 1026, 1027, 5, 72, 0, 0, 1027, 1028, 3, 116, 58, 0, 1028, 125, 1, 0, 0, 0, 1029,
        1030, 5, 17, 0, 0, 1030, 1031, 3, 116, 58, 0, 1031, 1032, 5, 70, 0, 0, 1032, 1033,
        5, 71, 0, 0, 1033, 1034, 3, 88, 44, 0, 1034, 1035, 5, 72, 0, 0, 1035, 1036, 5, 78, 0,
        0, 1036, 127, 1, 0, 0, 0, 1037, 1038, 5, 14, 0, 0, 1038, 1039, 5, 78, 0, 0, 1039, 129,
        1, 0, 0, 0, 1040, 1041, 5, 8, 0, 0, 1041, 1042, 5, 78, 0, 0, 1042, 131, 1, 0, 0, 0, 1043,
        1044, 5, 61, 0, 0, 1044, 1050, 3, 88, 44, 0, 1045, 1046, 5, 54, 0, 0, 1046, 1047, 5,
        71, 0, 0, 1047, 1048, 3, 34, 17, 0, 1048, 1049, 5, 72, 0, 0, 1049, 1051, 1, 0, 0, 0,
        1050, 1045, 1, 0, 0, 0, 1050, 1051, 1, 0, 0, 0, 1051, 1052, 1, 0, 0, 0, 1052, 1054,
        3, 112, 56, 0, 1053, 1055, 3, 134, 67, 0, 1054, 1053, 1, 0, 0, 0, 1055, 1056, 1, 0,
        0, 0, 1056, 1054, 1, 0, 0, 0, 1056, 1057, 1, 0, 0, 0, 1057, 133, 1, 0, 0, 0, 1058, 1066,
        5, 11, 0, 0, 1059, 1061, 3, 96, 48, 0, 1060, 1059, 1, 0, 0, 0, 1060, 1061, 1, 0, 0, 0,
        1061, 1062, 1, 0, 0, 0, 1062, 1063, 5, 71, 0, 0, 1063, 1064, 3, 34, 17, 0, 1064, 1065,
        5, 72, 0, 0, 1065, 1067, 1, 0, 0, 0, 1066, 1060, 1, 0, 0, 0, 1066, 1067, 1, 0, 0, 0, 1067,
        1068, 1, 0, 0, 0, 1068, 1069, 3, 112, 56, 0, 1069, 135, 1, 0, 0, 0, 1070, 1072, 5, 53,
        0, 0, 1071, 1073, 3, 88, 44, 0, 1072, 1071, 1, 0, 0, 0, 1072, 1073, 1, 0, 0, 0, 1073,
        1074, 1, 0, 0, 0, 1074, 1075, 5, 78, 0, 0, 1075, 137, 1, 0, 0, 0, 1076, 1077, 5, 19,
        0, 0, 1077, 1078, 3, 88, 44, 0, 1078, 1079, 3, 26, 13, 0, 1079, 1080, 5, 78, 0, 0, 1080,
        139, 1, 0, 0, 0, 1081, 1082, 5, 55, 0, 0, 1082, 1083, 3, 88, 44, 0, 1083, 1084, 3, 26,
        13, 0, 1084, 1085, 5, 78, 0, 0, 1085, 141, 1, 0, 0, 0, 1086, 1088, 5, 6, 0, 0, 1087,
        1089, 5, 134, 0, 0, 1088, 1087, 1, 0, 0, 0, 1088, 1089, 1, 0, 0, 0, 1089, 1091, 1, 0,
        0, 0, 1090, 1092, 3, 144, 72, 0, 1091, 1090, 1, 0, 0, 0, 1091, 1092, 1, 0, 0, 0, 1092,
        1093, 1, 0, 0, 0, 1093, 1097, 5, 135, 0, 0, 1094, 1096, 3, 158, 79, 0, 1095, 1094,
        1, 0, 0, 0, 1096, 1099, 1, 0, 0, 0, 1097, 1095, 1, 0, 0, 0, 1097, 1098, 1, 0, 0, 0, 1098,
        1100, 1, 0, 0, 0, 1099, 1097, 1, 0, 0, 0, 1100, 1101, 5, 158, 0, 0, 1101, 143, 1, 0,
        0, 0, 1102, 1103, 5, 137, 0, 0, 1103, 1108, 5, 136, 0, 0, 1104, 1105, 5, 139, 0, 0,
        1105, 1107, 5, 136, 0, 0, 1106, 1104, 1, 0, 0, 0, 1107, 1110, 1, 0, 0, 0, 1108, 1106,
        1, 0, 0, 0, 1108, 1109, 1, 0, 0, 0, 1109, 1111, 1, 0, 0, 0, 1110, 1108, 1, 0, 0, 0, 1111,
        1112, 5, 138, 0, 0, 1112, 145, 1, 0, 0, 0, 1113, 1118, 3, 84, 42, 0, 1114, 1115, 5,
        95, 0, 0, 1115, 1117, 3, 84, 42, 0, 1116, 1114, 1, 0, 0, 0, 1117, 1120, 1, 0, 0, 0, 1118,
        1116, 1, 0, 0, 0, 1118, 1119, 1, 0, 0, 0, 1119, 147, 1, 0, 0, 0, 1120, 1118, 1, 0, 0,
        0, 1121, 1125, 5, 71, 0, 0, 1122, 1124, 5, 95, 0, 0, 1123, 1122, 1, 0, 0, 0, 1124, 1127,
        1, 0, 0, 0, 1125, 1123, 1, 0, 0, 0, 1125, 1126, 1, 0, 0, 0, 1126, 1128, 1, 0, 0, 0, 1127,
        1125, 1, 0, 0, 0, 1128, 1129, 3, 84, 42, 0, 1129, 1136, 1, 0, 0, 0, 1130, 1132, 5, 95,
        0, 0, 1131, 1133, 3, 84, 42, 0, 1132, 1131, 1, 0, 0, 0, 1132, 1133, 1, 0, 0, 0, 1133,
        1135, 1, 0, 0, 0, 1134, 1130, 1, 0, 0, 0, 1135, 1138, 1, 0, 0, 0, 1136, 1134, 1, 0, 0,
        0, 1136, 1137, 1, 0, 0, 0, 1137, 1139, 1, 0, 0, 0, 1138, 1136, 1, 0, 0, 0, 1139, 1140,
        5, 72, 0, 0, 1140, 149, 1, 0, 0, 0, 1141, 1144, 3, 84, 42, 0, 1142, 1143, 5, 83, 0, 0,
        1143, 1145, 3, 88, 44, 0, 1144, 1142, 1, 0, 0, 0, 1144, 1145, 1, 0, 0, 0, 1145, 1151,
        1, 0, 0, 0, 1146, 1147, 3, 148, 74, 0, 1147, 1148, 5, 83, 0, 0, 1148, 1149, 3, 88, 44,
        0, 1149, 1151, 1, 0, 0, 0, 1150, 1141, 1, 0, 0, 0, 1150, 1146, 1, 0, 0, 0, 1151, 1152,
        1, 0, 0, 0, 1152, 1153, 5, 78, 0, 0, 1153, 151, 1, 0, 0, 0, 1154, 1155, 3, 88, 44, 0,
        1155, 1156, 5, 78, 0, 0, 1156, 153, 1, 0, 0, 0, 1157, 1158, 5, 41, 0, 0, 1158, 1159,
        5, 71, 0, 0, 1159, 1161, 3, 156, 78, 0, 1160, 1162, 3, 96, 48, 0, 1161, 1160, 1, 0,
        0, 0, 1161, 1162, 1, 0, 0, 0, 1162, 1163, 1, 0, 0, 0, 1163, 1164, 5, 81, 0, 0, 1164,
        1166, 3, 78, 39, 0, 1165, 1167, 3, 96, 48, 0, 1166, 1165, 1, 0, 0, 0, 1166, 1167, 1,
        0, 0, 0, 1167, 1168, 1, 0, 0, 0, 1168, 1169, 5, 72, 0, 0, 1169, 155, 1, 0, 0, 0, 1170,
        1173, 3, 80, 40, 0, 1171, 1173, 3, 28, 14, 0, 1172, 1170, 1, 0, 0, 0, 1172, 1171, 1,
        0, 0, 0, 1173, 157, 1, 0, 0, 0, 1174, 1186, 3, 160, 80, 0, 1175, 1186, 3, 162, 81, 0,
        1176, 1186, 3, 164, 82, 0, 1177, 1186, 3, 178, 89, 0, 1178, 1186, 3, 166, 83, 0, 1179,
        1186, 3, 168, 84, 0, 1180, 1186, 3, 172, 86, 0, 1181, 1186, 5, 151, 0, 0, 1182, 1186,
        5, 143, 0, 0, 1183, 1186, 5, 145, 0, 0, 1184, 1186, 3, 174, 87, 0, 1185, 1174, 1, 0,
        0, 0, 1185, 1175, 1, 0, 0, 0, 1185, 1176, 1, 0, 0, 0, 1185, 1177, 1, 0, 0, 0, 1185, 1178,
        1, 0, 0, 0, 1185, 1179, 1, 0, 0, 0, 1185, 1180, 1, 0, 0, 0, 1185, 1181, 1, 0, 0, 0, 1185,
        1182, 1, 0, 0, 0, 1185, 1183, 1, 0, 0, 0, 1185, 1184, 1, 0, 0, 0, 1186, 159, 1, 0, 0,
        0, 1187, 1191, 5, 157, 0, 0, 1188, 1190, 3, 158, 79, 0, 1189, 1188, 1, 0, 0, 0, 1190,
        1193, 1, 0, 0, 0, 1191, 1189, 1, 0, 0, 0, 1191, 1192, 1, 0, 0, 0, 1192, 1194, 1, 0, 0,
        0, 1193, 1191, 1, 0, 0, 0, 1194, 1195, 5, 158, 0, 0, 1195, 161, 1, 0, 0, 0, 1196, 1197,
        5, 152, 0, 0, 1197, 1200, 5, 165, 0, 0, 1198, 1199, 5, 161, 0, 0, 1199, 1201, 3, 184,
        92, 0, 1200, 1198, 1, 0, 0, 0, 1200, 1201, 1, 0, 0, 0, 1201, 1216, 1, 0, 0, 0, 1202,
        1203, 5, 152, 0, 0, 1203, 1208, 5, 165, 0, 0, 1204, 1205, 5, 163, 0, 0, 1205, 1207,
        5, 165, 0, 0, 1206, 1204, 1, 0, 0, 0, 1207, 1210, 1, 0, 0, 0, 1208, 1206, 1, 0, 0, 0,
        1208, 1209, 1, 0, 0, 0, 1209, 1213, 1, 0, 0, 0, 1210, 1208, 1, 0, 0, 0, 1211, 1212,
        5, 161, 0, 0, 1212, 1214, 3, 178, 89, 0, 1213, 1211, 1, 0, 0, 0, 1213, 1214, 1, 0, 0,
        0, 1214, 1216, 1, 0, 0, 0, 1215, 1196, 1, 0, 0, 0, 1215, 1202, 1, 0, 0, 0, 1216, 163,
        1, 0, 0, 0, 1217, 1218, 3, 176, 88, 0, 1218, 1219, 5, 161, 0, 0, 1219, 1220, 3, 184,
        92, 0, 1220, 1232, 1, 0, 0, 0, 1221, 1224, 3, 176, 88, 0, 1222, 1223, 5, 163, 0, 0,
        1223, 1225, 3, 176, 88, 0, 1224, 1222, 1, 0, 0, 0, 1225, 1226, 1, 0, 0, 0, 1226, 1224,
        1, 0, 0, 0, 1226, 1227, 1, 0, 0, 0, 1227, 1228, 1, 0, 0, 0, 1228, 1229, 5, 161, 0, 0,
        1229, 1230, 3, 178, 89, 0, 1230, 1232, 1, 0, 0, 0, 1231, 1217, 1, 0, 0, 0, 1231, 1221,
        1, 0, 0, 0, 1232, 165, 1, 0, 0, 0, 1233, 1234, 5, 150, 0, 0, 1234, 1235, 3, 184, 92,
        0, 1235, 1236, 3, 160, 80, 0, 1236, 167, 1, 0, 0, 0, 1237, 1238, 5, 148, 0, 0, 1238,
        1239, 3, 160, 80, 0, 1239, 1240, 3, 184, 92, 0, 1240, 1241, 3, 160, 80, 0, 1241, 1242,
        3, 160, 80, 0, 1242, 169, 1, 0, 0, 0, 1243, 1244, 5, 144, 0, 0, 1244, 1245, 3, 182,
        91, 0, 1245, 1246, 3, 160, 80, 0, 1246, 171, 1, 0, 0, 0, 1247, 1248, 5, 153, 0, 0, 1248,
        1260, 3, 184, 92, 0, 1249, 1251, 3, 170, 85, 0, 1250, 1249, 1, 0, 0, 0, 1251, 1252,
        1, 0, 0, 0, 1252, 1250, 1, 0, 0, 0, 1252, 1253, 1, 0, 0, 0, 1253, 1256, 1, 0, 0, 0, 1254,
        1255, 5, 146, 0, 0, 1255, 1257, 3, 160, 80, 0, 1256, 1254, 1, 0, 0, 0, 1256, 1257,
        1, 0, 0, 0, 1257, 1261, 1, 0, 0, 0, 1258, 1259, 5, 146, 0, 0, 1259, 1261, 3, 160, 80,
        0, 1260, 1250, 1, 0, 0, 0, 1260, 1258, 1, 0, 0, 0, 1261, 173, 1, 0, 0, 0, 1262, 1263,
        5, 149, 0, 0, 1263, 1264, 5, 165, 0, 0, 1264, 1273, 5, 159, 0, 0, 1265, 1270, 5, 165,
        0, 0, 1266, 1267, 5, 163, 0, 0, 1267, 1269, 5, 165, 0, 0, 1268, 1266, 1, 0, 0, 0, 1269,
        1272, 1, 0, 0, 0, 1270, 1268, 1, 0, 0, 0, 1270, 1271, 1, 0, 0, 0, 1271, 1274, 1, 0, 0,
        0, 1272, 1270, 1, 0, 0, 0, 1273, 1265, 1, 0, 0, 0, 1273, 1274, 1, 0, 0, 0, 1274, 1275,
        1, 0, 0, 0, 1275, 1285, 5, 160, 0, 0, 1276, 1277, 5, 164, 0, 0, 1277, 1282, 5, 165,
        0, 0, 1278, 1279, 5, 163, 0, 0, 1279, 1281, 5, 165, 0, 0, 1280, 1278, 1, 0, 0, 0, 1281,
        1284, 1, 0, 0, 0, 1282, 1280, 1, 0, 0, 0, 1282, 1283, 1, 0, 0, 0, 1283, 1286, 1, 0, 0,
        0, 1284, 1282, 1, 0, 0, 0, 1285, 1276, 1, 0, 0, 0, 1285, 1286, 1, 0, 0, 0, 1286, 1287,
        1, 0, 0, 0, 1287, 1288, 3, 160, 80, 0, 1288, 175, 1, 0, 0, 0, 1289, 1294, 5, 165, 0,
        0, 1290, 1291, 5, 162, 0, 0, 1291, 1293, 7, 16, 0, 0, 1292, 1290, 1, 0, 0, 0, 1293,
        1296, 1, 0, 0, 0, 1294, 1292, 1, 0, 0, 0, 1294, 1295, 1, 0, 0, 0, 1295, 177, 1, 0, 0,
        0, 1296, 1294, 1, 0, 0, 0, 1297, 1298, 7, 16, 0, 0, 1298, 1307, 5, 159, 0, 0, 1299,
        1304, 3, 184, 92, 0, 1300, 1301, 5, 163, 0, 0, 1301, 1303, 3, 184, 92, 0, 1302, 1300,
        1, 0, 0, 0, 1303, 1306, 1, 0, 0, 0, 1304, 1302, 1, 0, 0, 0, 1304, 1305, 1, 0, 0, 0, 1305,
        1308, 1, 0, 0, 0, 1306, 1304, 1, 0, 0, 0, 1307, 1299, 1, 0, 0, 0, 1307, 1308, 1, 0, 0,
        0, 1308, 1309, 1, 0, 0, 0, 1309, 1310, 5, 160, 0, 0, 1310, 179, 1, 0, 0, 0, 1311, 1312,
        7, 17, 0, 0, 1312, 181, 1, 0, 0, 0, 1313, 1319, 5, 167, 0, 0, 1314, 1319, 5, 168, 0,
        0, 1315, 1319, 5, 166, 0, 0, 1316, 1319, 3, 180, 90, 0, 1317, 1319, 5, 169, 0, 0, 1318,
        1313, 1, 0, 0, 0, 1318, 1314, 1, 0, 0, 0, 1318, 1315, 1, 0, 0, 0, 1318, 1316, 1, 0, 0,
        0, 1318, 1317, 1, 0, 0, 0, 1319, 183, 1, 0, 0, 0, 1320, 1324, 3, 176, 88, 0, 1321, 1324,
        3, 178, 89, 0, 1322, 1324, 3, 182, 91, 0, 1323, 1320, 1, 0, 0, 0, 1323, 1321, 1, 0,
        0, 0, 1323, 1322, 1, 0, 0, 0, 1324, 185, 1, 0, 0, 0, 147, 198, 200, 209, 217, 229, 236,
        246, 252, 257, 263, 271, 277, 288, 299, 304, 318, 330, 333, 341, 344, 347, 356,
        361, 370, 375, 378, 383, 396, 398, 412, 417, 423, 427, 446, 448, 456, 460, 466,
        470, 474, 481, 485, 491, 494, 503, 505, 510, 517, 535, 537, 547, 551, 570, 572,
        577, 585, 601, 632, 634, 640, 653, 656, 666, 669, 673, 679, 689, 692, 705, 711,
        715, 720, 725, 728, 737, 742, 747, 762, 767, 778, 780, 788, 792, 816, 818, 866,
        872, 876, 883, 892, 895, 902, 904, 911, 915, 919, 930, 942, 952, 957, 962, 969,
        971, 992, 996, 1005, 1011, 1015, 1018, 1050, 1056, 1060, 1066, 1072, 1088, 1091,
        1097, 1108, 1118, 1125, 1132, 1136, 1144, 1150, 1161, 1166, 1172, 1185, 1191,
        1200, 1208, 1213, 1215, 1226, 1231, 1252, 1256, 1260, 1270, 1273, 1282, 1285,
        1294, 1304, 1307, 1318, 1323
    ]


class SolidityParser(Parser):
    grammarFileName = "SolidityParser.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [DFA(ds, i) for i, ds in enumerate(atn.decisionToState)]

    sharedContextCache = PredictionContextCache()

    literalNames = ["<INVALID>", "<INVALID>", "'abstract'", "'address'",
                    "'anonymous'", "'as'", "'assembly'", "'bool'", "<INVALID>",
                    "'bytes'", "'calldata'", "'catch'", "'constant'", "'constructor'",
                    "<INVALID>", "'contract'", "'delete'", "'do'", "'else'",
                    "'emit'", "'enum'", "'error'", "'event'", "'external'",
                    "'fallback'", "<INVALID>", "<INVALID>", "<INVALID>",
                    "<INVALID>", "'from'", "<INVALID>", "'global'", "<INVALID>",
                    "<INVALID>", "'immutable'", "'import'", "'indexed'",
                    "'interface'", "'internal'", "'is'", "'library'", "'mapping'",
                    "'memory'", "'modifier'", "'new'", "<INVALID>", "'override'",
                    "'payable'", "'pragma'", "'private'", "'public'", "'pure'",
                    "'receive'", "'return'", "'returns'", "'revert'", "<INVALID>",
                    "'storage'", "'string'", "'struct'", "<INVALID>", "'try'",
                    "'type'", "<INVALID>", "'unchecked'", "'unicode'",
                    "<INVALID>", "'using'", "'view'", "'virtual'", "'while'",
                    "<INVALID>", "<INVALID>", "'['", "']'", "<INVALID>",
                    "<INVALID>", "':'", "<INVALID>", "<INVALID>", "'?'",
                    "'=>'", "<INVALID>", "'='", "'|='", "'^='", "'&='",
                    "'<<='", "'>>='", "'>>>='", "'+='", "'-='", "'*='",
                    "'/='", "'%='", "<INVALID>", "'||'", "'&&'", "'|'",
                    "'^'", "'&'", "'<<'", "'>>'", "'>>>'", "'+'", "'-'",
                    "'*'", "'/'", "'%'", "'**'", "'=='", "'!='", "'<'",
                    "'>'", "'<='", "'>='", "'!'", "'~'", "'++'", "'--'",
                    "'\"'", "'''", "<INVALID>", "<INVALID>", "<INVALID>",
                    "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                    "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                    "<INVALID>", "'\"evmasm\"'", "<INVALID>", "<INVALID>",
                    "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                    "<INVALID>", "<INVALID>", "<INVALID>", "'case'", "<INVALID>",
                    "'default'", "<INVALID>", "<INVALID>", "<INVALID>",
                    "<INVALID>", "'leave'", "'let'", "'switch'", "<INVALID>",
                    "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
                    "<INVALID>", "<INVALID>", "':='"]

    symbolicNames = ["<INVALID>", "ReservedKeywords", "Abstract", "Address",
                     "Anonymous", "As", "Assembly", "Bool", "Break", "Bytes",
                     "Calldata", "Catch", "Constant", "Constructor", "Continue",
                     "Contract", "Delete", "Do", "Else", "Emit", "Enum",
                     "Error", "Event", "External", "Fallback", "FALSE",
                     "Fixed", "FixedBytes", "For", "From", "Function",
                     "Global", "Hex", "If", "Immutable", "Import", "Indexed",
                     "Interface", "Internal", "Is", "Library", "Mapping",
                     "Memory", "Modifier", "New", "SubDenomination", "Override",
                     "Payable", "Pragma", "Private", "Public", "Pure",
                     "Receive", "Return", "Returns", "Revert", "SignedIntegerType",
                     "Storage", "String", "Struct", "TRUE", "Try", "Type",
                     "Ufixed", "Unchecked", "Unicode", "UnsignedIntegerType",
                     "Using", "View", "Virtual", "While", "LParen", "RParen",
                     "LBrack", "RBrack", "LBrace", "RBrace", "Colon", "Semicolon",
                     "Period", "Conditional", "DoubleArrow", "RightArrow",
                     "Assign", "AssignBitOr", "AssignBitXor", "AssignBitAnd",
                     "AssignShl", "AssignSar", "AssignShr", "AssignAdd",
                     "AssignSub", "AssignMul", "AssignDiv", "AssignMod",
                     "Comma", "Or", "And", "BitOr", "BitXor", "BitAnd",
                     "Shl", "Sar", "Shr", "Add", "Sub", "Mul", "Div", "Mod",
                     "Exp", "Equal", "NotEqual", "LessThan", "GreaterThan",
                     "LessThanOrEqual", "GreaterThanOrEqual", "Not", "BitNot",
                     "Inc", "Dec", "DoubleQuote", "SingleQuote", "NonEmptyStringLiteral",
                     "EmptyStringLiteral", "UnicodeStringLiteral", "HexString",
                     "HexNumber", "OctalNumber", "DecimalNumber", "DecimalNumberFollowedByIdentifier",
                     "Identifier", "WS", "COMMENT", "LINE_COMMENT", "AssemblyDialect",
                     "AssemblyLBrace", "AssemblyFlagString", "AssemblyBlockLParen",
                     "AssemblyBlockRParen", "AssemblyBlockComma", "AssemblyBlockWS",
                     "AssemblyBlockCOMMENT", "AssemblyBlockLINE_COMMENT",
                     "YulBreak", "YulCase", "YulContinue", "YulDefault",
                     "YulFalse", "YulFor", "YulFunction", "YulIf", "YulLeave",
                     "YulLet", "YulSwitch", "YulTrue", "YulHex", "YulEVMBuiltin",
                     "YulLBrace", "YulRBrace", "YulLParen", "YulRParen",
                     "YulAssign", "YulPeriod", "YulComma", "YulArrow",
                     "YulIdentifier", "YulHexNumber", "YulDecimalNumber",
                     "YulStringLiteral", "YulHexStringLiteral", "YulWS",
                     "YulCOMMENT", "YulLINE_COMMENT", "PragmaToken", "PragmaSemicolon",
                     "PragmaWS", "PragmaCOMMENT", "PragmaLINE_COMMENT"]

    RULE_sourceUnit = 0
    RULE_pragmaDirective = 1
    RULE_importDirective = 2
    RULE_importAliases = 3
    RULE_path = 4
    RULE_symbolAliases = 5
    RULE_contractDefinition = 6
    RULE_interfaceDefinition = 7
    RULE_libraryDefinition = 8
    RULE_inheritanceSpecifierList = 9
    RULE_inheritanceSpecifier = 10
    RULE_contractBodyElement = 11
    RULE_namedArgument = 12
    RULE_callArgumentList = 13
    RULE_identifierPath = 14
    RULE_modifierInvocation = 15
    RULE_visibility = 16
    RULE_parameterList = 17
    RULE_parameterDeclaration = 18
    RULE_constructorDefinition = 19
    RULE_stateMutability = 20
    RULE_overrideSpecifier = 21
    RULE_contractFunctionDefinition = 22
    RULE_freeFunctionDefinition = 23
    RULE_modifierDefinition = 24
    RULE_fallbackFunctionDefinition = 25
    RULE_receiveFunctionDefinition = 26
    RULE_structDefinition = 27
    RULE_structMember = 28
    RULE_enumDefinition = 29
    RULE_userDefinedValueTypeDefinition = 30
    RULE_stateVariableDeclaration = 31
    RULE_constantVariableDeclaration = 32
    RULE_eventParameter = 33
    RULE_eventDefinition = 34
    RULE_errorParameter = 35
    RULE_errorDefinition = 36
    RULE_userDefinableOperator = 37
    RULE_usingDirective = 38
    RULE_typeName = 39
    RULE_elementaryTypeName = 40
    RULE_functionTypeName = 41
    RULE_variableDeclaration = 42
    RULE_dataLocation = 43
    RULE_expression = 44
    RULE_assignOp = 45
    RULE_tupleExpression = 46
    RULE_inlineArrayExpression = 47
    RULE_identifier = 48
    RULE_literal = 49
    RULE_literalWithSubDenomination = 50
    RULE_boolLiteral = 51
    RULE_stringLiteral = 52
    RULE_hexStringLiteral = 53
    RULE_unicodeStringLiteral = 54
    RULE_numberLiteral = 55
    RULE_block = 56
    RULE_uncheckedBlock = 57
    RULE_statement = 58
    RULE_simpleStatement = 59
    RULE_ifStatement = 60
    RULE_forStatement = 61
    RULE_whileStatement = 62
    RULE_doWhileStatement = 63
    RULE_continueStatement = 64
    RULE_breakStatement = 65
    RULE_tryStatement = 66
    RULE_catchClause = 67
    RULE_returnStatement = 68
    RULE_emitStatement = 69
    RULE_revertStatement = 70
    RULE_assemblyStatement = 71
    RULE_assemblyFlags = 72
    RULE_variableDeclarationList = 73
    RULE_variableDeclarationTuple = 74
    RULE_variableDeclarationStatement = 75
    RULE_expressionStatement = 76
    RULE_mappingType = 77
    RULE_mappingKeyType = 78
    RULE_yulStatement = 79
    RULE_yulBlock = 80
    RULE_yulVariableDeclaration = 81
    RULE_yulAssignment = 82
    RULE_yulIfStatement = 83
    RULE_yulForStatement = 84
    RULE_yulSwitchCase = 85
    RULE_yulSwitchStatement = 86
    RULE_yulFunctionDefinition = 87
    RULE_yulPath = 88
    RULE_yulFunctionCall = 89
    RULE_yulbool = 90
    RULE_yulLiteral = 91
    RULE_yulExpression = 92

    ruleNames = ["sourceUnit", "pragmaDirective", "importDirective", "importAliases",
                 "path", "symbolAliases", "contractDefinition", "interfaceDefinition",
                 "libraryDefinition", "inheritanceSpecifierList", "inheritanceSpecifier",
                 "contractBodyElement", "namedArgument", "callArgumentList",
                 "identifierPath", "modifierInvocation", "visibility",
                 "parameterList", "parameterDeclaration", "constructorDefinition",
                 "stateMutability", "overrideSpecifier", "contractFunctionDefinition",
                 "freeFunctionDefinition", "modifierDefinition", "fallbackFunctionDefinition",
                 "receiveFunctionDefinition", "structDefinition", "structMember",
                 "enumDefinition", "userDefinedValueTypeDefinition", "stateVariableDeclaration",
                 "constantVariableDeclaration", "eventParameter", "eventDefinition",
                 "errorParameter", "errorDefinition", "userDefinableOperator",
                 "usingDirective", "typeName", "elementaryTypeName", "functionTypeName",
                 "variableDeclaration", "dataLocation", "expression",
                 "assignOp", "tupleExpression", "inlineArrayExpression",
                 "identifier", "literal", "literalWithSubDenomination",
                 "boolLiteral", "stringLiteral", "hexStringLiteral", "unicodeStringLiteral",
                 "numberLiteral", "block", "uncheckedBlock", "statement",
                 "simpleStatement", "ifStatement", "forStatement", "whileStatement",
                 "doWhileStatement", "continueStatement", "breakStatement",
                 "tryStatement", "catchClause", "returnStatement", "emitStatement",
                 "revertStatement", "assemblyStatement", "assemblyFlags",
                 "variableDeclarationList", "variableDeclarationTuple",
                 "variableDeclarationStatement", "expressionStatement",
                 "mappingType", "mappingKeyType", "yulStatement", "yulBlock",
                 "yulVariableDeclaration", "yulAssignment", "yulIfStatement",
                 "yulForStatement", "yulSwitchCase", "yulSwitchStatement",
                 "yulFunctionDefinition", "yulPath", "yulFunctionCall",
                 "yulbool", "yulLiteral", "yulExpression"]

    EOF = Token.EOF
    ReservedKeywords = 1
    Abstract = 2
    Address = 3
    Anonymous = 4
    As = 5
    Assembly = 6
    Bool = 7
    Break = 8
    Bytes = 9
    Calldata = 10
    Catch = 11
    Constant = 12
    Constructor = 13
    Continue = 14
    Contract = 15
    Delete = 16
    Do = 17
    Else = 18
    Emit = 19
    Enum = 20
    Error = 21
    Event = 22
    External = 23
    Fallback = 24
    FALSE = 25
    Fixed = 26
    FixedBytes = 27
    For = 28
    From = 29
    Function = 30
    Global = 31
    Hex = 32
    If = 33
    Immutable = 34
    Import = 35
    Indexed = 36
    Interface = 37
    Internal = 38
    Is = 39
    Library = 40
    Mapping = 41
    Memory = 42
    Modifier = 43
    New = 44
    SubDenomination = 45
    Override = 46
    Payable = 47
    Pragma = 48
    Private = 49
    Public = 50
    Pure = 51
    Receive = 52
    Return = 53
    Returns = 54
    Revert = 55
    SignedIntegerType = 56
    Storage = 57
    String = 58
    Struct = 59
    TRUE = 60
    Try = 61
    Type = 62
    Ufixed = 63
    Unchecked = 64
    Unicode = 65
    UnsignedIntegerType = 66
    Using = 67
    View = 68
    Virtual = 69
    While = 70
    LParen = 71
    RParen = 72
    LBrack = 73
    RBrack = 74
    LBrace = 75
    RBrace = 76
    Colon = 77
    Semicolon = 78
    Period = 79
    Conditional = 80
    DoubleArrow = 81
    RightArrow = 82
    Assign = 83
    AssignBitOr = 84
    AssignBitXor = 85
    AssignBitAnd = 86
    AssignShl = 87
    AssignSar = 88
    AssignShr = 89
    AssignAdd = 90
    AssignSub = 91
    AssignMul = 92
    AssignDiv = 93
    AssignMod = 94
    Comma = 95
    Or = 96
    And = 97
    BitOr = 98
    BitXor = 99
    BitAnd = 100
    Shl = 101
    Sar = 102
    Shr = 103
    Add = 104
    Sub = 105
    Mul = 106
    Div = 107
    Mod = 108
    Exp = 109
    Equal = 110
    NotEqual = 111
    LessThan = 112
    GreaterThan = 113
    LessThanOrEqual = 114
    GreaterThanOrEqual = 115
    Not = 116
    BitNot = 117
    Inc = 118
    Dec = 119
    DoubleQuote = 120
    SingleQuote = 121
    NonEmptyStringLiteral = 122
    EmptyStringLiteral = 123
    UnicodeStringLiteral = 124
    HexString = 125
    HexNumber = 126
    OctalNumber = 127
    DecimalNumber = 128
    DecimalNumberFollowedByIdentifier = 129
    Identifier = 130
    WS = 131
    COMMENT = 132
    LINE_COMMENT = 133
    AssemblyDialect = 134
    AssemblyLBrace = 135
    AssemblyFlagString = 136
    AssemblyBlockLParen = 137
    AssemblyBlockRParen = 138
    AssemblyBlockComma = 139
    AssemblyBlockWS = 140
    AssemblyBlockCOMMENT = 141
    AssemblyBlockLINE_COMMENT = 142
    YulBreak = 143
    YulCase = 144
    YulContinue = 145
    YulDefault = 146
    YulFalse = 147
    YulFor = 148
    YulFunction = 149
    YulIf = 150
    YulLeave = 151
    YulLet = 152
    YulSwitch = 153
    YulTrue = 154
    YulHex = 155
    YulEVMBuiltin = 156
    YulLBrace = 157
    YulRBrace = 158
    YulLParen = 159
    YulRParen = 160
    YulAssign = 161
    YulPeriod = 162
    YulComma = 163
    YulArrow = 164
    YulIdentifier = 165
    YulHexNumber = 166
    YulDecimalNumber = 167
    YulStringLiteral = 168
    YulHexStringLiteral = 169
    YulWS = 170
    YulCOMMENT = 171
    YulLINE_COMMENT = 172
    PragmaToken = 173
    PragmaSemicolon = 174
    PragmaWS = 175
    PragmaCOMMENT = 176
    PragmaLINE_COMMENT = 177

    def __init__(self, input: TokenStream, output: TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.0")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None

    class SourceUnitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(SolidityParser.EOF, 0)

        def pragmaDirective(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.PragmaDirectiveContext)
            else:
                return self.getTypedRuleContext(SolidityParser.PragmaDirectiveContext, i)

        def importDirective(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ImportDirectiveContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ImportDirectiveContext, i)

        def usingDirective(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.UsingDirectiveContext)
            else:
                return self.getTypedRuleContext(SolidityParser.UsingDirectiveContext, i)

        def contractDefinition(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ContractDefinitionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ContractDefinitionContext, i)

        def interfaceDefinition(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.InterfaceDefinitionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.InterfaceDefinitionContext, i)

        def libraryDefinition(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.LibraryDefinitionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.LibraryDefinitionContext, i)

        def freeFunctionDefinition(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.FreeFunctionDefinitionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.FreeFunctionDefinitionContext, i)

        def constantVariableDeclaration(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ConstantVariableDeclarationContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ConstantVariableDeclarationContext, i)

        def structDefinition(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.StructDefinitionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.StructDefinitionContext, i)

        def enumDefinition(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.EnumDefinitionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.EnumDefinitionContext, i)

        def userDefinedValueTypeDefinition(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.UserDefinedValueTypeDefinitionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.UserDefinedValueTypeDefinitionContext, i)

        def errorDefinition(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ErrorDefinitionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ErrorDefinitionContext, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_sourceUnit

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSourceUnit"):
                listener.enterSourceUnit(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSourceUnit"):
                listener.exitSourceUnit(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSourceUnit"):
                return visitor.visitSourceUnit(self)
            else:
                return visitor.visitChildren(self)

    def sourceUnit(self):

        localctx = SolidityParser.SourceUnitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_sourceUnit)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 200
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 1, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 198
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input, 0, self._ctx)
                    if la_ == 1:
                        self.state = 186
                        self.pragmaDirective()
                        pass

                    elif la_ == 2:
                        self.state = 187
                        self.importDirective()
                        pass

                    elif la_ == 3:
                        self.state = 188
                        self.usingDirective()
                        pass

                    elif la_ == 4:
                        self.state = 189
                        self.contractDefinition()
                        pass

                    elif la_ == 5:
                        self.state = 190
                        self.interfaceDefinition()
                        pass

                    elif la_ == 6:
                        self.state = 191
                        self.libraryDefinition()
                        pass

                    elif la_ == 7:
                        self.state = 192
                        self.freeFunctionDefinition()
                        pass

                    elif la_ == 8:
                        self.state = 193
                        self.constantVariableDeclaration()
                        pass

                    elif la_ == 9:
                        self.state = 194
                        self.structDefinition()
                        pass

                    elif la_ == 10:
                        self.state = 195
                        self.enumDefinition()
                        pass

                    elif la_ == 11:
                        self.state = 196
                        self.userDefinedValueTypeDefinition()
                        pass

                    elif la_ == 12:
                        self.state = 197
                        self.errorDefinition()
                        pass

                self.state = 202
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 1, self._ctx)

            self.state = 203
            self.match(SolidityParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PragmaDirectiveContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Pragma(self):
            return self.getToken(SolidityParser.Pragma, 0)

        def PragmaSemicolon(self):
            return self.getToken(SolidityParser.PragmaSemicolon, 0)

        def PragmaToken(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.PragmaToken)
            else:
                return self.getToken(SolidityParser.PragmaToken, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_pragmaDirective

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterPragmaDirective"):
                listener.enterPragmaDirective(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitPragmaDirective"):
                listener.exitPragmaDirective(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitPragmaDirective"):
                return visitor.visitPragmaDirective(self)
            else:
                return visitor.visitChildren(self)

    def pragmaDirective(self):

        localctx = SolidityParser.PragmaDirectiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_pragmaDirective)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 205
            self.match(SolidityParser.Pragma)
            self.state = 207
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 206
                self.match(SolidityParser.PragmaToken)
                self.state = 209
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la == 173):
                    break

            self.state = 211
            self.match(SolidityParser.PragmaSemicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ImportDirectiveContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.unitAlias = None  # IdentifierContext

        def Import(self):
            return self.getToken(SolidityParser.Import, 0)

        def Semicolon(self):
            return self.getToken(SolidityParser.Semicolon, 0)

        def path(self):
            return self.getTypedRuleContext(SolidityParser.PathContext, 0)

        def symbolAliases(self):
            return self.getTypedRuleContext(SolidityParser.SymbolAliasesContext, 0)

        def From(self):
            return self.getToken(SolidityParser.From, 0)

        def Mul(self):
            return self.getToken(SolidityParser.Mul, 0)

        def As(self):
            return self.getToken(SolidityParser.As, 0)

        def identifier(self):
            return self.getTypedRuleContext(SolidityParser.IdentifierContext, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_importDirective

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterImportDirective"):
                listener.enterImportDirective(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitImportDirective"):
                listener.exitImportDirective(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitImportDirective"):
                return visitor.visitImportDirective(self)
            else:
                return visitor.visitChildren(self)

    def importDirective(self):

        localctx = SolidityParser.ImportDirectiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_importDirective)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 213
            self.match(SolidityParser.Import)
            self.state = 229
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [122]:
                self.state = 214
                self.path()
                self.state = 217
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == 5:
                    self.state = 215
                    self.match(SolidityParser.As)
                    self.state = 216
                    localctx.unitAlias = self.identifier()

                pass
            elif token in [75]:
                self.state = 219
                self.symbolAliases()
                self.state = 220
                self.match(SolidityParser.From)
                self.state = 221
                self.path()
                pass
            elif token in [106]:
                self.state = 223
                self.match(SolidityParser.Mul)
                self.state = 224
                self.match(SolidityParser.As)
                self.state = 225
                localctx.unitAlias = self.identifier()
                self.state = 226
                self.match(SolidityParser.From)
                self.state = 227
                self.path()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 231
            self.match(SolidityParser.Semicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ImportAliasesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.symbol = None  # IdentifierContext
            self.alias = None  # IdentifierContext

        def identifier(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(SolidityParser.IdentifierContext, i)

        def As(self):
            return self.getToken(SolidityParser.As, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_importAliases

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterImportAliases"):
                listener.enterImportAliases(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitImportAliases"):
                listener.exitImportAliases(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitImportAliases"):
                return visitor.visitImportAliases(self)
            else:
                return visitor.visitChildren(self)

    def importAliases(self):

        localctx = SolidityParser.ImportAliasesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_importAliases)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 233
            localctx.symbol = self.identifier()
            self.state = 236
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 5:
                self.state = 234
                self.match(SolidityParser.As)
                self.state = 235
                localctx.alias = self.identifier()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PathContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NonEmptyStringLiteral(self):
            return self.getToken(SolidityParser.NonEmptyStringLiteral, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_path

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterPath"):
                listener.enterPath(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitPath"):
                listener.exitPath(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitPath"):
                return visitor.visitPath(self)
            else:
                return visitor.visitChildren(self)

    def path(self):

        localctx = SolidityParser.PathContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_path)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 238
            self.match(SolidityParser.NonEmptyStringLiteral)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SymbolAliasesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._importAliases = None  # ImportAliasesContext
            self.aliases = list()  # of ImportAliasesContexts

        def LBrace(self):
            return self.getToken(SolidityParser.LBrace, 0)

        def RBrace(self):
            return self.getToken(SolidityParser.RBrace, 0)

        def importAliases(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ImportAliasesContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ImportAliasesContext, i)

        def Comma(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.Comma)
            else:
                return self.getToken(SolidityParser.Comma, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_symbolAliases

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSymbolAliases"):
                listener.enterSymbolAliases(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSymbolAliases"):
                listener.exitSymbolAliases(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSymbolAliases"):
                return visitor.visitSymbolAliases(self)
            else:
                return visitor.visitChildren(self)

    def symbolAliases(self):

        localctx = SolidityParser.SymbolAliasesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_symbolAliases)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 240
            self.match(SolidityParser.LBrace)
            self.state = 241
            localctx._importAliases = self.importAliases()
            localctx.aliases.append(localctx._importAliases)
            self.state = 246
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 95:
                self.state = 242
                self.match(SolidityParser.Comma)
                self.state = 243
                localctx._importAliases = self.importAliases()
                localctx.aliases.append(localctx._importAliases)
                self.state = 248
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 249
            self.match(SolidityParser.RBrace)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ContractDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None  # IdentifierContext

        def Contract(self):
            return self.getToken(SolidityParser.Contract, 0)

        def LBrace(self):
            return self.getToken(SolidityParser.LBrace, 0)

        def RBrace(self):
            return self.getToken(SolidityParser.RBrace, 0)

        def identifier(self):
            return self.getTypedRuleContext(SolidityParser.IdentifierContext, 0)

        def Abstract(self):
            return self.getToken(SolidityParser.Abstract, 0)

        def inheritanceSpecifierList(self):
            return self.getTypedRuleContext(SolidityParser.InheritanceSpecifierListContext, 0)

        def contractBodyElement(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ContractBodyElementContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ContractBodyElementContext, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_contractDefinition

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterContractDefinition"):
                listener.enterContractDefinition(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitContractDefinition"):
                listener.exitContractDefinition(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitContractDefinition"):
                return visitor.visitContractDefinition(self)
            else:
                return visitor.visitChildren(self)

    def contractDefinition(self):

        localctx = SolidityParser.ContractDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_contractDefinition)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 252
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 2:
                self.state = 251
                self.match(SolidityParser.Abstract)

            self.state = 254
            self.match(SolidityParser.Contract)
            self.state = 255
            localctx.name = self.identifier()
            self.state = 257
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 39:
                self.state = 256
                self.inheritanceSpecifierList()

            self.state = 259
            self.match(SolidityParser.LBrace)
            self.state = 263
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 9, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 260
                    self.contractBodyElement()
                self.state = 265
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 9, self._ctx)

            self.state = 266
            self.match(SolidityParser.RBrace)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class InterfaceDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None  # IdentifierContext

        def Interface(self):
            return self.getToken(SolidityParser.Interface, 0)

        def LBrace(self):
            return self.getToken(SolidityParser.LBrace, 0)

        def RBrace(self):
            return self.getToken(SolidityParser.RBrace, 0)

        def identifier(self):
            return self.getTypedRuleContext(SolidityParser.IdentifierContext, 0)

        def inheritanceSpecifierList(self):
            return self.getTypedRuleContext(SolidityParser.InheritanceSpecifierListContext, 0)

        def contractBodyElement(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ContractBodyElementContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ContractBodyElementContext, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_interfaceDefinition

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterInterfaceDefinition"):
                listener.enterInterfaceDefinition(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitInterfaceDefinition"):
                listener.exitInterfaceDefinition(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitInterfaceDefinition"):
                return visitor.visitInterfaceDefinition(self)
            else:
                return visitor.visitChildren(self)

    def interfaceDefinition(self):

        localctx = SolidityParser.InterfaceDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_interfaceDefinition)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 268
            self.match(SolidityParser.Interface)
            self.state = 269
            localctx.name = self.identifier()
            self.state = 271
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 39:
                self.state = 270
                self.inheritanceSpecifierList()

            self.state = 273
            self.match(SolidityParser.LBrace)
            self.state = 277
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 11, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 274
                    self.contractBodyElement()
                self.state = 279
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 11, self._ctx)

            self.state = 280
            self.match(SolidityParser.RBrace)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LibraryDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None  # IdentifierContext

        def Library(self):
            return self.getToken(SolidityParser.Library, 0)

        def LBrace(self):
            return self.getToken(SolidityParser.LBrace, 0)

        def RBrace(self):
            return self.getToken(SolidityParser.RBrace, 0)

        def identifier(self):
            return self.getTypedRuleContext(SolidityParser.IdentifierContext, 0)

        def contractBodyElement(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ContractBodyElementContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ContractBodyElementContext, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_libraryDefinition

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLibraryDefinition"):
                listener.enterLibraryDefinition(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLibraryDefinition"):
                listener.exitLibraryDefinition(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitLibraryDefinition"):
                return visitor.visitLibraryDefinition(self)
            else:
                return visitor.visitChildren(self)

    def libraryDefinition(self):

        localctx = SolidityParser.LibraryDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_libraryDefinition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 282
            self.match(SolidityParser.Library)
            self.state = 283
            localctx.name = self.identifier()
            self.state = 284
            self.match(SolidityParser.LBrace)
            self.state = 288
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 12, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 285
                    self.contractBodyElement()
                self.state = 290
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 12, self._ctx)

            self.state = 291
            self.match(SolidityParser.RBrace)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class InheritanceSpecifierListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._inheritanceSpecifier = None  # InheritanceSpecifierContext
            self.inheritanceSpecifiers = list()  # of InheritanceSpecifierContexts

        def Is(self):
            return self.getToken(SolidityParser.Is, 0)

        def inheritanceSpecifier(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.InheritanceSpecifierContext)
            else:
                return self.getTypedRuleContext(SolidityParser.InheritanceSpecifierContext, i)

        def Comma(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.Comma)
            else:
                return self.getToken(SolidityParser.Comma, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_inheritanceSpecifierList

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterInheritanceSpecifierList"):
                listener.enterInheritanceSpecifierList(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitInheritanceSpecifierList"):
                listener.exitInheritanceSpecifierList(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitInheritanceSpecifierList"):
                return visitor.visitInheritanceSpecifierList(self)
            else:
                return visitor.visitChildren(self)

    def inheritanceSpecifierList(self):

        localctx = SolidityParser.InheritanceSpecifierListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_inheritanceSpecifierList)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 293
            self.match(SolidityParser.Is)
            self.state = 294
            localctx._inheritanceSpecifier = self.inheritanceSpecifier()
            localctx.inheritanceSpecifiers.append(localctx._inheritanceSpecifier)
            self.state = 299
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 13, self._ctx)
            while _alt != 1 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1 + 1:
                    self.state = 295
                    self.match(SolidityParser.Comma)
                    self.state = 296
                    localctx._inheritanceSpecifier = self.inheritanceSpecifier()
                    localctx.inheritanceSpecifiers.append(localctx._inheritanceSpecifier)
                self.state = 301
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 13, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class InheritanceSpecifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None  # IdentifierPathContext
            self.arguments = None  # CallArgumentListContext

        def identifierPath(self):
            return self.getTypedRuleContext(SolidityParser.IdentifierPathContext, 0)

        def callArgumentList(self):
            return self.getTypedRuleContext(SolidityParser.CallArgumentListContext, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_inheritanceSpecifier

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterInheritanceSpecifier"):
                listener.enterInheritanceSpecifier(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitInheritanceSpecifier"):
                listener.exitInheritanceSpecifier(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitInheritanceSpecifier"):
                return visitor.visitInheritanceSpecifier(self)
            else:
                return visitor.visitChildren(self)

    def inheritanceSpecifier(self):

        localctx = SolidityParser.InheritanceSpecifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_inheritanceSpecifier)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 302
            localctx.name = self.identifierPath()
            self.state = 304
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 71:
                self.state = 303
                localctx.arguments = self.callArgumentList()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ContractBodyElementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def constructorDefinition(self):
            return self.getTypedRuleContext(SolidityParser.ConstructorDefinitionContext, 0)

        def contractFunctionDefinition(self):
            return self.getTypedRuleContext(SolidityParser.ContractFunctionDefinitionContext, 0)

        def modifierDefinition(self):
            return self.getTypedRuleContext(SolidityParser.ModifierDefinitionContext, 0)

        def fallbackFunctionDefinition(self):
            return self.getTypedRuleContext(SolidityParser.FallbackFunctionDefinitionContext, 0)

        def receiveFunctionDefinition(self):
            return self.getTypedRuleContext(SolidityParser.ReceiveFunctionDefinitionContext, 0)

        def structDefinition(self):
            return self.getTypedRuleContext(SolidityParser.StructDefinitionContext, 0)

        def enumDefinition(self):
            return self.getTypedRuleContext(SolidityParser.EnumDefinitionContext, 0)

        def userDefinedValueTypeDefinition(self):
            return self.getTypedRuleContext(SolidityParser.UserDefinedValueTypeDefinitionContext, 0)

        def stateVariableDeclaration(self):
            return self.getTypedRuleContext(SolidityParser.StateVariableDeclarationContext, 0)

        def eventDefinition(self):
            return self.getTypedRuleContext(SolidityParser.EventDefinitionContext, 0)

        def errorDefinition(self):
            return self.getTypedRuleContext(SolidityParser.ErrorDefinitionContext, 0)

        def usingDirective(self):
            return self.getTypedRuleContext(SolidityParser.UsingDirectiveContext, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_contractBodyElement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterContractBodyElement"):
                listener.enterContractBodyElement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitContractBodyElement"):
                listener.exitContractBodyElement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitContractBodyElement"):
                return visitor.visitContractBodyElement(self)
            else:
                return visitor.visitChildren(self)

    def contractBodyElement(self):

        localctx = SolidityParser.ContractBodyElementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_contractBodyElement)
        try:
            self.state = 318
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 15, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 306
                self.constructorDefinition()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 307
                self.contractFunctionDefinition()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 308
                self.modifierDefinition()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 309
                self.fallbackFunctionDefinition()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 310
                self.receiveFunctionDefinition()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 311
                self.structDefinition()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 312
                self.enumDefinition()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 313
                self.userDefinedValueTypeDefinition()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 314
                self.stateVariableDeclaration()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 315
                self.eventDefinition()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 316
                self.errorDefinition()
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 317
                self.usingDirective()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class NamedArgumentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None  # IdentifierContext
            self.value = None  # ExpressionContext

        def Colon(self):
            return self.getToken(SolidityParser.Colon, 0)

        def identifier(self):
            return self.getTypedRuleContext(SolidityParser.IdentifierContext, 0)

        def expression(self):
            return self.getTypedRuleContext(SolidityParser.ExpressionContext, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_namedArgument

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterNamedArgument"):
                listener.enterNamedArgument(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitNamedArgument"):
                listener.exitNamedArgument(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitNamedArgument"):
                return visitor.visitNamedArgument(self)
            else:
                return visitor.visitChildren(self)

    def namedArgument(self):

        localctx = SolidityParser.NamedArgumentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_namedArgument)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 320
            localctx.name = self.identifier()
            self.state = 321
            self.match(SolidityParser.Colon)
            self.state = 322
            localctx.value = self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CallArgumentListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LParen(self):
            return self.getToken(SolidityParser.LParen, 0)

        def RParen(self):
            return self.getToken(SolidityParser.RParen, 0)

        def LBrace(self):
            return self.getToken(SolidityParser.LBrace, 0)

        def RBrace(self):
            return self.getToken(SolidityParser.RBrace, 0)

        def expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ExpressionContext, i)

        def namedArgument(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.NamedArgumentContext)
            else:
                return self.getTypedRuleContext(SolidityParser.NamedArgumentContext, i)

        def Comma(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.Comma)
            else:
                return self.getToken(SolidityParser.Comma, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_callArgumentList

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCallArgumentList"):
                listener.enterCallArgumentList(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCallArgumentList"):
                listener.exitCallArgumentList(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitCallArgumentList"):
                return visitor.visitCallArgumentList(self)
            else:
                return visitor.visitChildren(self)

    def callArgumentList(self):

        localctx = SolidityParser.CallArgumentListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_callArgumentList)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 324
            self.match(SolidityParser.LParen)
            self.state = 347
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 20, self._ctx)
            if la_ == 1:
                self.state = 333
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 17, self._ctx)
                if la_ == 1:
                    self.state = 325
                    self.expression(0)
                    self.state = 330
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la == 95:
                        self.state = 326
                        self.match(SolidityParser.Comma)
                        self.state = 327
                        self.expression(0)
                        self.state = 332
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                pass

            elif la_ == 2:
                self.state = 335
                self.match(SolidityParser.LBrace)
                self.state = 344
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 36028799705415680) != 0) or _la == 130:
                    self.state = 336
                    self.namedArgument()
                    self.state = 341
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la == 95:
                        self.state = 337
                        self.match(SolidityParser.Comma)
                        self.state = 338
                        self.namedArgument()
                        self.state = 343
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                self.state = 346
                self.match(SolidityParser.RBrace)
                pass

            self.state = 349
            self.match(SolidityParser.RParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class IdentifierPathContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(SolidityParser.IdentifierContext, i)

        def Period(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.Period)
            else:
                return self.getToken(SolidityParser.Period, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_identifierPath

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterIdentifierPath"):
                listener.enterIdentifierPath(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitIdentifierPath"):
                listener.exitIdentifierPath(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitIdentifierPath"):
                return visitor.visitIdentifierPath(self)
            else:
                return visitor.visitChildren(self)

    def identifierPath(self):

        localctx = SolidityParser.IdentifierPathContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_identifierPath)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 351
            self.identifier()
            self.state = 356
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 21, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 352
                    self.match(SolidityParser.Period)
                    self.state = 353
                    self.identifier()
                self.state = 358
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 21, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ModifierInvocationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifierPath(self):
            return self.getTypedRuleContext(SolidityParser.IdentifierPathContext, 0)

        def callArgumentList(self):
            return self.getTypedRuleContext(SolidityParser.CallArgumentListContext, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_modifierInvocation

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterModifierInvocation"):
                listener.enterModifierInvocation(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitModifierInvocation"):
                listener.exitModifierInvocation(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitModifierInvocation"):
                return visitor.visitModifierInvocation(self)
            else:
                return visitor.visitChildren(self)

    def modifierInvocation(self):

        localctx = SolidityParser.ModifierInvocationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_modifierInvocation)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 359
            self.identifierPath()
            self.state = 361
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 22, self._ctx)
            if la_ == 1:
                self.state = 360
                self.callArgumentList()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class VisibilityContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Internal(self):
            return self.getToken(SolidityParser.Internal, 0)

        def External(self):
            return self.getToken(SolidityParser.External, 0)

        def Private(self):
            return self.getToken(SolidityParser.Private, 0)

        def Public(self):
            return self.getToken(SolidityParser.Public, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_visibility

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterVisibility"):
                listener.enterVisibility(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitVisibility"):
                listener.exitVisibility(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitVisibility"):
                return visitor.visitVisibility(self)
            else:
                return visitor.visitChildren(self)

    def visibility(self):

        localctx = SolidityParser.VisibilityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_visibility)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 363
            _la = self._input.LA(1)
            if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 1689124746559488) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ParameterListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._parameterDeclaration = None  # ParameterDeclarationContext
            self.parameters = list()  # of ParameterDeclarationContexts

        def parameterDeclaration(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ParameterDeclarationContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ParameterDeclarationContext, i)

        def Comma(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.Comma)
            else:
                return self.getToken(SolidityParser.Comma, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_parameterList

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterParameterList"):
                listener.enterParameterList(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitParameterList"):
                listener.exitParameterList(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitParameterList"):
                return visitor.visitParameterList(self)
            else:
                return visitor.visitChildren(self)

    def parameterList(self):

        localctx = SolidityParser.ParameterListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_parameterList)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 365
            localctx._parameterDeclaration = self.parameterDeclaration()
            localctx.parameters.append(localctx._parameterDeclaration)
            self.state = 370
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 95:
                self.state = 366
                self.match(SolidityParser.Comma)
                self.state = 367
                localctx._parameterDeclaration = self.parameterDeclaration()
                localctx.parameters.append(localctx._parameterDeclaration)
                self.state = 372
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ParameterDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.type_ = None  # TypeNameContext
            self.location = None  # DataLocationContext
            self.name = None  # IdentifierContext

        def typeName(self):
            return self.getTypedRuleContext(SolidityParser.TypeNameContext, 0)

        def dataLocation(self):
            return self.getTypedRuleContext(SolidityParser.DataLocationContext, 0)

        def identifier(self):
            return self.getTypedRuleContext(SolidityParser.IdentifierContext, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_parameterDeclaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterParameterDeclaration"):
                listener.enterParameterDeclaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitParameterDeclaration"):
                listener.exitParameterDeclaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitParameterDeclaration"):
                return visitor.visitParameterDeclaration(self)
            else:
                return visitor.visitChildren(self)

    def parameterDeclaration(self):

        localctx = SolidityParser.ParameterDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_parameterDeclaration)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 373
            localctx.type_ = self.typeName(0)
            self.state = 375
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 144119586122368000) != 0):
                self.state = 374
                localctx.location = self.dataLocation()

            self.state = 378
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 36028799705415680) != 0) or _la == 130:
                self.state = 377
                localctx.name = self.identifier()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ConstructorDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.payableSet = SolidityParser.FALSE
            self.visibilitySet = SolidityParser.FALSE
            self.arguments = None  # ParameterListContext
            self.body = None  # BlockContext

        def Constructor(self):
            return self.getToken(SolidityParser.Constructor, 0)

        def LParen(self):
            return self.getToken(SolidityParser.LParen, 0)

        def RParen(self):
            return self.getToken(SolidityParser.RParen, 0)

        def block(self):
            return self.getTypedRuleContext(SolidityParser.BlockContext, 0)

        def modifierInvocation(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ModifierInvocationContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ModifierInvocationContext, i)

        def Payable(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.Payable)
            else:
                return self.getToken(SolidityParser.Payable, i)

        def Internal(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.Internal)
            else:
                return self.getToken(SolidityParser.Internal, i)

        def Public(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.Public)
            else:
                return self.getToken(SolidityParser.Public, i)

        def parameterList(self):
            return self.getTypedRuleContext(SolidityParser.ParameterListContext, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_constructorDefinition

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterConstructorDefinition"):
                listener.enterConstructorDefinition(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitConstructorDefinition"):
                listener.exitConstructorDefinition(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitConstructorDefinition"):
                return visitor.visitConstructorDefinition(self)
            else:
                return visitor.visitChildren(self)

    def constructorDefinition(self):

        localctx = SolidityParser.ConstructorDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_constructorDefinition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 380
            self.match(SolidityParser.Constructor)
            self.state = 381
            self.match(SolidityParser.LParen)
            self.state = 383
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 26, self._ctx)
            if la_ == 1:
                self.state = 382
                localctx.arguments = self.parameterList()

            self.state = 385
            self.match(SolidityParser.RParen)
            self.state = 398
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 28, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 396
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input, 27, self._ctx)
                    if la_ == 1:
                        self.state = 386
                        self.modifierInvocation()
                        pass

                    elif la_ == 2:
                        self.state = 387
                        if not localctx.payableSet:
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "$payableSet")
                        self.state = 388
                        self.match(SolidityParser.Payable)
                        localctx.payableSet = True
                        pass

                    elif la_ == 3:
                        self.state = 390
                        if not localctx.visibilitySet:
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "$visibilitySet")
                        self.state = 391
                        self.match(SolidityParser.Internal)
                        localctx.visibilitySet = True
                        pass

                    elif la_ == 4:
                        self.state = 393
                        if not localctx.visibilitySet:
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "$visibilitySet")
                        self.state = 394
                        self.match(SolidityParser.Public)
                        localctx.visibilitySet = True
                        pass

                self.state = 400
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 28, self._ctx)

            self.state = 401
            localctx.body = self.block()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StateMutabilityContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Pure(self):
            return self.getToken(SolidityParser.Pure, 0)

        def View(self):
            return self.getToken(SolidityParser.View, 0)

        def Payable(self):
            return self.getToken(SolidityParser.Payable, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_stateMutability

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterStateMutability"):
                listener.enterStateMutability(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitStateMutability"):
                listener.exitStateMutability(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitStateMutability"):
                return visitor.visitStateMutability(self)
            else:
                return visitor.visitChildren(self)

    def stateMutability(self):

        localctx = SolidityParser.StateMutabilityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_stateMutability)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 403
            _la = self._input.LA(1)
            if not (((((_la - 47)) & ~0x3f) == 0 and ((1 << (_la - 47)) & 2097169) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class OverrideSpecifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._identifierPath = None  # IdentifierPathContext
            self.overrides = list()  # of IdentifierPathContexts

        def Override(self):
            return self.getToken(SolidityParser.Override, 0)

        def LParen(self):
            return self.getToken(SolidityParser.LParen, 0)

        def RParen(self):
            return self.getToken(SolidityParser.RParen, 0)

        def identifierPath(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.IdentifierPathContext)
            else:
                return self.getTypedRuleContext(SolidityParser.IdentifierPathContext, i)

        def Comma(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.Comma)
            else:
                return self.getToken(SolidityParser.Comma, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_overrideSpecifier

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterOverrideSpecifier"):
                listener.enterOverrideSpecifier(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitOverrideSpecifier"):
                listener.exitOverrideSpecifier(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitOverrideSpecifier"):
                return visitor.visitOverrideSpecifier(self)
            else:
                return visitor.visitChildren(self)

    def overrideSpecifier(self):

        localctx = SolidityParser.OverrideSpecifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_overrideSpecifier)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 405
            self.match(SolidityParser.Override)
            self.state = 417
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 30, self._ctx)
            if la_ == 1:
                self.state = 406
                self.match(SolidityParser.LParen)
                self.state = 407
                localctx._identifierPath = self.identifierPath()
                localctx.overrides.append(localctx._identifierPath)
                self.state = 412
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == 95:
                    self.state = 408
                    self.match(SolidityParser.Comma)
                    self.state = 409
                    localctx._identifierPath = self.identifierPath()
                    localctx.overrides.append(localctx._identifierPath)
                    self.state = 414
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 415
                self.match(SolidityParser.RParen)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ContractFunctionDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.visibilitySet = SolidityParser.FALSE
            self.mutabilitySet = SolidityParser.FALSE
            self.virtualSet = SolidityParser.FALSE
            self.overrideSpecifierSet = SolidityParser.FALSE
            self.arguments = None  # ParameterListContext
            self.returnParameters = None  # ParameterListContext
            self.body = None  # BlockContext

        def Function(self):
            return self.getToken(SolidityParser.Function, 0)

        def LParen(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.LParen)
            else:
                return self.getToken(SolidityParser.LParen, i)

        def RParen(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.RParen)
            else:
                return self.getToken(SolidityParser.RParen, i)

        def identifier(self):
            return self.getTypedRuleContext(SolidityParser.IdentifierContext, 0)

        def Fallback(self):
            return self.getToken(SolidityParser.Fallback, 0)

        def Receive(self):
            return self.getToken(SolidityParser.Receive, 0)

        def Semicolon(self):
            return self.getToken(SolidityParser.Semicolon, 0)

        def visibility(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.VisibilityContext)
            else:
                return self.getTypedRuleContext(SolidityParser.VisibilityContext, i)

        def stateMutability(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.StateMutabilityContext)
            else:
                return self.getTypedRuleContext(SolidityParser.StateMutabilityContext, i)

        def modifierInvocation(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ModifierInvocationContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ModifierInvocationContext, i)

        def Virtual(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.Virtual)
            else:
                return self.getToken(SolidityParser.Virtual, i)

        def overrideSpecifier(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.OverrideSpecifierContext)
            else:
                return self.getTypedRuleContext(SolidityParser.OverrideSpecifierContext, i)

        def Returns(self):
            return self.getToken(SolidityParser.Returns, 0)

        def block(self):
            return self.getTypedRuleContext(SolidityParser.BlockContext, 0)

        def parameterList(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ParameterListContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ParameterListContext, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_contractFunctionDefinition

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterContractFunctionDefinition"):
                listener.enterContractFunctionDefinition(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitContractFunctionDefinition"):
                listener.exitContractFunctionDefinition(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitContractFunctionDefinition"):
                return visitor.visitContractFunctionDefinition(self)
            else:
                return visitor.visitChildren(self)

    def contractFunctionDefinition(self):

        localctx = SolidityParser.ContractFunctionDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_contractFunctionDefinition)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 419
            self.match(SolidityParser.Function)
            self.state = 423
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [21, 29, 31, 55, 130]:
                self.state = 420
                self.identifier()
                pass
            elif token in [24]:
                self.state = 421
                self.match(SolidityParser.Fallback)
                pass
            elif token in [52]:
                self.state = 422
                self.match(SolidityParser.Receive)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 425
            self.match(SolidityParser.LParen)
            self.state = 427
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 32, self._ctx)
            if la_ == 1:
                self.state = 426
                localctx.arguments = self.parameterList()

            self.state = 429
            self.match(SolidityParser.RParen)
            self.state = 448
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 34, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 446
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input, 33, self._ctx)
                    if la_ == 1:
                        self.state = 430
                        if not localctx.visibilitySet:
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "$visibilitySet")
                        self.state = 431
                        self.visibility()
                        localctx.visibilitySet = True
                        pass

                    elif la_ == 2:
                        self.state = 434
                        if not localctx.mutabilitySet:
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "$mutabilitySet")
                        self.state = 435
                        self.stateMutability()
                        localctx.mutabilitySet = True
                        pass

                    elif la_ == 3:
                        self.state = 438
                        self.modifierInvocation()
                        pass

                    elif la_ == 4:
                        self.state = 439
                        if not localctx.virtualSet:
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "$virtualSet")
                        self.state = 440
                        self.match(SolidityParser.Virtual)
                        localctx.virtualSet = True
                        pass

                    elif la_ == 5:
                        self.state = 442
                        if not localctx.overrideSpecifierSet:
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "$overrideSpecifierSet")
                        self.state = 443
                        self.overrideSpecifier()
                        localctx.overrideSpecifierSet = True
                        pass

                self.state = 450
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 34, self._ctx)

            self.state = 456
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 54:
                self.state = 451
                self.match(SolidityParser.Returns)
                self.state = 452
                self.match(SolidityParser.LParen)
                self.state = 453
                localctx.returnParameters = self.parameterList()
                self.state = 454
                self.match(SolidityParser.RParen)

            self.state = 460
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [78]:
                self.state = 458
                self.match(SolidityParser.Semicolon)
                pass
            elif token in [75]:
                self.state = 459
                localctx.body = self.block()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FreeFunctionDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.arguments = None  # ParameterListContext
            self.returnParameters = None  # ParameterListContext
            self.body = None  # BlockContext

        def Function(self):
            return self.getToken(SolidityParser.Function, 0)

        def LParen(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.LParen)
            else:
                return self.getToken(SolidityParser.LParen, i)

        def RParen(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.RParen)
            else:
                return self.getToken(SolidityParser.RParen, i)

        def identifier(self):
            return self.getTypedRuleContext(SolidityParser.IdentifierContext, 0)

        def Fallback(self):
            return self.getToken(SolidityParser.Fallback, 0)

        def Receive(self):
            return self.getToken(SolidityParser.Receive, 0)

        def Semicolon(self):
            return self.getToken(SolidityParser.Semicolon, 0)

        def stateMutability(self):
            return self.getTypedRuleContext(SolidityParser.StateMutabilityContext, 0)

        def Returns(self):
            return self.getToken(SolidityParser.Returns, 0)

        def block(self):
            return self.getTypedRuleContext(SolidityParser.BlockContext, 0)

        def parameterList(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ParameterListContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ParameterListContext, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_freeFunctionDefinition

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFreeFunctionDefinition"):
                listener.enterFreeFunctionDefinition(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFreeFunctionDefinition"):
                listener.exitFreeFunctionDefinition(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFreeFunctionDefinition"):
                return visitor.visitFreeFunctionDefinition(self)
            else:
                return visitor.visitChildren(self)

    def freeFunctionDefinition(self):

        localctx = SolidityParser.FreeFunctionDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_freeFunctionDefinition)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 462
            self.match(SolidityParser.Function)
            self.state = 466
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [21, 29, 31, 55, 130]:
                self.state = 463
                self.identifier()
                pass
            elif token in [24]:
                self.state = 464
                self.match(SolidityParser.Fallback)
                pass
            elif token in [52]:
                self.state = 465
                self.match(SolidityParser.Receive)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 468
            self.match(SolidityParser.LParen)
            self.state = 470
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 38, self._ctx)
            if la_ == 1:
                self.state = 469
                localctx.arguments = self.parameterList()

            self.state = 472
            self.match(SolidityParser.RParen)
            self.state = 474
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 47)) & ~0x3f) == 0 and ((1 << (_la - 47)) & 2097169) != 0):
                self.state = 473
                self.stateMutability()

            self.state = 481
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 54:
                self.state = 476
                self.match(SolidityParser.Returns)
                self.state = 477
                self.match(SolidityParser.LParen)
                self.state = 478
                localctx.returnParameters = self.parameterList()
                self.state = 479
                self.match(SolidityParser.RParen)

            self.state = 485
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [78]:
                self.state = 483
                self.match(SolidityParser.Semicolon)
                pass
            elif token in [75]:
                self.state = 484
                localctx.body = self.block()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ModifierDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.virtualSet = SolidityParser.FALSE
            self.overrideSpecifierSet = SolidityParser.FALSE
            self.name = None  # IdentifierContext
            self.arguments = None  # ParameterListContext
            self.body = None  # BlockContext

        def Modifier(self):
            return self.getToken(SolidityParser.Modifier, 0)

        def identifier(self):
            return self.getTypedRuleContext(SolidityParser.IdentifierContext, 0)

        def Semicolon(self):
            return self.getToken(SolidityParser.Semicolon, 0)

        def LParen(self):
            return self.getToken(SolidityParser.LParen, 0)

        def RParen(self):
            return self.getToken(SolidityParser.RParen, 0)

        def Virtual(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.Virtual)
            else:
                return self.getToken(SolidityParser.Virtual, i)

        def overrideSpecifier(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.OverrideSpecifierContext)
            else:
                return self.getTypedRuleContext(SolidityParser.OverrideSpecifierContext, i)

        def block(self):
            return self.getTypedRuleContext(SolidityParser.BlockContext, 0)

        def parameterList(self):
            return self.getTypedRuleContext(SolidityParser.ParameterListContext, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_modifierDefinition

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterModifierDefinition"):
                listener.enterModifierDefinition(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitModifierDefinition"):
                listener.exitModifierDefinition(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitModifierDefinition"):
                return visitor.visitModifierDefinition(self)
            else:
                return visitor.visitChildren(self)

    def modifierDefinition(self):

        localctx = SolidityParser.ModifierDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_modifierDefinition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 487
            self.match(SolidityParser.Modifier)
            self.state = 488
            localctx.name = self.identifier()
            self.state = 494
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 43, self._ctx)
            if la_ == 1:
                self.state = 489
                self.match(SolidityParser.LParen)
                self.state = 491
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 42, self._ctx)
                if la_ == 1:
                    self.state = 490
                    localctx.arguments = self.parameterList()

                self.state = 493
                self.match(SolidityParser.RParen)

            self.state = 505
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 45, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 503
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input, 44, self._ctx)
                    if la_ == 1:
                        self.state = 496
                        if not localctx.virtualSet:
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "$virtualSet")
                        self.state = 497
                        self.match(SolidityParser.Virtual)
                        localctx.virtualSet = True
                        pass

                    elif la_ == 2:
                        self.state = 499
                        if not localctx.overrideSpecifierSet:
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "$overrideSpecifierSet")
                        self.state = 500
                        self.overrideSpecifier()
                        localctx.overrideSpecifierSet = True
                        pass

                self.state = 507
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 45, self._ctx)

            self.state = 510
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [78]:
                self.state = 508
                self.match(SolidityParser.Semicolon)
                pass
            elif token in [75]:
                self.state = 509
                localctx.body = self.block()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FallbackFunctionDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.visibilitySet = SolidityParser.FALSE
            self.mutabilitySet = SolidityParser.FALSE
            self.virtualSet = SolidityParser.FALSE
            self.overrideSpecifierSet = SolidityParser.FALSE
            self.hasParameters = SolidityParser.FALSE
            self.kind = None  # Token
            self.returnParameters = None  # ParameterListContext
            self.body = None  # BlockContext

        def LParen(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.LParen)
            else:
                return self.getToken(SolidityParser.LParen, i)

        def RParen(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.RParen)
            else:
                return self.getToken(SolidityParser.RParen, i)

        def Fallback(self):
            return self.getToken(SolidityParser.Fallback, 0)

        def Returns(self):
            return self.getToken(SolidityParser.Returns, 0)

        def Semicolon(self):
            return self.getToken(SolidityParser.Semicolon, 0)

        def parameterList(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ParameterListContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ParameterListContext, i)

        def External(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.External)
            else:
                return self.getToken(SolidityParser.External, i)

        def stateMutability(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.StateMutabilityContext)
            else:
                return self.getTypedRuleContext(SolidityParser.StateMutabilityContext, i)

        def modifierInvocation(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ModifierInvocationContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ModifierInvocationContext, i)

        def Virtual(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.Virtual)
            else:
                return self.getToken(SolidityParser.Virtual, i)

        def overrideSpecifier(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.OverrideSpecifierContext)
            else:
                return self.getTypedRuleContext(SolidityParser.OverrideSpecifierContext, i)

        def block(self):
            return self.getTypedRuleContext(SolidityParser.BlockContext, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_fallbackFunctionDefinition

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFallbackFunctionDefinition"):
                listener.enterFallbackFunctionDefinition(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFallbackFunctionDefinition"):
                listener.exitFallbackFunctionDefinition(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFallbackFunctionDefinition"):
                return visitor.visitFallbackFunctionDefinition(self)
            else:
                return visitor.visitChildren(self)

    def fallbackFunctionDefinition(self):

        localctx = SolidityParser.FallbackFunctionDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_fallbackFunctionDefinition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 512
            localctx.kind = self.match(SolidityParser.Fallback)
            self.state = 513
            self.match(SolidityParser.LParen)
            self.state = 517
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 47, self._ctx)
            if la_ == 1:
                self.state = 514
                self.parameterList()
                localctx.hasParameters = True

            self.state = 519
            self.match(SolidityParser.RParen)
            self.state = 537
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 49, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 535
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input, 48, self._ctx)
                    if la_ == 1:
                        self.state = 520
                        if not localctx.visibilitySet:
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "$visibilitySet")
                        self.state = 521
                        self.match(SolidityParser.External)
                        localctx.visibilitySet = True
                        pass

                    elif la_ == 2:
                        self.state = 523
                        if not localctx.mutabilitySet:
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "$mutabilitySet")
                        self.state = 524
                        self.stateMutability()
                        localctx.mutabilitySet = True
                        pass

                    elif la_ == 3:
                        self.state = 527
                        self.modifierInvocation()
                        pass

                    elif la_ == 4:
                        self.state = 528
                        if not localctx.virtualSet:
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "$virtualSet")
                        self.state = 529
                        self.match(SolidityParser.Virtual)
                        localctx.virtualSet = True
                        pass

                    elif la_ == 5:
                        self.state = 531
                        if not localctx.overrideSpecifierSet:
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "$overrideSpecifierSet")
                        self.state = 532
                        self.overrideSpecifier()
                        localctx.overrideSpecifierSet = True
                        pass

                self.state = 539
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 49, self._ctx)

            self.state = 547
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 50, self._ctx)
            if la_ == 1:
                self.state = 540
                if not localctx.hasParameters:
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "$hasParameters")
                self.state = 541
                self.match(SolidityParser.Returns)
                self.state = 542
                self.match(SolidityParser.LParen)
                self.state = 543
                localctx.returnParameters = self.parameterList()
                self.state = 544
                self.match(SolidityParser.RParen)
                pass

            elif la_ == 2:
                self.state = 546
                if not localctx.hasParameters:
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "$hasParameters")
                pass

            self.state = 551
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [78]:
                self.state = 549
                self.match(SolidityParser.Semicolon)
                pass
            elif token in [75]:
                self.state = 550
                localctx.body = self.block()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ReceiveFunctionDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.visibilitySet = SolidityParser.FALSE
            self.mutabilitySet = SolidityParser.FALSE
            self.virtualSet = SolidityParser.FALSE
            self.overrideSpecifierSet = SolidityParser.FALSE
            self.kind = None  # Token
            self.body = None  # BlockContext

        def LParen(self):
            return self.getToken(SolidityParser.LParen, 0)

        def RParen(self):
            return self.getToken(SolidityParser.RParen, 0)

        def Receive(self):
            return self.getToken(SolidityParser.Receive, 0)

        def Semicolon(self):
            return self.getToken(SolidityParser.Semicolon, 0)

        def External(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.External)
            else:
                return self.getToken(SolidityParser.External, i)

        def Payable(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.Payable)
            else:
                return self.getToken(SolidityParser.Payable, i)

        def modifierInvocation(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ModifierInvocationContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ModifierInvocationContext, i)

        def Virtual(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.Virtual)
            else:
                return self.getToken(SolidityParser.Virtual, i)

        def overrideSpecifier(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.OverrideSpecifierContext)
            else:
                return self.getTypedRuleContext(SolidityParser.OverrideSpecifierContext, i)

        def block(self):
            return self.getTypedRuleContext(SolidityParser.BlockContext, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_receiveFunctionDefinition

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterReceiveFunctionDefinition"):
                listener.enterReceiveFunctionDefinition(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitReceiveFunctionDefinition"):
                listener.exitReceiveFunctionDefinition(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitReceiveFunctionDefinition"):
                return visitor.visitReceiveFunctionDefinition(self)
            else:
                return visitor.visitChildren(self)

    def receiveFunctionDefinition(self):

        localctx = SolidityParser.ReceiveFunctionDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_receiveFunctionDefinition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 553
            localctx.kind = self.match(SolidityParser.Receive)
            self.state = 554
            self.match(SolidityParser.LParen)
            self.state = 555
            self.match(SolidityParser.RParen)
            self.state = 572
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 53, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 570
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input, 52, self._ctx)
                    if la_ == 1:
                        self.state = 556
                        if not localctx.visibilitySet:
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "$visibilitySet")
                        self.state = 557
                        self.match(SolidityParser.External)
                        localctx.visibilitySet = True
                        pass

                    elif la_ == 2:
                        self.state = 559
                        if not localctx.mutabilitySet:
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "$mutabilitySet")
                        self.state = 560
                        self.match(SolidityParser.Payable)
                        localctx.mutabilitySet = True
                        pass

                    elif la_ == 3:
                        self.state = 562
                        self.modifierInvocation()
                        pass

                    elif la_ == 4:
                        self.state = 563
                        if not localctx.virtualSet:
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "$virtualSet")
                        self.state = 564
                        self.match(SolidityParser.Virtual)
                        localctx.virtualSet = True
                        pass

                    elif la_ == 5:
                        self.state = 566
                        if not localctx.overrideSpecifierSet:
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "$overrideSpecifierSet")
                        self.state = 567
                        self.overrideSpecifier()
                        localctx.overrideSpecifierSet = True
                        pass

                self.state = 574
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 53, self._ctx)

            self.state = 577
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [78]:
                self.state = 575
                self.match(SolidityParser.Semicolon)
                pass
            elif token in [75]:
                self.state = 576
                localctx.body = self.block()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StructDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None  # IdentifierContext
            self.members = None  # StructMemberContext

        def Struct(self):
            return self.getToken(SolidityParser.Struct, 0)

        def LBrace(self):
            return self.getToken(SolidityParser.LBrace, 0)

        def RBrace(self):
            return self.getToken(SolidityParser.RBrace, 0)

        def identifier(self):
            return self.getTypedRuleContext(SolidityParser.IdentifierContext, 0)

        def structMember(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.StructMemberContext)
            else:
                return self.getTypedRuleContext(SolidityParser.StructMemberContext, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_structDefinition

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterStructDefinition"):
                listener.enterStructDefinition(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitStructDefinition"):
                listener.exitStructDefinition(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitStructDefinition"):
                return visitor.visitStructDefinition(self)
            else:
                return visitor.visitChildren(self)

    def structDefinition(self):

        localctx = SolidityParser.StructDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_structDefinition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 579
            self.match(SolidityParser.Struct)
            self.state = 580
            localctx.name = self.identifier()
            self.state = 581
            self.match(SolidityParser.LBrace)
            self.state = 583
            self._errHandler.sync(self)
            _alt = 1
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 582
                    localctx.members = self.structMember()

                else:
                    raise NoViableAltException(self)
                self.state = 585
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 55, self._ctx)

            self.state = 587
            self.match(SolidityParser.RBrace)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StructMemberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.type_ = None  # TypeNameContext
            self.name = None  # IdentifierContext

        def Semicolon(self):
            return self.getToken(SolidityParser.Semicolon, 0)

        def typeName(self):
            return self.getTypedRuleContext(SolidityParser.TypeNameContext, 0)

        def identifier(self):
            return self.getTypedRuleContext(SolidityParser.IdentifierContext, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_structMember

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterStructMember"):
                listener.enterStructMember(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitStructMember"):
                listener.exitStructMember(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitStructMember"):
                return visitor.visitStructMember(self)
            else:
                return visitor.visitChildren(self)

    def structMember(self):

        localctx = SolidityParser.StructMemberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_structMember)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 589
            localctx.type_ = self.typeName(0)
            self.state = 590
            localctx.name = self.identifier()
            self.state = 591
            self.match(SolidityParser.Semicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class EnumDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None  # IdentifierContext
            self._identifier = None  # IdentifierContext
            self.enumValues = list()  # of IdentifierContexts

        def Enum(self):
            return self.getToken(SolidityParser.Enum, 0)

        def LBrace(self):
            return self.getToken(SolidityParser.LBrace, 0)

        def RBrace(self):
            return self.getToken(SolidityParser.RBrace, 0)

        def identifier(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(SolidityParser.IdentifierContext, i)

        def Comma(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.Comma)
            else:
                return self.getToken(SolidityParser.Comma, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_enumDefinition

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterEnumDefinition"):
                listener.enterEnumDefinition(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitEnumDefinition"):
                listener.exitEnumDefinition(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitEnumDefinition"):
                return visitor.visitEnumDefinition(self)
            else:
                return visitor.visitChildren(self)

    def enumDefinition(self):

        localctx = SolidityParser.EnumDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_enumDefinition)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 593
            self.match(SolidityParser.Enum)
            self.state = 594
            localctx.name = self.identifier()
            self.state = 595
            self.match(SolidityParser.LBrace)
            self.state = 596
            localctx._identifier = self.identifier()
            localctx.enumValues.append(localctx._identifier)
            self.state = 601
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 95:
                self.state = 597
                self.match(SolidityParser.Comma)
                self.state = 598
                localctx._identifier = self.identifier()
                localctx.enumValues.append(localctx._identifier)
                self.state = 603
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 604
            self.match(SolidityParser.RBrace)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class UserDefinedValueTypeDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None  # IdentifierContext

        def Type(self):
            return self.getToken(SolidityParser.Type, 0)

        def Is(self):
            return self.getToken(SolidityParser.Is, 0)

        def elementaryTypeName(self):
            return self.getTypedRuleContext(SolidityParser.ElementaryTypeNameContext, 0)

        def Semicolon(self):
            return self.getToken(SolidityParser.Semicolon, 0)

        def identifier(self):
            return self.getTypedRuleContext(SolidityParser.IdentifierContext, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_userDefinedValueTypeDefinition

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterUserDefinedValueTypeDefinition"):
                listener.enterUserDefinedValueTypeDefinition(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitUserDefinedValueTypeDefinition"):
                listener.exitUserDefinedValueTypeDefinition(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitUserDefinedValueTypeDefinition"):
                return visitor.visitUserDefinedValueTypeDefinition(self)
            else:
                return visitor.visitChildren(self)

    def userDefinedValueTypeDefinition(self):

        localctx = SolidityParser.UserDefinedValueTypeDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_userDefinedValueTypeDefinition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 606
            self.match(SolidityParser.Type)
            self.state = 607
            localctx.name = self.identifier()
            self.state = 608
            self.match(SolidityParser.Is)
            self.state = 609
            self.elementaryTypeName(SolidityParser.TRUE)
            self.state = 610
            self.match(SolidityParser.Semicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StateVariableDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.constantnessSet = SolidityParser.FALSE
            self.visibilitySet = SolidityParser.FALSE
            self.overrideSpecifierSet = SolidityParser.FALSE
            self.type_ = None  # TypeNameContext
            self.name = None  # IdentifierContext
            self.initialValue = None  # ExpressionContext

        def Semicolon(self):
            return self.getToken(SolidityParser.Semicolon, 0)

        def typeName(self):
            return self.getTypedRuleContext(SolidityParser.TypeNameContext, 0)

        def identifier(self):
            return self.getTypedRuleContext(SolidityParser.IdentifierContext, 0)

        def Public(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.Public)
            else:
                return self.getToken(SolidityParser.Public, i)

        def Private(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.Private)
            else:
                return self.getToken(SolidityParser.Private, i)

        def Internal(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.Internal)
            else:
                return self.getToken(SolidityParser.Internal, i)

        def Constant(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.Constant)
            else:
                return self.getToken(SolidityParser.Constant, i)

        def overrideSpecifier(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.OverrideSpecifierContext)
            else:
                return self.getTypedRuleContext(SolidityParser.OverrideSpecifierContext, i)

        def Immutable(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.Immutable)
            else:
                return self.getToken(SolidityParser.Immutable, i)

        def Assign(self):
            return self.getToken(SolidityParser.Assign, 0)

        def expression(self):
            return self.getTypedRuleContext(SolidityParser.ExpressionContext, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_stateVariableDeclaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterStateVariableDeclaration"):
                listener.enterStateVariableDeclaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitStateVariableDeclaration"):
                listener.exitStateVariableDeclaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitStateVariableDeclaration"):
                return visitor.visitStateVariableDeclaration(self)
            else:
                return visitor.visitChildren(self)

    def stateVariableDeclaration(self):

        localctx = SolidityParser.StateVariableDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_stateVariableDeclaration)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 612
            localctx.type_ = self.typeName(0)
            self.state = 634
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 58, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 632
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input, 57, self._ctx)
                    if la_ == 1:
                        self.state = 613
                        if not localctx.visibilitySet:
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "$visibilitySet")
                        self.state = 614
                        self.match(SolidityParser.Public)
                        localctx.visibilitySet = True
                        pass

                    elif la_ == 2:
                        self.state = 616
                        if not localctx.visibilitySet:
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "$visibilitySet")
                        self.state = 617
                        self.match(SolidityParser.Private)
                        localctx.visibilitySet = True
                        pass

                    elif la_ == 3:
                        self.state = 619
                        if not localctx.visibilitySet:
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "$visibilitySet")
                        self.state = 620
                        self.match(SolidityParser.Internal)
                        localctx.visibilitySet = True
                        pass

                    elif la_ == 4:
                        self.state = 622
                        if not localctx.constantnessSet:
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "$constantnessSet")
                        self.state = 623
                        self.match(SolidityParser.Constant)
                        localctx.constantnessSet = True
                        pass

                    elif la_ == 5:
                        self.state = 625
                        if not localctx.overrideSpecifierSet:
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "$overrideSpecifierSet")
                        self.state = 626
                        self.overrideSpecifier()
                        localctx.overrideSpecifierSet = True
                        pass

                    elif la_ == 6:
                        self.state = 629
                        if not localctx.constantnessSet:
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "$constantnessSet")
                        self.state = 630
                        self.match(SolidityParser.Immutable)
                        localctx.constantnessSet = True
                        pass

                self.state = 636
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 58, self._ctx)

            self.state = 637
            localctx.name = self.identifier()
            self.state = 640
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 83:
                self.state = 638
                self.match(SolidityParser.Assign)
                self.state = 639
                localctx.initialValue = self.expression(0)

            self.state = 642
            self.match(SolidityParser.Semicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ConstantVariableDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.type_ = None  # TypeNameContext
            self.name = None  # IdentifierContext
            self.initialValue = None  # ExpressionContext

        def Constant(self):
            return self.getToken(SolidityParser.Constant, 0)

        def Assign(self):
            return self.getToken(SolidityParser.Assign, 0)

        def Semicolon(self):
            return self.getToken(SolidityParser.Semicolon, 0)

        def typeName(self):
            return self.getTypedRuleContext(SolidityParser.TypeNameContext, 0)

        def identifier(self):
            return self.getTypedRuleContext(SolidityParser.IdentifierContext, 0)

        def expression(self):
            return self.getTypedRuleContext(SolidityParser.ExpressionContext, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_constantVariableDeclaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterConstantVariableDeclaration"):
                listener.enterConstantVariableDeclaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitConstantVariableDeclaration"):
                listener.exitConstantVariableDeclaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitConstantVariableDeclaration"):
                return visitor.visitConstantVariableDeclaration(self)
            else:
                return visitor.visitChildren(self)

    def constantVariableDeclaration(self):

        localctx = SolidityParser.ConstantVariableDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_constantVariableDeclaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 644
            localctx.type_ = self.typeName(0)
            self.state = 645
            self.match(SolidityParser.Constant)
            self.state = 646
            localctx.name = self.identifier()
            self.state = 647
            self.match(SolidityParser.Assign)
            self.state = 648
            localctx.initialValue = self.expression(0)
            self.state = 649
            self.match(SolidityParser.Semicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class EventParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.type_ = None  # TypeNameContext
            self.name = None  # IdentifierContext

        def typeName(self):
            return self.getTypedRuleContext(SolidityParser.TypeNameContext, 0)

        def Indexed(self):
            return self.getToken(SolidityParser.Indexed, 0)

        def identifier(self):
            return self.getTypedRuleContext(SolidityParser.IdentifierContext, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_eventParameter

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterEventParameter"):
                listener.enterEventParameter(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitEventParameter"):
                listener.exitEventParameter(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitEventParameter"):
                return visitor.visitEventParameter(self)
            else:
                return visitor.visitChildren(self)

    def eventParameter(self):

        localctx = SolidityParser.EventParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_eventParameter)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 651
            localctx.type_ = self.typeName(0)
            self.state = 653
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 36:
                self.state = 652
                self.match(SolidityParser.Indexed)

            self.state = 656
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 36028799705415680) != 0) or _la == 130:
                self.state = 655
                localctx.name = self.identifier()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class EventDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None  # IdentifierContext
            self._eventParameter = None  # EventParameterContext
            self.parameters = list()  # of EventParameterContexts

        def Event(self):
            return self.getToken(SolidityParser.Event, 0)

        def LParen(self):
            return self.getToken(SolidityParser.LParen, 0)

        def RParen(self):
            return self.getToken(SolidityParser.RParen, 0)

        def Semicolon(self):
            return self.getToken(SolidityParser.Semicolon, 0)

        def identifier(self):
            return self.getTypedRuleContext(SolidityParser.IdentifierContext, 0)

        def Anonymous(self):
            return self.getToken(SolidityParser.Anonymous, 0)

        def eventParameter(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.EventParameterContext)
            else:
                return self.getTypedRuleContext(SolidityParser.EventParameterContext, i)

        def Comma(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.Comma)
            else:
                return self.getToken(SolidityParser.Comma, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_eventDefinition

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterEventDefinition"):
                listener.enterEventDefinition(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitEventDefinition"):
                listener.exitEventDefinition(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitEventDefinition"):
                return visitor.visitEventDefinition(self)
            else:
                return visitor.visitChildren(self)

    def eventDefinition(self):

        localctx = SolidityParser.EventDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_eventDefinition)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 658
            self.match(SolidityParser.Event)
            self.state = 659
            localctx.name = self.identifier()
            self.state = 660
            self.match(SolidityParser.LParen)
            self.state = 669
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 63, self._ctx)
            if la_ == 1:
                self.state = 661
                localctx._eventParameter = self.eventParameter()
                localctx.parameters.append(localctx._eventParameter)
                self.state = 666
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == 95:
                    self.state = 662
                    self.match(SolidityParser.Comma)
                    self.state = 663
                    localctx._eventParameter = self.eventParameter()
                    localctx.parameters.append(localctx._eventParameter)
                    self.state = 668
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

            self.state = 671
            self.match(SolidityParser.RParen)
            self.state = 673
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 4:
                self.state = 672
                self.match(SolidityParser.Anonymous)

            self.state = 675
            self.match(SolidityParser.Semicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ErrorParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.type_ = None  # TypeNameContext
            self.name = None  # IdentifierContext

        def typeName(self):
            return self.getTypedRuleContext(SolidityParser.TypeNameContext, 0)

        def identifier(self):
            return self.getTypedRuleContext(SolidityParser.IdentifierContext, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_errorParameter

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterErrorParameter"):
                listener.enterErrorParameter(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitErrorParameter"):
                listener.exitErrorParameter(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitErrorParameter"):
                return visitor.visitErrorParameter(self)
            else:
                return visitor.visitChildren(self)

    def errorParameter(self):

        localctx = SolidityParser.ErrorParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_errorParameter)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 677
            localctx.type_ = self.typeName(0)
            self.state = 679
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 36028799705415680) != 0) or _la == 130:
                self.state = 678
                localctx.name = self.identifier()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ErrorDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None  # IdentifierContext
            self._errorParameter = None  # ErrorParameterContext
            self.parameters = list()  # of ErrorParameterContexts

        def Error(self):
            return self.getToken(SolidityParser.Error, 0)

        def LParen(self):
            return self.getToken(SolidityParser.LParen, 0)

        def RParen(self):
            return self.getToken(SolidityParser.RParen, 0)

        def Semicolon(self):
            return self.getToken(SolidityParser.Semicolon, 0)

        def identifier(self):
            return self.getTypedRuleContext(SolidityParser.IdentifierContext, 0)

        def errorParameter(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ErrorParameterContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ErrorParameterContext, i)

        def Comma(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.Comma)
            else:
                return self.getToken(SolidityParser.Comma, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_errorDefinition

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterErrorDefinition"):
                listener.enterErrorDefinition(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitErrorDefinition"):
                listener.exitErrorDefinition(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitErrorDefinition"):
                return visitor.visitErrorDefinition(self)
            else:
                return visitor.visitChildren(self)

    def errorDefinition(self):

        localctx = SolidityParser.ErrorDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_errorDefinition)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 681
            self.match(SolidityParser.Error)
            self.state = 682
            localctx.name = self.identifier()
            self.state = 683
            self.match(SolidityParser.LParen)
            self.state = 692
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 67, self._ctx)
            if la_ == 1:
                self.state = 684
                localctx._errorParameter = self.errorParameter()
                localctx.parameters.append(localctx._errorParameter)
                self.state = 689
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == 95:
                    self.state = 685
                    self.match(SolidityParser.Comma)
                    self.state = 686
                    localctx._errorParameter = self.errorParameter()
                    localctx.parameters.append(localctx._errorParameter)
                    self.state = 691
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

            self.state = 694
            self.match(SolidityParser.RParen)
            self.state = 695
            self.match(SolidityParser.Semicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class UserDefinableOperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BitAnd(self):
            return self.getToken(SolidityParser.BitAnd, 0)

        def BitNot(self):
            return self.getToken(SolidityParser.BitNot, 0)

        def BitOr(self):
            return self.getToken(SolidityParser.BitOr, 0)

        def BitXor(self):
            return self.getToken(SolidityParser.BitXor, 0)

        def Add(self):
            return self.getToken(SolidityParser.Add, 0)

        def Div(self):
            return self.getToken(SolidityParser.Div, 0)

        def Mod(self):
            return self.getToken(SolidityParser.Mod, 0)

        def Mul(self):
            return self.getToken(SolidityParser.Mul, 0)

        def Sub(self):
            return self.getToken(SolidityParser.Sub, 0)

        def Equal(self):
            return self.getToken(SolidityParser.Equal, 0)

        def GreaterThan(self):
            return self.getToken(SolidityParser.GreaterThan, 0)

        def GreaterThanOrEqual(self):
            return self.getToken(SolidityParser.GreaterThanOrEqual, 0)

        def LessThan(self):
            return self.getToken(SolidityParser.LessThan, 0)

        def LessThanOrEqual(self):
            return self.getToken(SolidityParser.LessThanOrEqual, 0)

        def NotEqual(self):
            return self.getToken(SolidityParser.NotEqual, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_userDefinableOperator

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterUserDefinableOperator"):
                listener.enterUserDefinableOperator(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitUserDefinableOperator"):
                listener.exitUserDefinableOperator(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitUserDefinableOperator"):
                return visitor.visitUserDefinableOperator(self)
            else:
                return visitor.visitChildren(self)

    def userDefinableOperator(self):

        localctx = SolidityParser.UserDefinableOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_userDefinableOperator)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 697
            _la = self._input.LA(1)
            if not (((((_la - 98)) & ~0x3f) == 0 and ((1 << (_la - 98)) & 784327) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class UsingDirectiveContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Using(self):
            return self.getToken(SolidityParser.Using, 0)

        def For(self):
            return self.getToken(SolidityParser.For, 0)

        def Semicolon(self):
            return self.getToken(SolidityParser.Semicolon, 0)

        def identifierPath(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.IdentifierPathContext)
            else:
                return self.getTypedRuleContext(SolidityParser.IdentifierPathContext, i)

        def Mul(self):
            return self.getToken(SolidityParser.Mul, 0)

        def typeName(self):
            return self.getTypedRuleContext(SolidityParser.TypeNameContext, 0)

        def Global(self):
            return self.getToken(SolidityParser.Global, 0)

        def LBrace(self):
            return self.getToken(SolidityParser.LBrace, 0)

        def RBrace(self):
            return self.getToken(SolidityParser.RBrace, 0)

        def As(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.As)
            else:
                return self.getToken(SolidityParser.As, i)

        def userDefinableOperator(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.UserDefinableOperatorContext)
            else:
                return self.getTypedRuleContext(SolidityParser.UserDefinableOperatorContext, i)

        def Comma(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.Comma)
            else:
                return self.getToken(SolidityParser.Comma, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_usingDirective

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterUsingDirective"):
                listener.enterUsingDirective(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitUsingDirective"):
                listener.exitUsingDirective(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitUsingDirective"):
                return visitor.visitUsingDirective(self)
            else:
                return visitor.visitChildren(self)

    def usingDirective(self):

        localctx = SolidityParser.UsingDirectiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_usingDirective)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 699
            self.match(SolidityParser.Using)
            self.state = 720
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [21, 29, 31, 55, 130]:
                self.state = 700
                self.identifierPath()
                pass
            elif token in [75]:
                self.state = 701
                self.match(SolidityParser.LBrace)
                self.state = 702
                self.identifierPath()
                self.state = 705
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == 5:
                    self.state = 703
                    self.match(SolidityParser.As)
                    self.state = 704
                    self.userDefinableOperator()

                self.state = 715
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == 95:
                    self.state = 707
                    self.match(SolidityParser.Comma)
                    self.state = 708
                    self.identifierPath()
                    self.state = 711
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la == 5:
                        self.state = 709
                        self.match(SolidityParser.As)
                        self.state = 710
                        self.userDefinableOperator()

                    self.state = 717
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 718
                self.match(SolidityParser.RBrace)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 722
            self.match(SolidityParser.For)
            self.state = 725
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 72, self._ctx)
            if la_ == 1:
                self.state = 723
                self.match(SolidityParser.Mul)
                pass

            elif la_ == 2:
                self.state = 724
                self.typeName(0)
                pass

            self.state = 728
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 31:
                self.state = 727
                self.match(SolidityParser.Global)

            self.state = 730
            self.match(SolidityParser.Semicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TypeNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def elementaryTypeName(self):
            return self.getTypedRuleContext(SolidityParser.ElementaryTypeNameContext, 0)

        def functionTypeName(self):
            return self.getTypedRuleContext(SolidityParser.FunctionTypeNameContext, 0)

        def mappingType(self):
            return self.getTypedRuleContext(SolidityParser.MappingTypeContext, 0)

        def identifierPath(self):
            return self.getTypedRuleContext(SolidityParser.IdentifierPathContext, 0)

        def typeName(self):
            return self.getTypedRuleContext(SolidityParser.TypeNameContext, 0)

        def LBrack(self):
            return self.getToken(SolidityParser.LBrack, 0)

        def RBrack(self):
            return self.getToken(SolidityParser.RBrack, 0)

        def expression(self):
            return self.getTypedRuleContext(SolidityParser.ExpressionContext, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_typeName

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterTypeName"):
                listener.enterTypeName(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitTypeName"):
                listener.exitTypeName(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitTypeName"):
                return visitor.visitTypeName(self)
            else:
                return visitor.visitChildren(self)

    def typeName(self, _p: int = 0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = SolidityParser.TypeNameContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 78
        self.enterRecursionRule(localctx, 78, self.RULE_typeName, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 737
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 74, self._ctx)
            if la_ == 1:
                self.state = 733
                self.elementaryTypeName(SolidityParser.TRUE)
                pass

            elif la_ == 2:
                self.state = 734
                self.functionTypeName()
                pass

            elif la_ == 3:
                self.state = 735
                self.mappingType()
                pass

            elif la_ == 4:
                self.state = 736
                self.identifierPath()
                pass

            self._ctx.stop = self._input.LT(-1)
            self.state = 747
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 76, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = SolidityParser.TypeNameContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_typeName)
                    self.state = 739
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 740
                    self.match(SolidityParser.LBrack)
                    self.state = 742
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input, 75, self._ctx)
                    if la_ == 1:
                        self.state = 741
                        self.expression(0)

                    self.state = 744
                    self.match(SolidityParser.RBrack)
                self.state = 749
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 76, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class ElementaryTypeNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1,
                     allowAddressPayable: bool = None):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.allowAddressPayable = None
            self.allowAddressPayable = allowAddressPayable

        def Address(self):
            return self.getToken(SolidityParser.Address, 0)

        def Payable(self):
            return self.getToken(SolidityParser.Payable, 0)

        def Bool(self):
            return self.getToken(SolidityParser.Bool, 0)

        def String(self):
            return self.getToken(SolidityParser.String, 0)

        def Bytes(self):
            return self.getToken(SolidityParser.Bytes, 0)

        def SignedIntegerType(self):
            return self.getToken(SolidityParser.SignedIntegerType, 0)

        def UnsignedIntegerType(self):
            return self.getToken(SolidityParser.UnsignedIntegerType, 0)

        def FixedBytes(self):
            return self.getToken(SolidityParser.FixedBytes, 0)

        def Fixed(self):
            return self.getToken(SolidityParser.Fixed, 0)

        def Ufixed(self):
            return self.getToken(SolidityParser.Ufixed, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_elementaryTypeName

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterElementaryTypeName"):
                listener.enterElementaryTypeName(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitElementaryTypeName"):
                listener.exitElementaryTypeName(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitElementaryTypeName"):
                return visitor.visitElementaryTypeName(self)
            else:
                return visitor.visitChildren(self)

    def elementaryTypeName(self, allowAddressPayable: bool):

        localctx = SolidityParser.ElementaryTypeNameContext(self, self._ctx, self.state, allowAddressPayable)
        self.enterRule(localctx, 80, self.RULE_elementaryTypeName)
        try:
            self.state = 762
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 77, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 750
                self.match(SolidityParser.Address)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 751
                if not localctx.allowAddressPayable:
                    from antlr4.error.Errors import FailedPredicateException
                    raise FailedPredicateException(self, "$allowAddressPayable")
                self.state = 752
                self.match(SolidityParser.Address)
                self.state = 753
                self.match(SolidityParser.Payable)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 754
                self.match(SolidityParser.Bool)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 755
                self.match(SolidityParser.String)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 756
                self.match(SolidityParser.Bytes)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 757
                self.match(SolidityParser.SignedIntegerType)
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 758
                self.match(SolidityParser.UnsignedIntegerType)
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 759
                self.match(SolidityParser.FixedBytes)
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 760
                self.match(SolidityParser.Fixed)
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 761
                self.match(SolidityParser.Ufixed)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FunctionTypeNameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.visibilitySet = SolidityParser.FALSE
            self.mutabilitySet = SolidityParser.FALSE
            self.arguments = None  # ParameterListContext
            self.returnParameters = None  # ParameterListContext

        def Function(self):
            return self.getToken(SolidityParser.Function, 0)

        def LParen(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.LParen)
            else:
                return self.getToken(SolidityParser.LParen, i)

        def RParen(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.RParen)
            else:
                return self.getToken(SolidityParser.RParen, i)

        def visibility(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.VisibilityContext)
            else:
                return self.getTypedRuleContext(SolidityParser.VisibilityContext, i)

        def stateMutability(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.StateMutabilityContext)
            else:
                return self.getTypedRuleContext(SolidityParser.StateMutabilityContext, i)

        def Returns(self):
            return self.getToken(SolidityParser.Returns, 0)

        def parameterList(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ParameterListContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ParameterListContext, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_functionTypeName

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFunctionTypeName"):
                listener.enterFunctionTypeName(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFunctionTypeName"):
                listener.exitFunctionTypeName(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFunctionTypeName"):
                return visitor.visitFunctionTypeName(self)
            else:
                return visitor.visitChildren(self)

    def functionTypeName(self):

        localctx = SolidityParser.FunctionTypeNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_functionTypeName)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 764
            self.match(SolidityParser.Function)
            self.state = 765
            self.match(SolidityParser.LParen)
            self.state = 767
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 78, self._ctx)
            if la_ == 1:
                self.state = 766
                localctx.arguments = self.parameterList()

            self.state = 769
            self.match(SolidityParser.RParen)
            self.state = 780
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 80, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 778
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input, 79, self._ctx)
                    if la_ == 1:
                        self.state = 770
                        if not localctx.visibilitySet:
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "$visibilitySet")
                        self.state = 771
                        self.visibility()
                        localctx.visibilitySet = True
                        pass

                    elif la_ == 2:
                        self.state = 774
                        if not localctx.mutabilitySet:
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "$mutabilitySet")
                        self.state = 775
                        self.stateMutability()
                        localctx.mutabilitySet = True
                        pass

                self.state = 782
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 80, self._ctx)

            self.state = 788
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 81, self._ctx)
            if la_ == 1:
                self.state = 783
                self.match(SolidityParser.Returns)
                self.state = 784
                self.match(SolidityParser.LParen)
                self.state = 785
                localctx.returnParameters = self.parameterList()
                self.state = 786
                self.match(SolidityParser.RParen)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class VariableDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.type_ = None  # TypeNameContext
            self.location = None  # DataLocationContext
            self.name = None  # IdentifierContext

        def typeName(self):
            return self.getTypedRuleContext(SolidityParser.TypeNameContext, 0)

        def identifier(self):
            return self.getTypedRuleContext(SolidityParser.IdentifierContext, 0)

        def dataLocation(self):
            return self.getTypedRuleContext(SolidityParser.DataLocationContext, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_variableDeclaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterVariableDeclaration"):
                listener.enterVariableDeclaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitVariableDeclaration"):
                listener.exitVariableDeclaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitVariableDeclaration"):
                return visitor.visitVariableDeclaration(self)
            else:
                return visitor.visitChildren(self)

    def variableDeclaration(self):

        localctx = SolidityParser.VariableDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_variableDeclaration)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 790
            localctx.type_ = self.typeName(0)
            self.state = 792
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 144119586122368000) != 0):
                self.state = 791
                localctx.location = self.dataLocation()

            self.state = 794
            localctx.name = self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DataLocationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Memory(self):
            return self.getToken(SolidityParser.Memory, 0)

        def Storage(self):
            return self.getToken(SolidityParser.Storage, 0)

        def Calldata(self):
            return self.getToken(SolidityParser.Calldata, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_dataLocation

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterDataLocation"):
                listener.enterDataLocation(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitDataLocation"):
                listener.exitDataLocation(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitDataLocation"):
                return visitor.visitDataLocation(self)
            else:
                return visitor.visitChildren(self)

    def dataLocation(self):

        localctx = SolidityParser.DataLocationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_dataLocation)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 796
            _la = self._input.LA(1)
            if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 144119586122368000) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def getRuleIndex(self):
            return SolidityParser.RULE_expression

        def copyFrom(self, ctx: ParserRuleContext):
            super().copyFrom(ctx)

    class UnaryPrefixOperationContext(ExpressionContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a SolidityParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self):
            return self.getTypedRuleContext(SolidityParser.ExpressionContext, 0)

        def Inc(self):
            return self.getToken(SolidityParser.Inc, 0)

        def Dec(self):
            return self.getToken(SolidityParser.Dec, 0)

        def Not(self):
            return self.getToken(SolidityParser.Not, 0)

        def BitNot(self):
            return self.getToken(SolidityParser.BitNot, 0)

        def Delete(self):
            return self.getToken(SolidityParser.Delete, 0)

        def Sub(self):
            return self.getToken(SolidityParser.Sub, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterUnaryPrefixOperation"):
                listener.enterUnaryPrefixOperation(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitUnaryPrefixOperation"):
                listener.exitUnaryPrefixOperation(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitUnaryPrefixOperation"):
                return visitor.visitUnaryPrefixOperation(self)
            else:
                return visitor.visitChildren(self)

    class PrimaryExpressionContext(ExpressionContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a SolidityParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(SolidityParser.IdentifierContext, 0)

        def literal(self):
            return self.getTypedRuleContext(SolidityParser.LiteralContext, 0)

        def literalWithSubDenomination(self):
            return self.getTypedRuleContext(SolidityParser.LiteralWithSubDenominationContext, 0)

        def elementaryTypeName(self):
            return self.getTypedRuleContext(SolidityParser.ElementaryTypeNameContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterPrimaryExpression"):
                listener.enterPrimaryExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitPrimaryExpression"):
                listener.exitPrimaryExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitPrimaryExpression"):
                return visitor.visitPrimaryExpression(self)
            else:
                return visitor.visitChildren(self)

    class OrderComparisonContext(ExpressionContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a SolidityParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ExpressionContext, i)

        def LessThan(self):
            return self.getToken(SolidityParser.LessThan, 0)

        def GreaterThan(self):
            return self.getToken(SolidityParser.GreaterThan, 0)

        def LessThanOrEqual(self):
            return self.getToken(SolidityParser.LessThanOrEqual, 0)

        def GreaterThanOrEqual(self):
            return self.getToken(SolidityParser.GreaterThanOrEqual, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterOrderComparison"):
                listener.enterOrderComparison(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitOrderComparison"):
                listener.exitOrderComparison(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitOrderComparison"):
                return visitor.visitOrderComparison(self)
            else:
                return visitor.visitChildren(self)

    class ConditionalContext(ExpressionContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a SolidityParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ExpressionContext, i)

        def Conditional(self):
            return self.getToken(SolidityParser.Conditional, 0)

        def Colon(self):
            return self.getToken(SolidityParser.Colon, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterConditional"):
                listener.enterConditional(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitConditional"):
                listener.exitConditional(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitConditional"):
                return visitor.visitConditional(self)
            else:
                return visitor.visitChildren(self)

    class PayableConversionContext(ExpressionContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a SolidityParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Payable(self):
            return self.getToken(SolidityParser.Payable, 0)

        def callArgumentList(self):
            return self.getTypedRuleContext(SolidityParser.CallArgumentListContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterPayableConversion"):
                listener.enterPayableConversion(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitPayableConversion"):
                listener.exitPayableConversion(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitPayableConversion"):
                return visitor.visitPayableConversion(self)
            else:
                return visitor.visitChildren(self)

    class AssignmentContext(ExpressionContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a SolidityParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ExpressionContext, i)

        def assignOp(self):
            return self.getTypedRuleContext(SolidityParser.AssignOpContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAssignment"):
                listener.enterAssignment(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAssignment"):
                listener.exitAssignment(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAssignment"):
                return visitor.visitAssignment(self)
            else:
                return visitor.visitChildren(self)

    class UnarySuffixOperationContext(ExpressionContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a SolidityParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self):
            return self.getTypedRuleContext(SolidityParser.ExpressionContext, 0)

        def Inc(self):
            return self.getToken(SolidityParser.Inc, 0)

        def Dec(self):
            return self.getToken(SolidityParser.Dec, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterUnarySuffixOperation"):
                listener.enterUnarySuffixOperation(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitUnarySuffixOperation"):
                listener.exitUnarySuffixOperation(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitUnarySuffixOperation"):
                return visitor.visitUnarySuffixOperation(self)
            else:
                return visitor.visitChildren(self)

    class ShiftOperationContext(ExpressionContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a SolidityParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ExpressionContext, i)

        def Shl(self):
            return self.getToken(SolidityParser.Shl, 0)

        def Sar(self):
            return self.getToken(SolidityParser.Sar, 0)

        def Shr(self):
            return self.getToken(SolidityParser.Shr, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterShiftOperation"):
                listener.enterShiftOperation(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitShiftOperation"):
                listener.exitShiftOperation(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitShiftOperation"):
                return visitor.visitShiftOperation(self)
            else:
                return visitor.visitChildren(self)

    class BitAndOperationContext(ExpressionContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a SolidityParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ExpressionContext, i)

        def BitAnd(self):
            return self.getToken(SolidityParser.BitAnd, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterBitAndOperation"):
                listener.enterBitAndOperation(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitBitAndOperation"):
                listener.exitBitAndOperation(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitBitAndOperation"):
                return visitor.visitBitAndOperation(self)
            else:
                return visitor.visitChildren(self)

    class FunctionCallContext(ExpressionContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a SolidityParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self):
            return self.getTypedRuleContext(SolidityParser.ExpressionContext, 0)

        def callArgumentList(self):
            return self.getTypedRuleContext(SolidityParser.CallArgumentListContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFunctionCall"):
                listener.enterFunctionCall(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFunctionCall"):
                listener.exitFunctionCall(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFunctionCall"):
                return visitor.visitFunctionCall(self)
            else:
                return visitor.visitChildren(self)

    class IndexRangeAccessContext(ExpressionContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a SolidityParser.ExpressionContext
            super().__init__(parser)
            self.startIndex = None  # ExpressionContext
            self.endIndex = None  # ExpressionContext
            self.copyFrom(ctx)

        def expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ExpressionContext, i)

        def LBrack(self):
            return self.getToken(SolidityParser.LBrack, 0)

        def Colon(self):
            return self.getToken(SolidityParser.Colon, 0)

        def RBrack(self):
            return self.getToken(SolidityParser.RBrack, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterIndexRangeAccess"):
                listener.enterIndexRangeAccess(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitIndexRangeAccess"):
                listener.exitIndexRangeAccess(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitIndexRangeAccess"):
                return visitor.visitIndexRangeAccess(self)
            else:
                return visitor.visitChildren(self)

    class IndexAccessContext(ExpressionContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a SolidityParser.ExpressionContext
            super().__init__(parser)
            self.index = None  # ExpressionContext
            self.copyFrom(ctx)

        def expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ExpressionContext, i)

        def LBrack(self):
            return self.getToken(SolidityParser.LBrack, 0)

        def RBrack(self):
            return self.getToken(SolidityParser.RBrack, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterIndexAccess"):
                listener.enterIndexAccess(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitIndexAccess"):
                listener.exitIndexAccess(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitIndexAccess"):
                return visitor.visitIndexAccess(self)
            else:
                return visitor.visitChildren(self)

    class AddSubOperationContext(ExpressionContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a SolidityParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ExpressionContext, i)

        def Add(self):
            return self.getToken(SolidityParser.Add, 0)

        def Sub(self):
            return self.getToken(SolidityParser.Sub, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAddSubOperation"):
                listener.enterAddSubOperation(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAddSubOperation"):
                listener.exitAddSubOperation(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAddSubOperation"):
                return visitor.visitAddSubOperation(self)
            else:
                return visitor.visitChildren(self)

    class BitOrOperationContext(ExpressionContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a SolidityParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ExpressionContext, i)

        def BitOr(self):
            return self.getToken(SolidityParser.BitOr, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterBitOrOperation"):
                listener.enterBitOrOperation(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitBitOrOperation"):
                listener.exitBitOrOperation(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitBitOrOperation"):
                return visitor.visitBitOrOperation(self)
            else:
                return visitor.visitChildren(self)

    class ExpOperationContext(ExpressionContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a SolidityParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ExpressionContext, i)

        def Exp(self):
            return self.getToken(SolidityParser.Exp, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExpOperation"):
                listener.enterExpOperation(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExpOperation"):
                listener.exitExpOperation(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExpOperation"):
                return visitor.visitExpOperation(self)
            else:
                return visitor.visitChildren(self)

    class AndOperationContext(ExpressionContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a SolidityParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ExpressionContext, i)

        def And(self):
            return self.getToken(SolidityParser.And, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAndOperation"):
                listener.enterAndOperation(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAndOperation"):
                listener.exitAndOperation(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAndOperation"):
                return visitor.visitAndOperation(self)
            else:
                return visitor.visitChildren(self)

    class InlineArrayContext(ExpressionContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a SolidityParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def inlineArrayExpression(self):
            return self.getTypedRuleContext(SolidityParser.InlineArrayExpressionContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterInlineArray"):
                listener.enterInlineArray(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitInlineArray"):
                listener.exitInlineArray(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitInlineArray"):
                return visitor.visitInlineArray(self)
            else:
                return visitor.visitChildren(self)

    class OrOperationContext(ExpressionContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a SolidityParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ExpressionContext, i)

        def Or(self):
            return self.getToken(SolidityParser.Or, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterOrOperation"):
                listener.enterOrOperation(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitOrOperation"):
                listener.exitOrOperation(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitOrOperation"):
                return visitor.visitOrOperation(self)
            else:
                return visitor.visitChildren(self)

    class MemberAccessContext(ExpressionContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a SolidityParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self):
            return self.getTypedRuleContext(SolidityParser.ExpressionContext, 0)

        def Period(self):
            return self.getToken(SolidityParser.Period, 0)

        def identifier(self):
            return self.getTypedRuleContext(SolidityParser.IdentifierContext, 0)

        def Address(self):
            return self.getToken(SolidityParser.Address, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterMemberAccess"):
                listener.enterMemberAccess(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitMemberAccess"):
                listener.exitMemberAccess(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitMemberAccess"):
                return visitor.visitMemberAccess(self)
            else:
                return visitor.visitChildren(self)

    class MulDivModOperationContext(ExpressionContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a SolidityParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ExpressionContext, i)

        def Mul(self):
            return self.getToken(SolidityParser.Mul, 0)

        def Div(self):
            return self.getToken(SolidityParser.Div, 0)

        def Mod(self):
            return self.getToken(SolidityParser.Mod, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterMulDivModOperation"):
                listener.enterMulDivModOperation(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitMulDivModOperation"):
                listener.exitMulDivModOperation(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitMulDivModOperation"):
                return visitor.visitMulDivModOperation(self)
            else:
                return visitor.visitChildren(self)

    class FunctionCallOptionsContext(ExpressionContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a SolidityParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self):
            return self.getTypedRuleContext(SolidityParser.ExpressionContext, 0)

        def LBrace(self):
            return self.getToken(SolidityParser.LBrace, 0)

        def RBrace(self):
            return self.getToken(SolidityParser.RBrace, 0)

        def namedArgument(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.NamedArgumentContext)
            else:
                return self.getTypedRuleContext(SolidityParser.NamedArgumentContext, i)

        def Comma(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.Comma)
            else:
                return self.getToken(SolidityParser.Comma, i)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFunctionCallOptions"):
                listener.enterFunctionCallOptions(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFunctionCallOptions"):
                listener.exitFunctionCallOptions(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFunctionCallOptions"):
                return visitor.visitFunctionCallOptions(self)
            else:
                return visitor.visitChildren(self)

    class NewExprContext(ExpressionContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a SolidityParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def New(self):
            return self.getToken(SolidityParser.New, 0)

        def typeName(self):
            return self.getTypedRuleContext(SolidityParser.TypeNameContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterNewExpr"):
                listener.enterNewExpr(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitNewExpr"):
                listener.exitNewExpr(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitNewExpr"):
                return visitor.visitNewExpr(self)
            else:
                return visitor.visitChildren(self)

    class BitXorOperationContext(ExpressionContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a SolidityParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ExpressionContext, i)

        def BitXor(self):
            return self.getToken(SolidityParser.BitXor, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterBitXorOperation"):
                listener.enterBitXorOperation(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitBitXorOperation"):
                listener.exitBitXorOperation(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitBitXorOperation"):
                return visitor.visitBitXorOperation(self)
            else:
                return visitor.visitChildren(self)

    class TupleContext(ExpressionContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a SolidityParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def tupleExpression(self):
            return self.getTypedRuleContext(SolidityParser.TupleExpressionContext, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterTuple"):
                listener.enterTuple(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitTuple"):
                listener.exitTuple(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitTuple"):
                return visitor.visitTuple(self)
            else:
                return visitor.visitChildren(self)

    class EqualityComparisonContext(ExpressionContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a SolidityParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ExpressionContext, i)

        def Equal(self):
            return self.getToken(SolidityParser.Equal, 0)

        def NotEqual(self):
            return self.getToken(SolidityParser.NotEqual, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterEqualityComparison"):
                listener.enterEqualityComparison(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitEqualityComparison"):
                listener.exitEqualityComparison(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitEqualityComparison"):
                return visitor.visitEqualityComparison(self)
            else:
                return visitor.visitChildren(self)

    class MetaTypeContext(ExpressionContext):

        def __init__(self, parser, ctx: ParserRuleContext):  # actually a SolidityParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Type(self):
            return self.getToken(SolidityParser.Type, 0)

        def LParen(self):
            return self.getToken(SolidityParser.LParen, 0)

        def typeName(self):
            return self.getTypedRuleContext(SolidityParser.TypeNameContext, 0)

        def RParen(self):
            return self.getToken(SolidityParser.RParen, 0)

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterMetaType"):
                listener.enterMetaType(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitMetaType"):
                listener.exitMetaType(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitMetaType"):
                return visitor.visitMetaType(self)
            else:
                return visitor.visitChildren(self)

    def expression(self, _p: int = 0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = SolidityParser.ExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 88
        self.enterRecursionRule(localctx, 88, self.RULE_expression, _p)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 818
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 84, self._ctx)
            if la_ == 1:
                localctx = SolidityParser.PayableConversionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 799
                self.match(SolidityParser.Payable)
                self.state = 800
                self.callArgumentList()
                pass

            elif la_ == 2:
                localctx = SolidityParser.MetaTypeContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 801
                self.match(SolidityParser.Type)
                self.state = 802
                self.match(SolidityParser.LParen)
                self.state = 803
                self.typeName(0)
                self.state = 804
                self.match(SolidityParser.RParen)
                pass

            elif la_ == 3:
                localctx = SolidityParser.UnaryPrefixOperationContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 806
                _la = self._input.LA(1)
                if not (_la == 16 or ((((_la - 105)) & ~0x3f) == 0 and ((1 << (_la - 105)) & 30721) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 807
                self.expression(19)
                pass

            elif la_ == 4:
                localctx = SolidityParser.NewExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 808
                self.match(SolidityParser.New)
                self.state = 809
                self.typeName(0)
                pass

            elif la_ == 5:
                localctx = SolidityParser.TupleContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 810
                self.tupleExpression()
                pass

            elif la_ == 6:
                localctx = SolidityParser.InlineArrayContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 811
                self.inlineArrayExpression()
                pass

            elif la_ == 7:
                localctx = SolidityParser.PrimaryExpressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 816
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 83, self._ctx)
                if la_ == 1:
                    self.state = 812
                    self.identifier()
                    pass

                elif la_ == 2:
                    self.state = 813
                    self.literal()
                    pass

                elif la_ == 3:
                    self.state = 814
                    self.literalWithSubDenomination()
                    pass

                elif la_ == 4:
                    self.state = 815
                    self.elementaryTypeName(SolidityParser.FALSE)
                    pass

                pass

            self._ctx.stop = self._input.LT(-1)
            self.state = 904
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 92, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 902
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input, 91, self._ctx)
                    if la_ == 1:
                        localctx = SolidityParser.ExpOperationContext(self,
                                                                      SolidityParser.ExpressionContext(self, _parentctx,
                                                                                                       _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 820
                        if not self.precpred(self._ctx, 17):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 17)")
                        self.state = 821
                        self.match(SolidityParser.Exp)
                        self.state = 822
                        self.expression(17)
                        pass

                    elif la_ == 2:
                        localctx = SolidityParser.MulDivModOperationContext(self, SolidityParser.ExpressionContext(self,
                                                                                                                   _parentctx,
                                                                                                                   _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 823
                        if not self.precpred(self._ctx, 16):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 16)")
                        self.state = 824
                        _la = self._input.LA(1)
                        if not (((((_la - 106)) & ~0x3f) == 0 and ((1 << (_la - 106)) & 7) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 825
                        self.expression(17)
                        pass

                    elif la_ == 3:
                        localctx = SolidityParser.AddSubOperationContext(self, SolidityParser.ExpressionContext(self,
                                                                                                                _parentctx,
                                                                                                                _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 826
                        if not self.precpred(self._ctx, 15):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 15)")
                        self.state = 827
                        _la = self._input.LA(1)
                        if not (_la == 104 or _la == 105):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 828
                        self.expression(16)
                        pass

                    elif la_ == 4:
                        localctx = SolidityParser.ShiftOperationContext(self, SolidityParser.ExpressionContext(self,
                                                                                                               _parentctx,
                                                                                                               _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 829
                        if not self.precpred(self._ctx, 14):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 14)")
                        self.state = 830
                        _la = self._input.LA(1)
                        if not (((((_la - 101)) & ~0x3f) == 0 and ((1 << (_la - 101)) & 7) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 831
                        self.expression(15)
                        pass

                    elif la_ == 5:
                        localctx = SolidityParser.BitAndOperationContext(self, SolidityParser.ExpressionContext(self,
                                                                                                                _parentctx,
                                                                                                                _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 832
                        if not self.precpred(self._ctx, 13):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 13)")
                        self.state = 833
                        self.match(SolidityParser.BitAnd)
                        self.state = 834
                        self.expression(14)
                        pass

                    elif la_ == 6:
                        localctx = SolidityParser.BitXorOperationContext(self, SolidityParser.ExpressionContext(self,
                                                                                                                _parentctx,
                                                                                                                _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 835
                        if not self.precpred(self._ctx, 12):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 12)")
                        self.state = 836
                        self.match(SolidityParser.BitXor)
                        self.state = 837
                        self.expression(13)
                        pass

                    elif la_ == 7:
                        localctx = SolidityParser.BitOrOperationContext(self, SolidityParser.ExpressionContext(self,
                                                                                                               _parentctx,
                                                                                                               _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 838
                        if not self.precpred(self._ctx, 11):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 11)")
                        self.state = 839
                        self.match(SolidityParser.BitOr)
                        self.state = 840
                        self.expression(12)
                        pass

                    elif la_ == 8:
                        localctx = SolidityParser.OrderComparisonContext(self, SolidityParser.ExpressionContext(self,
                                                                                                                _parentctx,
                                                                                                                _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 841
                        if not self.precpred(self._ctx, 10):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 10)")
                        self.state = 842
                        _la = self._input.LA(1)
                        if not (((((_la - 112)) & ~0x3f) == 0 and ((1 << (_la - 112)) & 15) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 843
                        self.expression(11)
                        pass

                    elif la_ == 9:
                        localctx = SolidityParser.EqualityComparisonContext(self, SolidityParser.ExpressionContext(self,
                                                                                                                   _parentctx,
                                                                                                                   _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 844
                        if not self.precpred(self._ctx, 9):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 9)")
                        self.state = 845
                        _la = self._input.LA(1)
                        if not (_la == 110 or _la == 111):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 846
                        self.expression(10)
                        pass

                    elif la_ == 10:
                        localctx = SolidityParser.AndOperationContext(self,
                                                                      SolidityParser.ExpressionContext(self, _parentctx,
                                                                                                       _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 847
                        if not self.precpred(self._ctx, 8):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 8)")
                        self.state = 848
                        self.match(SolidityParser.And)
                        self.state = 849
                        self.expression(9)
                        pass

                    elif la_ == 11:
                        localctx = SolidityParser.OrOperationContext(self,
                                                                     SolidityParser.ExpressionContext(self, _parentctx,
                                                                                                      _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 850
                        if not self.precpred(self._ctx, 7):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 7)")
                        self.state = 851
                        self.match(SolidityParser.Or)
                        self.state = 852
                        self.expression(8)
                        pass

                    elif la_ == 12:
                        localctx = SolidityParser.ConditionalContext(self,
                                                                     SolidityParser.ExpressionContext(self, _parentctx,
                                                                                                      _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 853
                        if not self.precpred(self._ctx, 6):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 6)")
                        self.state = 854
                        self.match(SolidityParser.Conditional)
                        self.state = 855
                        self.expression(0)
                        self.state = 856
                        self.match(SolidityParser.Colon)
                        self.state = 857
                        self.expression(6)
                        pass

                    elif la_ == 13:
                        localctx = SolidityParser.AssignmentContext(self,
                                                                    SolidityParser.ExpressionContext(self, _parentctx,
                                                                                                     _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 859
                        if not self.precpred(self._ctx, 5):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 5)")
                        self.state = 860
                        self.assignOp()
                        self.state = 861
                        self.expression(5)
                        pass

                    elif la_ == 14:
                        localctx = SolidityParser.IndexAccessContext(self,
                                                                     SolidityParser.ExpressionContext(self, _parentctx,
                                                                                                      _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 863
                        if not self.precpred(self._ctx, 26):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 26)")
                        self.state = 864
                        self.match(SolidityParser.LBrack)
                        self.state = 866
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input, 85, self._ctx)
                        if la_ == 1:
                            self.state = 865
                            localctx.index = self.expression(0)

                        self.state = 868
                        self.match(SolidityParser.RBrack)
                        pass

                    elif la_ == 15:
                        localctx = SolidityParser.IndexRangeAccessContext(self, SolidityParser.ExpressionContext(self,
                                                                                                                 _parentctx,
                                                                                                                 _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 869
                        if not self.precpred(self._ctx, 25):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 25)")
                        self.state = 870
                        self.match(SolidityParser.LBrack)
                        self.state = 872
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input, 86, self._ctx)
                        if la_ == 1:
                            self.state = 871
                            localctx.startIndex = self.expression(0)

                        self.state = 874
                        self.match(SolidityParser.Colon)
                        self.state = 876
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input, 87, self._ctx)
                        if la_ == 1:
                            self.state = 875
                            localctx.endIndex = self.expression(0)

                        self.state = 878
                        self.match(SolidityParser.RBrack)
                        pass

                    elif la_ == 16:
                        localctx = SolidityParser.MemberAccessContext(self,
                                                                      SolidityParser.ExpressionContext(self, _parentctx,
                                                                                                       _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 879
                        if not self.precpred(self._ctx, 24):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 24)")
                        self.state = 880
                        self.match(SolidityParser.Period)
                        self.state = 883
                        self._errHandler.sync(self)
                        token = self._input.LA(1)
                        if token in [21, 29, 31, 55, 130]:
                            self.state = 881
                            self.identifier()
                            pass
                        elif token in [3]:
                            self.state = 882
                            self.match(SolidityParser.Address)
                            pass
                        else:
                            raise NoViableAltException(self)

                        pass

                    elif la_ == 17:
                        localctx = SolidityParser.FunctionCallOptionsContext(self,
                                                                             SolidityParser.ExpressionContext(self,
                                                                                                              _parentctx,
                                                                                                              _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 885
                        if not self.precpred(self._ctx, 23):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 23)")
                        self.state = 886
                        self.match(SolidityParser.LBrace)
                        self.state = 895
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if (((_la) & ~0x3f) == 0 and ((1 << _la) & 36028799705415680) != 0) or _la == 130:
                            self.state = 887
                            self.namedArgument()
                            self.state = 892
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)
                            while _la == 95:
                                self.state = 888
                                self.match(SolidityParser.Comma)
                                self.state = 889
                                self.namedArgument()
                                self.state = 894
                                self._errHandler.sync(self)
                                _la = self._input.LA(1)

                        self.state = 897
                        self.match(SolidityParser.RBrace)
                        pass

                    elif la_ == 18:
                        localctx = SolidityParser.FunctionCallContext(self,
                                                                      SolidityParser.ExpressionContext(self, _parentctx,
                                                                                                       _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 898
                        if not self.precpred(self._ctx, 22):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 22)")
                        self.state = 899
                        self.callArgumentList()
                        pass

                    elif la_ == 19:
                        localctx = SolidityParser.UnarySuffixOperationContext(self,
                                                                              SolidityParser.ExpressionContext(self,
                                                                                                               _parentctx,
                                                                                                               _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 900
                        if not self.precpred(self._ctx, 18):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 18)")
                        self.state = 901
                        _la = self._input.LA(1)
                        if not (_la == 118 or _la == 119):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        pass

                self.state = 906
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 92, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class AssignOpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Assign(self):
            return self.getToken(SolidityParser.Assign, 0)

        def AssignBitOr(self):
            return self.getToken(SolidityParser.AssignBitOr, 0)

        def AssignBitXor(self):
            return self.getToken(SolidityParser.AssignBitXor, 0)

        def AssignBitAnd(self):
            return self.getToken(SolidityParser.AssignBitAnd, 0)

        def AssignShl(self):
            return self.getToken(SolidityParser.AssignShl, 0)

        def AssignSar(self):
            return self.getToken(SolidityParser.AssignSar, 0)

        def AssignShr(self):
            return self.getToken(SolidityParser.AssignShr, 0)

        def AssignAdd(self):
            return self.getToken(SolidityParser.AssignAdd, 0)

        def AssignSub(self):
            return self.getToken(SolidityParser.AssignSub, 0)

        def AssignMul(self):
            return self.getToken(SolidityParser.AssignMul, 0)

        def AssignDiv(self):
            return self.getToken(SolidityParser.AssignDiv, 0)

        def AssignMod(self):
            return self.getToken(SolidityParser.AssignMod, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_assignOp

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAssignOp"):
                listener.enterAssignOp(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAssignOp"):
                listener.exitAssignOp(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAssignOp"):
                return visitor.visitAssignOp(self)
            else:
                return visitor.visitChildren(self)

    def assignOp(self):

        localctx = SolidityParser.AssignOpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_assignOp)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 907
            _la = self._input.LA(1)
            if not (((((_la - 83)) & ~0x3f) == 0 and ((1 << (_la - 83)) & 4095) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TupleExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LParen(self):
            return self.getToken(SolidityParser.LParen, 0)

        def RParen(self):
            return self.getToken(SolidityParser.RParen, 0)

        def expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ExpressionContext, i)

        def Comma(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.Comma)
            else:
                return self.getToken(SolidityParser.Comma, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_tupleExpression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterTupleExpression"):
                listener.enterTupleExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitTupleExpression"):
                listener.exitTupleExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitTupleExpression"):
                return visitor.visitTupleExpression(self)
            else:
                return visitor.visitChildren(self)

    def tupleExpression(self):

        localctx = SolidityParser.TupleExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_tupleExpression)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 909
            self.match(SolidityParser.LParen)

            self.state = 911
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 93, self._ctx)
            if la_ == 1:
                self.state = 910
                self.expression(0)

            self.state = 919
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 95:
                self.state = 913
                self.match(SolidityParser.Comma)
                self.state = 915
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 94, self._ctx)
                if la_ == 1:
                    self.state = 914
                    self.expression(0)

                self.state = 921
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 922
            self.match(SolidityParser.RParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class InlineArrayExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LBrack(self):
            return self.getToken(SolidityParser.LBrack, 0)

        def RBrack(self):
            return self.getToken(SolidityParser.RBrack, 0)

        def expression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.ExpressionContext, i)

        def Comma(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.Comma)
            else:
                return self.getToken(SolidityParser.Comma, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_inlineArrayExpression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterInlineArrayExpression"):
                listener.enterInlineArrayExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitInlineArrayExpression"):
                listener.exitInlineArrayExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitInlineArrayExpression"):
                return visitor.visitInlineArrayExpression(self)
            else:
                return visitor.visitChildren(self)

    def inlineArrayExpression(self):

        localctx = SolidityParser.InlineArrayExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_inlineArrayExpression)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 924
            self.match(SolidityParser.LBrack)

            self.state = 925
            self.expression(0)
            self.state = 930
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 95:
                self.state = 926
                self.match(SolidityParser.Comma)
                self.state = 927
                self.expression(0)
                self.state = 932
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 933
            self.match(SolidityParser.RBrack)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class IdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(SolidityParser.Identifier, 0)

        def From(self):
            return self.getToken(SolidityParser.From, 0)

        def Error(self):
            return self.getToken(SolidityParser.Error, 0)

        def Revert(self):
            return self.getToken(SolidityParser.Revert, 0)

        def Global(self):
            return self.getToken(SolidityParser.Global, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_identifier

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterIdentifier"):
                listener.enterIdentifier(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitIdentifier"):
                listener.exitIdentifier(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitIdentifier"):
                return visitor.visitIdentifier(self)
            else:
                return visitor.visitChildren(self)

    def identifier(self):

        localctx = SolidityParser.IdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_identifier)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 935
            _la = self._input.LA(1)
            if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & 36028799705415680) != 0) or _la == 130):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def stringLiteral(self):
            return self.getTypedRuleContext(SolidityParser.StringLiteralContext, 0)

        def numberLiteral(self):
            return self.getTypedRuleContext(SolidityParser.NumberLiteralContext, 0)

        def boolLiteral(self):
            return self.getTypedRuleContext(SolidityParser.BoolLiteralContext, 0)

        def hexStringLiteral(self):
            return self.getTypedRuleContext(SolidityParser.HexStringLiteralContext, 0)

        def unicodeStringLiteral(self):
            return self.getTypedRuleContext(SolidityParser.UnicodeStringLiteralContext, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_literal

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLiteral"):
                listener.enterLiteral(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLiteral"):
                listener.exitLiteral(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitLiteral"):
                return visitor.visitLiteral(self)
            else:
                return visitor.visitChildren(self)

    def literal(self):

        localctx = SolidityParser.LiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_literal)
        try:
            self.state = 942
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [122, 123]:
                self.enterOuterAlt(localctx, 1)
                self.state = 937
                self.stringLiteral()
                pass
            elif token in [126, 128]:
                self.enterOuterAlt(localctx, 2)
                self.state = 938
                self.numberLiteral()
                pass
            elif token in [25, 60]:
                self.enterOuterAlt(localctx, 3)
                self.state = 939
                self.boolLiteral()
                pass
            elif token in [125]:
                self.enterOuterAlt(localctx, 4)
                self.state = 940
                self.hexStringLiteral()
                pass
            elif token in [124]:
                self.enterOuterAlt(localctx, 5)
                self.state = 941
                self.unicodeStringLiteral()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LiteralWithSubDenominationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def numberLiteral(self):
            return self.getTypedRuleContext(SolidityParser.NumberLiteralContext, 0)

        def SubDenomination(self):
            return self.getToken(SolidityParser.SubDenomination, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_literalWithSubDenomination

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterLiteralWithSubDenomination"):
                listener.enterLiteralWithSubDenomination(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitLiteralWithSubDenomination"):
                listener.exitLiteralWithSubDenomination(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitLiteralWithSubDenomination"):
                return visitor.visitLiteralWithSubDenomination(self)
            else:
                return visitor.visitChildren(self)

    def literalWithSubDenomination(self):

        localctx = SolidityParser.LiteralWithSubDenominationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_literalWithSubDenomination)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 944
            self.numberLiteral()
            self.state = 945
            self.match(SolidityParser.SubDenomination)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BoolLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TRUE(self):
            return self.getToken(SolidityParser.TRUE, 0)

        def FALSE(self):
            return self.getToken(SolidityParser.FALSE, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_boolLiteral

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterBoolLiteral"):
                listener.enterBoolLiteral(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitBoolLiteral"):
                listener.exitBoolLiteral(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitBoolLiteral"):
                return visitor.visitBoolLiteral(self)
            else:
                return visitor.visitChildren(self)

    def boolLiteral(self):

        localctx = SolidityParser.BoolLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_boolLiteral)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 947
            _la = self._input.LA(1)
            if not (_la == 25 or _la == 60):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StringLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NonEmptyStringLiteral(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.NonEmptyStringLiteral)
            else:
                return self.getToken(SolidityParser.NonEmptyStringLiteral, i)

        def EmptyStringLiteral(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.EmptyStringLiteral)
            else:
                return self.getToken(SolidityParser.EmptyStringLiteral, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_stringLiteral

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterStringLiteral"):
                listener.enterStringLiteral(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitStringLiteral"):
                listener.exitStringLiteral(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitStringLiteral"):
                return visitor.visitStringLiteral(self)
            else:
                return visitor.visitChildren(self)

    def stringLiteral(self):

        localctx = SolidityParser.StringLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_stringLiteral)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 950
            self._errHandler.sync(self)
            _alt = 1
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 949
                    _la = self._input.LA(1)
                    if not (_la == 122 or _la == 123):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()

                else:
                    raise NoViableAltException(self)
                self.state = 952
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 98, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class HexStringLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HexString(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.HexString)
            else:
                return self.getToken(SolidityParser.HexString, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_hexStringLiteral

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterHexStringLiteral"):
                listener.enterHexStringLiteral(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitHexStringLiteral"):
                listener.exitHexStringLiteral(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitHexStringLiteral"):
                return visitor.visitHexStringLiteral(self)
            else:
                return visitor.visitChildren(self)

    def hexStringLiteral(self):

        localctx = SolidityParser.HexStringLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_hexStringLiteral)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 955
            self._errHandler.sync(self)
            _alt = 1
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 954
                    self.match(SolidityParser.HexString)

                else:
                    raise NoViableAltException(self)
                self.state = 957
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 99, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class UnicodeStringLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UnicodeStringLiteral(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.UnicodeStringLiteral)
            else:
                return self.getToken(SolidityParser.UnicodeStringLiteral, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_unicodeStringLiteral

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterUnicodeStringLiteral"):
                listener.enterUnicodeStringLiteral(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitUnicodeStringLiteral"):
                listener.exitUnicodeStringLiteral(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitUnicodeStringLiteral"):
                return visitor.visitUnicodeStringLiteral(self)
            else:
                return visitor.visitChildren(self)

    def unicodeStringLiteral(self):

        localctx = SolidityParser.UnicodeStringLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_unicodeStringLiteral)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 960
            self._errHandler.sync(self)
            _alt = 1
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 959
                    self.match(SolidityParser.UnicodeStringLiteral)

                else:
                    raise NoViableAltException(self)
                self.state = 962
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 100, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class NumberLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DecimalNumber(self):
            return self.getToken(SolidityParser.DecimalNumber, 0)

        def HexNumber(self):
            return self.getToken(SolidityParser.HexNumber, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_numberLiteral

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterNumberLiteral"):
                listener.enterNumberLiteral(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitNumberLiteral"):
                listener.exitNumberLiteral(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitNumberLiteral"):
                return visitor.visitNumberLiteral(self)
            else:
                return visitor.visitChildren(self)

    def numberLiteral(self):

        localctx = SolidityParser.NumberLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_numberLiteral)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 964
            _la = self._input.LA(1)
            if not (_la == 126 or _la == 128):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LBrace(self):
            return self.getToken(SolidityParser.LBrace, 0)

        def RBrace(self):
            return self.getToken(SolidityParser.RBrace, 0)

        def statement(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.StatementContext)
            else:
                return self.getTypedRuleContext(SolidityParser.StatementContext, i)

        def uncheckedBlock(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.UncheckedBlockContext)
            else:
                return self.getTypedRuleContext(SolidityParser.UncheckedBlockContext, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_block

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterBlock"):
                listener.enterBlock(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitBlock"):
                listener.exitBlock(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitBlock"):
                return visitor.visitBlock(self)
            else:
                return visitor.visitChildren(self)

    def block(self):

        localctx = SolidityParser.BlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_block)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 966
            self.match(SolidityParser.LBrace)
            self.state = 971
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 102, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 969
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input, 101, self._ctx)
                    if la_ == 1:
                        self.state = 967
                        self.statement()
                        pass

                    elif la_ == 2:
                        self.state = 968
                        self.uncheckedBlock()
                        pass

                self.state = 973
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 102, self._ctx)

            self.state = 974
            self.match(SolidityParser.RBrace)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class UncheckedBlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Unchecked(self):
            return self.getToken(SolidityParser.Unchecked, 0)

        def block(self):
            return self.getTypedRuleContext(SolidityParser.BlockContext, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_uncheckedBlock

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterUncheckedBlock"):
                listener.enterUncheckedBlock(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitUncheckedBlock"):
                listener.exitUncheckedBlock(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitUncheckedBlock"):
                return visitor.visitUncheckedBlock(self)
            else:
                return visitor.visitChildren(self)

    def uncheckedBlock(self):

        localctx = SolidityParser.UncheckedBlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_uncheckedBlock)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 976
            self.match(SolidityParser.Unchecked)
            self.state = 977
            self.block()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def block(self):
            return self.getTypedRuleContext(SolidityParser.BlockContext, 0)

        def simpleStatement(self):
            return self.getTypedRuleContext(SolidityParser.SimpleStatementContext, 0)

        def ifStatement(self):
            return self.getTypedRuleContext(SolidityParser.IfStatementContext, 0)

        def forStatement(self):
            return self.getTypedRuleContext(SolidityParser.ForStatementContext, 0)

        def whileStatement(self):
            return self.getTypedRuleContext(SolidityParser.WhileStatementContext, 0)

        def doWhileStatement(self):
            return self.getTypedRuleContext(SolidityParser.DoWhileStatementContext, 0)

        def continueStatement(self):
            return self.getTypedRuleContext(SolidityParser.ContinueStatementContext, 0)

        def breakStatement(self):
            return self.getTypedRuleContext(SolidityParser.BreakStatementContext, 0)

        def tryStatement(self):
            return self.getTypedRuleContext(SolidityParser.TryStatementContext, 0)

        def returnStatement(self):
            return self.getTypedRuleContext(SolidityParser.ReturnStatementContext, 0)

        def emitStatement(self):
            return self.getTypedRuleContext(SolidityParser.EmitStatementContext, 0)

        def revertStatement(self):
            return self.getTypedRuleContext(SolidityParser.RevertStatementContext, 0)

        def assemblyStatement(self):
            return self.getTypedRuleContext(SolidityParser.AssemblyStatementContext, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_statement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterStatement"):
                listener.enterStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitStatement"):
                listener.exitStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitStatement"):
                return visitor.visitStatement(self)
            else:
                return visitor.visitChildren(self)

    def statement(self):

        localctx = SolidityParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_statement)
        try:
            self.state = 992
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 103, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 979
                self.block()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 980
                self.simpleStatement()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 981
                self.ifStatement()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 982
                self.forStatement()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 983
                self.whileStatement()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 984
                self.doWhileStatement()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 985
                self.continueStatement()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 986
                self.breakStatement()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 987
                self.tryStatement()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 988
                self.returnStatement()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 989
                self.emitStatement()
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 990
                self.revertStatement()
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 991
                self.assemblyStatement()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SimpleStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variableDeclarationStatement(self):
            return self.getTypedRuleContext(SolidityParser.VariableDeclarationStatementContext, 0)

        def expressionStatement(self):
            return self.getTypedRuleContext(SolidityParser.ExpressionStatementContext, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_simpleStatement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterSimpleStatement"):
                listener.enterSimpleStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitSimpleStatement"):
                listener.exitSimpleStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitSimpleStatement"):
                return visitor.visitSimpleStatement(self)
            else:
                return visitor.visitChildren(self)

    def simpleStatement(self):

        localctx = SolidityParser.SimpleStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_simpleStatement)
        try:
            self.state = 996
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 104, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 994
                self.variableDeclarationStatement()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 995
                self.expressionStatement()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class IfStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def If(self):
            return self.getToken(SolidityParser.If, 0)

        def LParen(self):
            return self.getToken(SolidityParser.LParen, 0)

        def expression(self):
            return self.getTypedRuleContext(SolidityParser.ExpressionContext, 0)

        def RParen(self):
            return self.getToken(SolidityParser.RParen, 0)

        def statement(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.StatementContext)
            else:
                return self.getTypedRuleContext(SolidityParser.StatementContext, i)

        def Else(self):
            return self.getToken(SolidityParser.Else, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_ifStatement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterIfStatement"):
                listener.enterIfStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitIfStatement"):
                listener.exitIfStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitIfStatement"):
                return visitor.visitIfStatement(self)
            else:
                return visitor.visitChildren(self)

    def ifStatement(self):

        localctx = SolidityParser.IfStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_ifStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 998
            self.match(SolidityParser.If)
            self.state = 999
            self.match(SolidityParser.LParen)
            self.state = 1000
            self.expression(0)
            self.state = 1001
            self.match(SolidityParser.RParen)
            self.state = 1002
            self.statement()
            self.state = 1005
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 105, self._ctx)
            if la_ == 1:
                self.state = 1003
                self.match(SolidityParser.Else)
                self.state = 1004
                self.statement()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ForStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def For(self):
            return self.getToken(SolidityParser.For, 0)

        def LParen(self):
            return self.getToken(SolidityParser.LParen, 0)

        def RParen(self):
            return self.getToken(SolidityParser.RParen, 0)

        def statement(self):
            return self.getTypedRuleContext(SolidityParser.StatementContext, 0)

        def simpleStatement(self):
            return self.getTypedRuleContext(SolidityParser.SimpleStatementContext, 0)

        def Semicolon(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.Semicolon)
            else:
                return self.getToken(SolidityParser.Semicolon, i)

        def expressionStatement(self):
            return self.getTypedRuleContext(SolidityParser.ExpressionStatementContext, 0)

        def expression(self):
            return self.getTypedRuleContext(SolidityParser.ExpressionContext, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_forStatement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterForStatement"):
                listener.enterForStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitForStatement"):
                listener.exitForStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitForStatement"):
                return visitor.visitForStatement(self)
            else:
                return visitor.visitChildren(self)

    def forStatement(self):

        localctx = SolidityParser.ForStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_forStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1007
            self.match(SolidityParser.For)
            self.state = 1008
            self.match(SolidityParser.LParen)
            self.state = 1011
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 106, self._ctx)
            if la_ == 1:
                self.state = 1009
                self.simpleStatement()
                pass

            elif la_ == 2:
                self.state = 1010
                self.match(SolidityParser.Semicolon)
                pass

            self.state = 1015
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 107, self._ctx)
            if la_ == 1:
                self.state = 1013
                self.expressionStatement()
                pass

            elif la_ == 2:
                self.state = 1014
                self.match(SolidityParser.Semicolon)
                pass

            self.state = 1018
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 108, self._ctx)
            if la_ == 1:
                self.state = 1017
                self.expression(0)

            self.state = 1020
            self.match(SolidityParser.RParen)
            self.state = 1021
            self.statement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class WhileStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def While(self):
            return self.getToken(SolidityParser.While, 0)

        def LParen(self):
            return self.getToken(SolidityParser.LParen, 0)

        def expression(self):
            return self.getTypedRuleContext(SolidityParser.ExpressionContext, 0)

        def RParen(self):
            return self.getToken(SolidityParser.RParen, 0)

        def statement(self):
            return self.getTypedRuleContext(SolidityParser.StatementContext, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_whileStatement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterWhileStatement"):
                listener.enterWhileStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitWhileStatement"):
                listener.exitWhileStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitWhileStatement"):
                return visitor.visitWhileStatement(self)
            else:
                return visitor.visitChildren(self)

    def whileStatement(self):

        localctx = SolidityParser.WhileStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_whileStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1023
            self.match(SolidityParser.While)
            self.state = 1024
            self.match(SolidityParser.LParen)
            self.state = 1025
            self.expression(0)
            self.state = 1026
            self.match(SolidityParser.RParen)
            self.state = 1027
            self.statement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DoWhileStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Do(self):
            return self.getToken(SolidityParser.Do, 0)

        def statement(self):
            return self.getTypedRuleContext(SolidityParser.StatementContext, 0)

        def While(self):
            return self.getToken(SolidityParser.While, 0)

        def LParen(self):
            return self.getToken(SolidityParser.LParen, 0)

        def expression(self):
            return self.getTypedRuleContext(SolidityParser.ExpressionContext, 0)

        def RParen(self):
            return self.getToken(SolidityParser.RParen, 0)

        def Semicolon(self):
            return self.getToken(SolidityParser.Semicolon, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_doWhileStatement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterDoWhileStatement"):
                listener.enterDoWhileStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitDoWhileStatement"):
                listener.exitDoWhileStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitDoWhileStatement"):
                return visitor.visitDoWhileStatement(self)
            else:
                return visitor.visitChildren(self)

    def doWhileStatement(self):

        localctx = SolidityParser.DoWhileStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_doWhileStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1029
            self.match(SolidityParser.Do)
            self.state = 1030
            self.statement()
            self.state = 1031
            self.match(SolidityParser.While)
            self.state = 1032
            self.match(SolidityParser.LParen)
            self.state = 1033
            self.expression(0)
            self.state = 1034
            self.match(SolidityParser.RParen)
            self.state = 1035
            self.match(SolidityParser.Semicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ContinueStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Continue(self):
            return self.getToken(SolidityParser.Continue, 0)

        def Semicolon(self):
            return self.getToken(SolidityParser.Semicolon, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_continueStatement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterContinueStatement"):
                listener.enterContinueStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitContinueStatement"):
                listener.exitContinueStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitContinueStatement"):
                return visitor.visitContinueStatement(self)
            else:
                return visitor.visitChildren(self)

    def continueStatement(self):

        localctx = SolidityParser.ContinueStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_continueStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1037
            self.match(SolidityParser.Continue)
            self.state = 1038
            self.match(SolidityParser.Semicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BreakStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Break(self):
            return self.getToken(SolidityParser.Break, 0)

        def Semicolon(self):
            return self.getToken(SolidityParser.Semicolon, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_breakStatement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterBreakStatement"):
                listener.enterBreakStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitBreakStatement"):
                listener.exitBreakStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitBreakStatement"):
                return visitor.visitBreakStatement(self)
            else:
                return visitor.visitChildren(self)

    def breakStatement(self):

        localctx = SolidityParser.BreakStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_breakStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1040
            self.match(SolidityParser.Break)
            self.state = 1041
            self.match(SolidityParser.Semicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TryStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.returnParameters = None  # ParameterListContext

        def Try(self):
            return self.getToken(SolidityParser.Try, 0)

        def expression(self):
            return self.getTypedRuleContext(SolidityParser.ExpressionContext, 0)

        def block(self):
            return self.getTypedRuleContext(SolidityParser.BlockContext, 0)

        def Returns(self):
            return self.getToken(SolidityParser.Returns, 0)

        def LParen(self):
            return self.getToken(SolidityParser.LParen, 0)

        def RParen(self):
            return self.getToken(SolidityParser.RParen, 0)

        def catchClause(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.CatchClauseContext)
            else:
                return self.getTypedRuleContext(SolidityParser.CatchClauseContext, i)

        def parameterList(self):
            return self.getTypedRuleContext(SolidityParser.ParameterListContext, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_tryStatement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterTryStatement"):
                listener.enterTryStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitTryStatement"):
                listener.exitTryStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitTryStatement"):
                return visitor.visitTryStatement(self)
            else:
                return visitor.visitChildren(self)

    def tryStatement(self):

        localctx = SolidityParser.TryStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_tryStatement)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1043
            self.match(SolidityParser.Try)
            self.state = 1044
            self.expression(0)
            self.state = 1050
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 54:
                self.state = 1045
                self.match(SolidityParser.Returns)
                self.state = 1046
                self.match(SolidityParser.LParen)
                self.state = 1047
                localctx.returnParameters = self.parameterList()
                self.state = 1048
                self.match(SolidityParser.RParen)

            self.state = 1052
            self.block()
            self.state = 1054
            self._errHandler.sync(self)
            _alt = 1
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 1053
                    self.catchClause()

                else:
                    raise NoViableAltException(self)
                self.state = 1056
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 110, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CatchClauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.arguments = None  # ParameterListContext

        def Catch(self):
            return self.getToken(SolidityParser.Catch, 0)

        def block(self):
            return self.getTypedRuleContext(SolidityParser.BlockContext, 0)

        def LParen(self):
            return self.getToken(SolidityParser.LParen, 0)

        def RParen(self):
            return self.getToken(SolidityParser.RParen, 0)

        def identifier(self):
            return self.getTypedRuleContext(SolidityParser.IdentifierContext, 0)

        def parameterList(self):
            return self.getTypedRuleContext(SolidityParser.ParameterListContext, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_catchClause

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCatchClause"):
                listener.enterCatchClause(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCatchClause"):
                listener.exitCatchClause(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitCatchClause"):
                return visitor.visitCatchClause(self)
            else:
                return visitor.visitChildren(self)

    def catchClause(self):

        localctx = SolidityParser.CatchClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_catchClause)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1058
            self.match(SolidityParser.Catch)
            self.state = 1066
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 36028799705415680) != 0) or _la == 71 or _la == 130:
                self.state = 1060
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 36028799705415680) != 0) or _la == 130:
                    self.state = 1059
                    self.identifier()

                self.state = 1062
                self.match(SolidityParser.LParen)

                self.state = 1063
                localctx.arguments = self.parameterList()
                self.state = 1064
                self.match(SolidityParser.RParen)

            self.state = 1068
            self.block()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ReturnStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Return(self):
            return self.getToken(SolidityParser.Return, 0)

        def Semicolon(self):
            return self.getToken(SolidityParser.Semicolon, 0)

        def expression(self):
            return self.getTypedRuleContext(SolidityParser.ExpressionContext, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_returnStatement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterReturnStatement"):
                listener.enterReturnStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitReturnStatement"):
                listener.exitReturnStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitReturnStatement"):
                return visitor.visitReturnStatement(self)
            else:
                return visitor.visitChildren(self)

    def returnStatement(self):

        localctx = SolidityParser.ReturnStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_returnStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1070
            self.match(SolidityParser.Return)
            self.state = 1072
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 113, self._ctx)
            if la_ == 1:
                self.state = 1071
                self.expression(0)

            self.state = 1074
            self.match(SolidityParser.Semicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class EmitStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Emit(self):
            return self.getToken(SolidityParser.Emit, 0)

        def expression(self):
            return self.getTypedRuleContext(SolidityParser.ExpressionContext, 0)

        def callArgumentList(self):
            return self.getTypedRuleContext(SolidityParser.CallArgumentListContext, 0)

        def Semicolon(self):
            return self.getToken(SolidityParser.Semicolon, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_emitStatement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterEmitStatement"):
                listener.enterEmitStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitEmitStatement"):
                listener.exitEmitStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitEmitStatement"):
                return visitor.visitEmitStatement(self)
            else:
                return visitor.visitChildren(self)

    def emitStatement(self):

        localctx = SolidityParser.EmitStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_emitStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1076
            self.match(SolidityParser.Emit)
            self.state = 1077
            self.expression(0)
            self.state = 1078
            self.callArgumentList()
            self.state = 1079
            self.match(SolidityParser.Semicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RevertStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Revert(self):
            return self.getToken(SolidityParser.Revert, 0)

        def expression(self):
            return self.getTypedRuleContext(SolidityParser.ExpressionContext, 0)

        def callArgumentList(self):
            return self.getTypedRuleContext(SolidityParser.CallArgumentListContext, 0)

        def Semicolon(self):
            return self.getToken(SolidityParser.Semicolon, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_revertStatement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRevertStatement"):
                listener.enterRevertStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRevertStatement"):
                listener.exitRevertStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitRevertStatement"):
                return visitor.visitRevertStatement(self)
            else:
                return visitor.visitChildren(self)

    def revertStatement(self):

        localctx = SolidityParser.RevertStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_revertStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1081
            self.match(SolidityParser.Revert)
            self.state = 1082
            self.expression(0)
            self.state = 1083
            self.callArgumentList()
            self.state = 1084
            self.match(SolidityParser.Semicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AssemblyStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Assembly(self):
            return self.getToken(SolidityParser.Assembly, 0)

        def AssemblyLBrace(self):
            return self.getToken(SolidityParser.AssemblyLBrace, 0)

        def YulRBrace(self):
            return self.getToken(SolidityParser.YulRBrace, 0)

        def AssemblyDialect(self):
            return self.getToken(SolidityParser.AssemblyDialect, 0)

        def assemblyFlags(self):
            return self.getTypedRuleContext(SolidityParser.AssemblyFlagsContext, 0)

        def yulStatement(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.YulStatementContext)
            else:
                return self.getTypedRuleContext(SolidityParser.YulStatementContext, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_assemblyStatement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAssemblyStatement"):
                listener.enterAssemblyStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAssemblyStatement"):
                listener.exitAssemblyStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAssemblyStatement"):
                return visitor.visitAssemblyStatement(self)
            else:
                return visitor.visitChildren(self)

    def assemblyStatement(self):

        localctx = SolidityParser.AssemblyStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 142, self.RULE_assemblyStatement)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1086
            self.match(SolidityParser.Assembly)
            self.state = 1088
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 134:
                self.state = 1087
                self.match(SolidityParser.AssemblyDialect)

            self.state = 1091
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 137:
                self.state = 1090
                self.assemblyFlags()

            self.state = 1093
            self.match(SolidityParser.AssemblyLBrace)
            self.state = 1097
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 143)) & ~0x3f) == 0 and ((1 << (_la - 143)) & 4220901) != 0):
                self.state = 1094
                self.yulStatement()
                self.state = 1099
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1100
            self.match(SolidityParser.YulRBrace)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AssemblyFlagsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AssemblyBlockLParen(self):
            return self.getToken(SolidityParser.AssemblyBlockLParen, 0)

        def AssemblyFlagString(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.AssemblyFlagString)
            else:
                return self.getToken(SolidityParser.AssemblyFlagString, i)

        def AssemblyBlockRParen(self):
            return self.getToken(SolidityParser.AssemblyBlockRParen, 0)

        def AssemblyBlockComma(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.AssemblyBlockComma)
            else:
                return self.getToken(SolidityParser.AssemblyBlockComma, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_assemblyFlags

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAssemblyFlags"):
                listener.enterAssemblyFlags(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAssemblyFlags"):
                listener.exitAssemblyFlags(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAssemblyFlags"):
                return visitor.visitAssemblyFlags(self)
            else:
                return visitor.visitChildren(self)

    def assemblyFlags(self):

        localctx = SolidityParser.AssemblyFlagsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 144, self.RULE_assemblyFlags)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1102
            self.match(SolidityParser.AssemblyBlockLParen)
            self.state = 1103
            self.match(SolidityParser.AssemblyFlagString)
            self.state = 1108
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 139:
                self.state = 1104
                self.match(SolidityParser.AssemblyBlockComma)
                self.state = 1105
                self.match(SolidityParser.AssemblyFlagString)
                self.state = 1110
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1111
            self.match(SolidityParser.AssemblyBlockRParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class VariableDeclarationListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._variableDeclaration = None  # VariableDeclarationContext
            self.variableDeclarations = list()  # of VariableDeclarationContexts

        def variableDeclaration(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.VariableDeclarationContext)
            else:
                return self.getTypedRuleContext(SolidityParser.VariableDeclarationContext, i)

        def Comma(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.Comma)
            else:
                return self.getToken(SolidityParser.Comma, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_variableDeclarationList

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterVariableDeclarationList"):
                listener.enterVariableDeclarationList(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitVariableDeclarationList"):
                listener.exitVariableDeclarationList(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitVariableDeclarationList"):
                return visitor.visitVariableDeclarationList(self)
            else:
                return visitor.visitChildren(self)

    def variableDeclarationList(self):

        localctx = SolidityParser.VariableDeclarationListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 146, self.RULE_variableDeclarationList)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1113
            localctx._variableDeclaration = self.variableDeclaration()
            localctx.variableDeclarations.append(localctx._variableDeclaration)
            self.state = 1118
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 95:
                self.state = 1114
                self.match(SolidityParser.Comma)
                self.state = 1115
                localctx._variableDeclaration = self.variableDeclaration()
                localctx.variableDeclarations.append(localctx._variableDeclaration)
                self.state = 1120
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class VariableDeclarationTupleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._variableDeclaration = None  # VariableDeclarationContext
            self.variableDeclarations = list()  # of VariableDeclarationContexts

        def LParen(self):
            return self.getToken(SolidityParser.LParen, 0)

        def RParen(self):
            return self.getToken(SolidityParser.RParen, 0)

        def variableDeclaration(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.VariableDeclarationContext)
            else:
                return self.getTypedRuleContext(SolidityParser.VariableDeclarationContext, i)

        def Comma(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.Comma)
            else:
                return self.getToken(SolidityParser.Comma, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_variableDeclarationTuple

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterVariableDeclarationTuple"):
                listener.enterVariableDeclarationTuple(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitVariableDeclarationTuple"):
                listener.exitVariableDeclarationTuple(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitVariableDeclarationTuple"):
                return visitor.visitVariableDeclarationTuple(self)
            else:
                return visitor.visitChildren(self)

    def variableDeclarationTuple(self):

        localctx = SolidityParser.VariableDeclarationTupleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 148, self.RULE_variableDeclarationTuple)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1121
            self.match(SolidityParser.LParen)

            self.state = 1125
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 119, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 1122
                    self.match(SolidityParser.Comma)
                self.state = 1127
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 119, self._ctx)

            self.state = 1128
            localctx._variableDeclaration = self.variableDeclaration()
            localctx.variableDeclarations.append(localctx._variableDeclaration)
            self.state = 1136
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 95:
                self.state = 1130
                self.match(SolidityParser.Comma)
                self.state = 1132
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 120, self._ctx)
                if la_ == 1:
                    self.state = 1131
                    localctx._variableDeclaration = self.variableDeclaration()
                    localctx.variableDeclarations.append(localctx._variableDeclaration)

                self.state = 1138
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1139
            self.match(SolidityParser.RParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class VariableDeclarationStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Semicolon(self):
            return self.getToken(SolidityParser.Semicolon, 0)

        def variableDeclaration(self):
            return self.getTypedRuleContext(SolidityParser.VariableDeclarationContext, 0)

        def variableDeclarationTuple(self):
            return self.getTypedRuleContext(SolidityParser.VariableDeclarationTupleContext, 0)

        def Assign(self):
            return self.getToken(SolidityParser.Assign, 0)

        def expression(self):
            return self.getTypedRuleContext(SolidityParser.ExpressionContext, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_variableDeclarationStatement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterVariableDeclarationStatement"):
                listener.enterVariableDeclarationStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitVariableDeclarationStatement"):
                listener.exitVariableDeclarationStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitVariableDeclarationStatement"):
                return visitor.visitVariableDeclarationStatement(self)
            else:
                return visitor.visitChildren(self)

    def variableDeclarationStatement(self):

        localctx = SolidityParser.VariableDeclarationStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 150, self.RULE_variableDeclarationStatement)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1150
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 123, self._ctx)
            if la_ == 1:
                self.state = 1141
                self.variableDeclaration()
                self.state = 1144
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == 83:
                    self.state = 1142
                    self.match(SolidityParser.Assign)
                    self.state = 1143
                    self.expression(0)

                pass

            elif la_ == 2:
                self.state = 1146
                self.variableDeclarationTuple()
                self.state = 1147
                self.match(SolidityParser.Assign)
                self.state = 1148
                self.expression(0)
                pass

            self.state = 1152
            self.match(SolidityParser.Semicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExpressionStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expression(self):
            return self.getTypedRuleContext(SolidityParser.ExpressionContext, 0)

        def Semicolon(self):
            return self.getToken(SolidityParser.Semicolon, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_expressionStatement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExpressionStatement"):
                listener.enterExpressionStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExpressionStatement"):
                listener.exitExpressionStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExpressionStatement"):
                return visitor.visitExpressionStatement(self)
            else:
                return visitor.visitChildren(self)

    def expressionStatement(self):

        localctx = SolidityParser.ExpressionStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 152, self.RULE_expressionStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1154
            self.expression(0)
            self.state = 1155
            self.match(SolidityParser.Semicolon)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class MappingTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.key = None  # MappingKeyTypeContext
            self.name = None  # IdentifierContext
            self.value = None  # TypeNameContext

        def Mapping(self):
            return self.getToken(SolidityParser.Mapping, 0)

        def LParen(self):
            return self.getToken(SolidityParser.LParen, 0)

        def DoubleArrow(self):
            return self.getToken(SolidityParser.DoubleArrow, 0)

        def RParen(self):
            return self.getToken(SolidityParser.RParen, 0)

        def mappingKeyType(self):
            return self.getTypedRuleContext(SolidityParser.MappingKeyTypeContext, 0)

        def typeName(self):
            return self.getTypedRuleContext(SolidityParser.TypeNameContext, 0)

        def identifier(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(SolidityParser.IdentifierContext, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_mappingType

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterMappingType"):
                listener.enterMappingType(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitMappingType"):
                listener.exitMappingType(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitMappingType"):
                return visitor.visitMappingType(self)
            else:
                return visitor.visitChildren(self)

    def mappingType(self):

        localctx = SolidityParser.MappingTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 154, self.RULE_mappingType)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1157
            self.match(SolidityParser.Mapping)
            self.state = 1158
            self.match(SolidityParser.LParen)
            self.state = 1159
            localctx.key = self.mappingKeyType()
            self.state = 1161
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 36028799705415680) != 0) or _la == 130:
                self.state = 1160
                localctx.name = self.identifier()

            self.state = 1163
            self.match(SolidityParser.DoubleArrow)
            self.state = 1164
            localctx.value = self.typeName(0)
            self.state = 1166
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & 36028799705415680) != 0) or _la == 130:
                self.state = 1165
                localctx.name = self.identifier()

            self.state = 1168
            self.match(SolidityParser.RParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class MappingKeyTypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def elementaryTypeName(self):
            return self.getTypedRuleContext(SolidityParser.ElementaryTypeNameContext, 0)

        def identifierPath(self):
            return self.getTypedRuleContext(SolidityParser.IdentifierPathContext, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_mappingKeyType

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterMappingKeyType"):
                listener.enterMappingKeyType(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitMappingKeyType"):
                listener.exitMappingKeyType(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitMappingKeyType"):
                return visitor.visitMappingKeyType(self)
            else:
                return visitor.visitChildren(self)

    def mappingKeyType(self):

        localctx = SolidityParser.MappingKeyTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 156, self.RULE_mappingKeyType)
        try:
            self.state = 1172
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 126, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1170
                self.elementaryTypeName(SolidityParser.FALSE)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1171
                self.identifierPath()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class YulStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def yulBlock(self):
            return self.getTypedRuleContext(SolidityParser.YulBlockContext, 0)

        def yulVariableDeclaration(self):
            return self.getTypedRuleContext(SolidityParser.YulVariableDeclarationContext, 0)

        def yulAssignment(self):
            return self.getTypedRuleContext(SolidityParser.YulAssignmentContext, 0)

        def yulFunctionCall(self):
            return self.getTypedRuleContext(SolidityParser.YulFunctionCallContext, 0)

        def yulIfStatement(self):
            return self.getTypedRuleContext(SolidityParser.YulIfStatementContext, 0)

        def yulForStatement(self):
            return self.getTypedRuleContext(SolidityParser.YulForStatementContext, 0)

        def yulSwitchStatement(self):
            return self.getTypedRuleContext(SolidityParser.YulSwitchStatementContext, 0)

        def YulLeave(self):
            return self.getToken(SolidityParser.YulLeave, 0)

        def YulBreak(self):
            return self.getToken(SolidityParser.YulBreak, 0)

        def YulContinue(self):
            return self.getToken(SolidityParser.YulContinue, 0)

        def yulFunctionDefinition(self):
            return self.getTypedRuleContext(SolidityParser.YulFunctionDefinitionContext, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_yulStatement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterYulStatement"):
                listener.enterYulStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitYulStatement"):
                listener.exitYulStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitYulStatement"):
                return visitor.visitYulStatement(self)
            else:
                return visitor.visitChildren(self)

    def yulStatement(self):

        localctx = SolidityParser.YulStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 158, self.RULE_yulStatement)
        try:
            self.state = 1185
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 127, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1174
                self.yulBlock()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1175
                self.yulVariableDeclaration()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1176
                self.yulAssignment()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1177
                self.yulFunctionCall()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1178
                self.yulIfStatement()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 1179
                self.yulForStatement()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 1180
                self.yulSwitchStatement()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 1181
                self.match(SolidityParser.YulLeave)
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 1182
                self.match(SolidityParser.YulBreak)
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 1183
                self.match(SolidityParser.YulContinue)
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 1184
                self.yulFunctionDefinition()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class YulBlockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def YulLBrace(self):
            return self.getToken(SolidityParser.YulLBrace, 0)

        def YulRBrace(self):
            return self.getToken(SolidityParser.YulRBrace, 0)

        def yulStatement(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.YulStatementContext)
            else:
                return self.getTypedRuleContext(SolidityParser.YulStatementContext, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_yulBlock

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterYulBlock"):
                listener.enterYulBlock(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitYulBlock"):
                listener.exitYulBlock(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitYulBlock"):
                return visitor.visitYulBlock(self)
            else:
                return visitor.visitChildren(self)

    def yulBlock(self):

        localctx = SolidityParser.YulBlockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 160, self.RULE_yulBlock)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1187
            self.match(SolidityParser.YulLBrace)
            self.state = 1191
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 143)) & ~0x3f) == 0 and ((1 << (_la - 143)) & 4220901) != 0):
                self.state = 1188
                self.yulStatement()
                self.state = 1193
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1194
            self.match(SolidityParser.YulRBrace)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class YulVariableDeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._YulIdentifier = None  # Token
            self.variables = list()  # of Tokens

        def YulLet(self):
            return self.getToken(SolidityParser.YulLet, 0)

        def YulIdentifier(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.YulIdentifier)
            else:
                return self.getToken(SolidityParser.YulIdentifier, i)

        def YulAssign(self):
            return self.getToken(SolidityParser.YulAssign, 0)

        def yulExpression(self):
            return self.getTypedRuleContext(SolidityParser.YulExpressionContext, 0)

        def YulComma(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.YulComma)
            else:
                return self.getToken(SolidityParser.YulComma, i)

        def yulFunctionCall(self):
            return self.getTypedRuleContext(SolidityParser.YulFunctionCallContext, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_yulVariableDeclaration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterYulVariableDeclaration"):
                listener.enterYulVariableDeclaration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitYulVariableDeclaration"):
                listener.exitYulVariableDeclaration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitYulVariableDeclaration"):
                return visitor.visitYulVariableDeclaration(self)
            else:
                return visitor.visitChildren(self)

    def yulVariableDeclaration(self):

        localctx = SolidityParser.YulVariableDeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 162, self.RULE_yulVariableDeclaration)
        self._la = 0  # Token type
        try:
            self.state = 1215
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 132, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1196
                self.match(SolidityParser.YulLet)
                self.state = 1197
                localctx._YulIdentifier = self.match(SolidityParser.YulIdentifier)
                localctx.variables.append(localctx._YulIdentifier)
                self.state = 1200
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == 161:
                    self.state = 1198
                    self.match(SolidityParser.YulAssign)
                    self.state = 1199
                    self.yulExpression()

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1202
                self.match(SolidityParser.YulLet)
                self.state = 1203
                localctx._YulIdentifier = self.match(SolidityParser.YulIdentifier)
                localctx.variables.append(localctx._YulIdentifier)
                self.state = 1208
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == 163:
                    self.state = 1204
                    self.match(SolidityParser.YulComma)
                    self.state = 1205
                    localctx._YulIdentifier = self.match(SolidityParser.YulIdentifier)
                    localctx.variables.append(localctx._YulIdentifier)
                    self.state = 1210
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1213
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == 161:
                    self.state = 1211
                    self.match(SolidityParser.YulAssign)
                    self.state = 1212
                    self.yulFunctionCall()

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class YulAssignmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def yulPath(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.YulPathContext)
            else:
                return self.getTypedRuleContext(SolidityParser.YulPathContext, i)

        def YulAssign(self):
            return self.getToken(SolidityParser.YulAssign, 0)

        def yulExpression(self):
            return self.getTypedRuleContext(SolidityParser.YulExpressionContext, 0)

        def yulFunctionCall(self):
            return self.getTypedRuleContext(SolidityParser.YulFunctionCallContext, 0)

        def YulComma(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.YulComma)
            else:
                return self.getToken(SolidityParser.YulComma, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_yulAssignment

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterYulAssignment"):
                listener.enterYulAssignment(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitYulAssignment"):
                listener.exitYulAssignment(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitYulAssignment"):
                return visitor.visitYulAssignment(self)
            else:
                return visitor.visitChildren(self)

    def yulAssignment(self):

        localctx = SolidityParser.YulAssignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 164, self.RULE_yulAssignment)
        self._la = 0  # Token type
        try:
            self.state = 1231
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 134, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1217
                self.yulPath()
                self.state = 1218
                self.match(SolidityParser.YulAssign)
                self.state = 1219
                self.yulExpression()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1221
                self.yulPath()
                self.state = 1224
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 1222
                    self.match(SolidityParser.YulComma)
                    self.state = 1223
                    self.yulPath()
                    self.state = 1226
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la == 163):
                        break

                self.state = 1228
                self.match(SolidityParser.YulAssign)
                self.state = 1229
                self.yulFunctionCall()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class YulIfStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.cond = None  # YulExpressionContext
            self.body = None  # YulBlockContext

        def YulIf(self):
            return self.getToken(SolidityParser.YulIf, 0)

        def yulExpression(self):
            return self.getTypedRuleContext(SolidityParser.YulExpressionContext, 0)

        def yulBlock(self):
            return self.getTypedRuleContext(SolidityParser.YulBlockContext, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_yulIfStatement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterYulIfStatement"):
                listener.enterYulIfStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitYulIfStatement"):
                listener.exitYulIfStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitYulIfStatement"):
                return visitor.visitYulIfStatement(self)
            else:
                return visitor.visitChildren(self)

    def yulIfStatement(self):

        localctx = SolidityParser.YulIfStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 166, self.RULE_yulIfStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1233
            self.match(SolidityParser.YulIf)
            self.state = 1234
            localctx.cond = self.yulExpression()
            self.state = 1235
            localctx.body = self.yulBlock()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class YulForStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.init = None  # YulBlockContext
            self.cond = None  # YulExpressionContext
            self.post = None  # YulBlockContext
            self.body = None  # YulBlockContext

        def YulFor(self):
            return self.getToken(SolidityParser.YulFor, 0)

        def yulBlock(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.YulBlockContext)
            else:
                return self.getTypedRuleContext(SolidityParser.YulBlockContext, i)

        def yulExpression(self):
            return self.getTypedRuleContext(SolidityParser.YulExpressionContext, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_yulForStatement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterYulForStatement"):
                listener.enterYulForStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitYulForStatement"):
                listener.exitYulForStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitYulForStatement"):
                return visitor.visitYulForStatement(self)
            else:
                return visitor.visitChildren(self)

    def yulForStatement(self):

        localctx = SolidityParser.YulForStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 168, self.RULE_yulForStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1237
            self.match(SolidityParser.YulFor)
            self.state = 1238
            localctx.init = self.yulBlock()
            self.state = 1239
            localctx.cond = self.yulExpression()
            self.state = 1240
            localctx.post = self.yulBlock()
            self.state = 1241
            localctx.body = self.yulBlock()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class YulSwitchCaseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def YulCase(self):
            return self.getToken(SolidityParser.YulCase, 0)

        def yulLiteral(self):
            return self.getTypedRuleContext(SolidityParser.YulLiteralContext, 0)

        def yulBlock(self):
            return self.getTypedRuleContext(SolidityParser.YulBlockContext, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_yulSwitchCase

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterYulSwitchCase"):
                listener.enterYulSwitchCase(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitYulSwitchCase"):
                listener.exitYulSwitchCase(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitYulSwitchCase"):
                return visitor.visitYulSwitchCase(self)
            else:
                return visitor.visitChildren(self)

    def yulSwitchCase(self):

        localctx = SolidityParser.YulSwitchCaseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 170, self.RULE_yulSwitchCase)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1243
            self.match(SolidityParser.YulCase)
            self.state = 1244
            self.yulLiteral()
            self.state = 1245
            self.yulBlock()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class YulSwitchStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def YulSwitch(self):
            return self.getToken(SolidityParser.YulSwitch, 0)

        def yulExpression(self):
            return self.getTypedRuleContext(SolidityParser.YulExpressionContext, 0)

        def YulDefault(self):
            return self.getToken(SolidityParser.YulDefault, 0)

        def yulBlock(self):
            return self.getTypedRuleContext(SolidityParser.YulBlockContext, 0)

        def yulSwitchCase(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.YulSwitchCaseContext)
            else:
                return self.getTypedRuleContext(SolidityParser.YulSwitchCaseContext, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_yulSwitchStatement

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterYulSwitchStatement"):
                listener.enterYulSwitchStatement(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitYulSwitchStatement"):
                listener.exitYulSwitchStatement(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitYulSwitchStatement"):
                return visitor.visitYulSwitchStatement(self)
            else:
                return visitor.visitChildren(self)

    def yulSwitchStatement(self):

        localctx = SolidityParser.YulSwitchStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 172, self.RULE_yulSwitchStatement)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1247
            self.match(SolidityParser.YulSwitch)
            self.state = 1248
            self.yulExpression()
            self.state = 1260
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [144]:
                self.state = 1250
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 1249
                    self.yulSwitchCase()
                    self.state = 1252
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la == 144):
                        break

                self.state = 1256
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == 146:
                    self.state = 1254
                    self.match(SolidityParser.YulDefault)
                    self.state = 1255
                    self.yulBlock()

                pass
            elif token in [146]:
                self.state = 1258
                self.match(SolidityParser.YulDefault)
                self.state = 1259
                self.yulBlock()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class YulFunctionDefinitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._YulIdentifier = None  # Token
            self.arguments = list()  # of Tokens
            self.returnParameters = list()  # of Tokens
            self.body = None  # YulBlockContext

        def YulFunction(self):
            return self.getToken(SolidityParser.YulFunction, 0)

        def YulIdentifier(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.YulIdentifier)
            else:
                return self.getToken(SolidityParser.YulIdentifier, i)

        def YulLParen(self):
            return self.getToken(SolidityParser.YulLParen, 0)

        def YulRParen(self):
            return self.getToken(SolidityParser.YulRParen, 0)

        def yulBlock(self):
            return self.getTypedRuleContext(SolidityParser.YulBlockContext, 0)

        def YulArrow(self):
            return self.getToken(SolidityParser.YulArrow, 0)

        def YulComma(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.YulComma)
            else:
                return self.getToken(SolidityParser.YulComma, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_yulFunctionDefinition

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterYulFunctionDefinition"):
                listener.enterYulFunctionDefinition(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitYulFunctionDefinition"):
                listener.exitYulFunctionDefinition(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitYulFunctionDefinition"):
                return visitor.visitYulFunctionDefinition(self)
            else:
                return visitor.visitChildren(self)

    def yulFunctionDefinition(self):

        localctx = SolidityParser.YulFunctionDefinitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 174, self.RULE_yulFunctionDefinition)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1262
            self.match(SolidityParser.YulFunction)
            self.state = 1263
            self.match(SolidityParser.YulIdentifier)
            self.state = 1264
            self.match(SolidityParser.YulLParen)
            self.state = 1273
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 165:
                self.state = 1265
                localctx._YulIdentifier = self.match(SolidityParser.YulIdentifier)
                localctx.arguments.append(localctx._YulIdentifier)
                self.state = 1270
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == 163:
                    self.state = 1266
                    self.match(SolidityParser.YulComma)
                    self.state = 1267
                    localctx._YulIdentifier = self.match(SolidityParser.YulIdentifier)
                    localctx.arguments.append(localctx._YulIdentifier)
                    self.state = 1272
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

            self.state = 1275
            self.match(SolidityParser.YulRParen)
            self.state = 1285
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == 164:
                self.state = 1276
                self.match(SolidityParser.YulArrow)
                self.state = 1277
                localctx._YulIdentifier = self.match(SolidityParser.YulIdentifier)
                localctx.returnParameters.append(localctx._YulIdentifier)
                self.state = 1282
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == 163:
                    self.state = 1278
                    self.match(SolidityParser.YulComma)
                    self.state = 1279
                    localctx._YulIdentifier = self.match(SolidityParser.YulIdentifier)
                    localctx.returnParameters.append(localctx._YulIdentifier)
                    self.state = 1284
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

            self.state = 1287
            localctx.body = self.yulBlock()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class YulPathContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def YulIdentifier(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.YulIdentifier)
            else:
                return self.getToken(SolidityParser.YulIdentifier, i)

        def YulPeriod(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.YulPeriod)
            else:
                return self.getToken(SolidityParser.YulPeriod, i)

        def YulEVMBuiltin(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.YulEVMBuiltin)
            else:
                return self.getToken(SolidityParser.YulEVMBuiltin, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_yulPath

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterYulPath"):
                listener.enterYulPath(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitYulPath"):
                listener.exitYulPath(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitYulPath"):
                return visitor.visitYulPath(self)
            else:
                return visitor.visitChildren(self)

    def yulPath(self):

        localctx = SolidityParser.YulPathContext(self, self._ctx, self.state)
        self.enterRule(localctx, 176, self.RULE_yulPath)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1289
            self.match(SolidityParser.YulIdentifier)
            self.state = 1294
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == 162:
                self.state = 1290
                self.match(SolidityParser.YulPeriod)
                self.state = 1291
                _la = self._input.LA(1)
                if not (_la == 156 or _la == 165):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1296
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class YulFunctionCallContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def YulLParen(self):
            return self.getToken(SolidityParser.YulLParen, 0)

        def YulRParen(self):
            return self.getToken(SolidityParser.YulRParen, 0)

        def YulIdentifier(self):
            return self.getToken(SolidityParser.YulIdentifier, 0)

        def YulEVMBuiltin(self):
            return self.getToken(SolidityParser.YulEVMBuiltin, 0)

        def yulExpression(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(SolidityParser.YulExpressionContext)
            else:
                return self.getTypedRuleContext(SolidityParser.YulExpressionContext, i)

        def YulComma(self, i: int = None):
            if i is None:
                return self.getTokens(SolidityParser.YulComma)
            else:
                return self.getToken(SolidityParser.YulComma, i)

        def getRuleIndex(self):
            return SolidityParser.RULE_yulFunctionCall

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterYulFunctionCall"):
                listener.enterYulFunctionCall(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitYulFunctionCall"):
                listener.exitYulFunctionCall(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitYulFunctionCall"):
                return visitor.visitYulFunctionCall(self)
            else:
                return visitor.visitChildren(self)

    def yulFunctionCall(self):

        localctx = SolidityParser.YulFunctionCallContext(self, self._ctx, self.state)
        self.enterRule(localctx, 178, self.RULE_yulFunctionCall)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1297
            _la = self._input.LA(1)
            if not (_la == 156 or _la == 165):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1298
            self.match(SolidityParser.YulLParen)
            self.state = 1307
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 147)) & ~0x3f) == 0 and ((1 << (_la - 147)) & 8127105) != 0):
                self.state = 1299
                self.yulExpression()
                self.state = 1304
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la == 163:
                    self.state = 1300
                    self.match(SolidityParser.YulComma)
                    self.state = 1301
                    self.yulExpression()
                    self.state = 1306
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

            self.state = 1309
            self.match(SolidityParser.YulRParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class YulboolContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def YulTrue(self):
            return self.getToken(SolidityParser.YulTrue, 0)

        def YulFalse(self):
            return self.getToken(SolidityParser.YulFalse, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_yulbool

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterYulbool"):
                listener.enterYulbool(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitYulbool"):
                listener.exitYulbool(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitYulbool"):
                return visitor.visitYulbool(self)
            else:
                return visitor.visitChildren(self)

    def yulbool(self):

        localctx = SolidityParser.YulboolContext(self, self._ctx, self.state)
        self.enterRule(localctx, 180, self.RULE_yulbool)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1311
            _la = self._input.LA(1)
            if not (_la == 147 or _la == 154):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class YulLiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def YulDecimalNumber(self):
            return self.getToken(SolidityParser.YulDecimalNumber, 0)

        def YulStringLiteral(self):
            return self.getToken(SolidityParser.YulStringLiteral, 0)

        def YulHexNumber(self):
            return self.getToken(SolidityParser.YulHexNumber, 0)

        def yulbool(self):
            return self.getTypedRuleContext(SolidityParser.YulboolContext, 0)

        def YulHexStringLiteral(self):
            return self.getToken(SolidityParser.YulHexStringLiteral, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_yulLiteral

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterYulLiteral"):
                listener.enterYulLiteral(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitYulLiteral"):
                listener.exitYulLiteral(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitYulLiteral"):
                return visitor.visitYulLiteral(self)
            else:
                return visitor.visitChildren(self)

    def yulLiteral(self):

        localctx = SolidityParser.YulLiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 182, self.RULE_yulLiteral)
        try:
            self.state = 1318
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [167]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1313
                self.match(SolidityParser.YulDecimalNumber)
                pass
            elif token in [168]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1314
                self.match(SolidityParser.YulStringLiteral)
                pass
            elif token in [166]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1315
                self.match(SolidityParser.YulHexNumber)
                pass
            elif token in [147, 154]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1316
                self.yulbool()
                pass
            elif token in [169]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1317
                self.match(SolidityParser.YulHexStringLiteral)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class YulExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent: ParserRuleContext = None, invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def yulPath(self):
            return self.getTypedRuleContext(SolidityParser.YulPathContext, 0)

        def yulFunctionCall(self):
            return self.getTypedRuleContext(SolidityParser.YulFunctionCallContext, 0)

        def yulLiteral(self):
            return self.getTypedRuleContext(SolidityParser.YulLiteralContext, 0)

        def getRuleIndex(self):
            return SolidityParser.RULE_yulExpression

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterYulExpression"):
                listener.enterYulExpression(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitYulExpression"):
                listener.exitYulExpression(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitYulExpression"):
                return visitor.visitYulExpression(self)
            else:
                return visitor.visitChildren(self)

    def yulExpression(self):

        localctx = SolidityParser.YulExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 184, self.RULE_yulExpression)
        try:
            self.state = 1323
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 146, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1320
                self.yulPath()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1321
                self.yulFunctionCall()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1322
                self.yulLiteral()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    def sempred(self, localctx: RuleContext, ruleIndex: int, predIndex: int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[19] = self.constructorDefinition_sempred
        self._predicates[22] = self.contractFunctionDefinition_sempred
        self._predicates[24] = self.modifierDefinition_sempred
        self._predicates[25] = self.fallbackFunctionDefinition_sempred
        self._predicates[26] = self.receiveFunctionDefinition_sempred
        self._predicates[31] = self.stateVariableDeclaration_sempred
        self._predicates[39] = self.typeName_sempred
        self._predicates[40] = self.elementaryTypeName_sempred
        self._predicates[41] = self.functionTypeName_sempred
        self._predicates[44] = self.expression_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def constructorDefinition_sempred(self, localctx: ConstructorDefinitionContext, predIndex: int):
        if predIndex == 0:
            return localctx.payableSet

        if predIndex == 1:
            return localctx.visibilitySet

        if predIndex == 2:
            return localctx.visibilitySet

    def contractFunctionDefinition_sempred(self, localctx: ContractFunctionDefinitionContext, predIndex: int):
        if predIndex == 3:
            return localctx.visibilitySet

        if predIndex == 4:
            return localctx.mutabilitySet

        if predIndex == 5:
            return localctx.virtualSet

        if predIndex == 6:
            return localctx.overrideSpecifierSet

    def modifierDefinition_sempred(self, localctx: ModifierDefinitionContext, predIndex: int):
        if predIndex == 7:
            return localctx.virtualSet

        if predIndex == 8:
            return localctx.overrideSpecifierSet

    def fallbackFunctionDefinition_sempred(self, localctx: FallbackFunctionDefinitionContext, predIndex: int):
        if predIndex == 9:
            return localctx.visibilitySet

        if predIndex == 10:
            return localctx.mutabilitySet

        if predIndex == 11:
            return localctx.virtualSet

        if predIndex == 12:
            return localctx.overrideSpecifierSet

        if predIndex == 13:
            return localctx.hasParameters

        if predIndex == 14:
            return localctx.hasParameters

    def receiveFunctionDefinition_sempred(self, localctx: ReceiveFunctionDefinitionContext, predIndex: int):
        if predIndex == 15:
            return localctx.visibilitySet

        if predIndex == 16:
            return localctx.mutabilitySet

        if predIndex == 17:
            return localctx.virtualSet

        if predIndex == 18:
            return localctx.overrideSpecifierSet

    def stateVariableDeclaration_sempred(self, localctx: StateVariableDeclarationContext, predIndex: int):
        if predIndex == 19:
            return localctx.visibilitySet

        if predIndex == 20:
            return localctx.visibilitySet

        if predIndex == 21:
            return localctx.visibilitySet

        if predIndex == 22:
            return localctx.constantnessSet

        if predIndex == 23:
            return localctx.overrideSpecifierSet

        if predIndex == 24:
            return localctx.constantnessSet

    def typeName_sempred(self, localctx: TypeNameContext, predIndex: int):
        if predIndex == 25:
            return self.precpred(self._ctx, 1)

    def elementaryTypeName_sempred(self, localctx: ElementaryTypeNameContext, predIndex: int):
        if predIndex == 26:
            return localctx.allowAddressPayable

    def functionTypeName_sempred(self, localctx: FunctionTypeNameContext, predIndex: int):
        if predIndex == 27:
            return localctx.visibilitySet

        if predIndex == 28:
            return localctx.mutabilitySet

    def expression_sempred(self, localctx: ExpressionContext, predIndex: int):
        if predIndex == 29:
            return self.precpred(self._ctx, 17)

        if predIndex == 30:
            return self.precpred(self._ctx, 16)

        if predIndex == 31:
            return self.precpred(self._ctx, 15)

        if predIndex == 32:
            return self.precpred(self._ctx, 14)

        if predIndex == 33:
            return self.precpred(self._ctx, 13)

        if predIndex == 34:
            return self.precpred(self._ctx, 12)

        if predIndex == 35:
            return self.precpred(self._ctx, 11)

        if predIndex == 36:
            return self.precpred(self._ctx, 10)

        if predIndex == 37:
            return self.precpred(self._ctx, 9)

        if predIndex == 38:
            return self.precpred(self._ctx, 8)

        if predIndex == 39:
            return self.precpred(self._ctx, 7)

        if predIndex == 40:
            return self.precpred(self._ctx, 6)

        if predIndex == 41:
            return self.precpred(self._ctx, 5)

        if predIndex == 42:
            return self.precpred(self._ctx, 26)

        if predIndex == 43:
            return self.precpred(self._ctx, 25)

        if predIndex == 44:
            return self.precpred(self._ctx, 24)

        if predIndex == 45:
            return self.precpred(self._ctx, 23)

        if predIndex == 46:
            return self.precpred(self._ctx, 22)

        if predIndex == 47:
            return self.precpred(self._ctx, 18)





