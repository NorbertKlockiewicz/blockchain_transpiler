# Generated from Vyper.g4 by ANTLR 4.12.0
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,78,984,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
        6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,
        2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,
        7,20,2,21,7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,
        2,27,7,27,2,28,7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,
        7,33,2,34,7,34,2,35,7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,
        2,40,7,40,2,41,7,41,2,42,7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,
        7,46,2,47,7,47,2,48,7,48,2,49,7,49,2,50,7,50,2,51,7,51,2,52,7,52,
        2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,56,2,57,7,57,2,58,7,58,2,59,
        7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,63,2,64,7,64,2,65,7,65,
        2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,7,70,2,71,7,71,2,72,
        7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,7,77,2,78,7,78,
        2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,7,84,2,85,
        7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,1,0,1,0,1,0,1,0,1,0,
        1,0,1,0,1,0,1,0,1,0,1,0,1,0,5,0,193,8,0,10,0,12,0,196,9,0,1,0,1,
        0,1,1,1,1,1,2,1,2,1,2,5,2,205,8,2,10,2,12,2,208,9,2,1,2,1,2,1,3,
        1,3,1,3,1,4,1,4,3,4,217,8,4,1,4,1,4,1,4,3,4,222,8,4,5,4,224,8,4,
        10,4,12,4,227,9,4,1,4,3,4,230,8,4,1,5,1,5,5,5,234,8,5,10,5,12,5,
        237,9,5,1,5,1,5,4,5,241,8,5,11,5,12,5,242,3,5,245,8,5,1,6,1,6,5,
        6,249,8,6,10,6,12,6,252,9,6,1,6,1,6,3,6,256,8,6,1,6,1,6,1,6,1,6,
        1,6,3,6,263,8,6,3,6,265,8,6,1,6,1,6,1,6,1,6,1,6,1,6,3,6,273,8,6,
        1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,8,1,8,1,8,1,8,1,8,1,8,1,8,
        1,9,1,9,1,9,1,9,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,11,1,11,3,11,
        304,8,11,1,11,1,11,1,12,1,12,1,12,1,12,3,12,312,8,12,1,12,3,12,315,
        8,12,1,12,1,12,1,13,4,13,320,8,13,11,13,12,13,321,1,14,1,14,1,14,
        1,14,1,14,3,14,329,8,14,1,15,1,15,1,15,5,15,334,8,15,10,15,12,15,
        337,9,15,1,16,1,16,1,16,1,17,1,17,1,17,1,17,3,17,346,8,17,1,17,1,
        17,3,17,350,8,17,1,18,3,18,353,8,18,1,18,1,18,1,18,1,18,1,18,1,18,
        1,19,1,19,1,19,1,19,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,21,1,21,
        1,21,3,21,375,8,21,4,21,377,8,21,11,21,12,21,378,1,21,1,21,1,22,
        1,22,1,22,1,22,1,22,3,22,388,8,22,1,23,1,23,1,24,1,24,1,24,1,24,
        1,24,4,24,397,8,24,11,24,12,24,398,1,24,1,24,1,25,1,25,1,25,1,25,
        1,25,1,26,1,26,3,26,410,8,26,1,27,1,27,5,27,414,8,27,10,27,12,27,
        417,9,27,1,28,1,28,4,28,421,8,28,11,28,12,28,422,1,29,1,29,1,29,
        1,29,1,30,1,30,1,30,1,30,3,30,433,8,30,1,30,1,30,1,30,1,30,1,31,
        1,31,1,31,1,31,1,31,3,31,444,8,31,1,31,1,31,1,31,1,31,1,31,3,31,
        451,8,31,5,31,453,8,31,10,31,12,31,456,9,31,1,31,3,31,459,8,31,1,
        31,1,31,1,32,1,32,1,32,1,32,3,32,467,8,32,1,32,1,32,1,32,1,32,1,
        33,1,33,1,33,1,33,1,33,3,33,478,8,33,1,34,1,34,1,34,1,34,1,35,1,
        35,1,35,1,35,1,35,1,35,1,35,1,35,4,35,492,8,35,11,35,12,35,493,1,
        35,1,35,1,36,1,36,1,37,1,37,1,37,1,37,1,38,1,38,1,38,1,38,1,38,1,
        38,1,38,1,38,4,38,512,8,38,11,38,12,38,513,1,38,1,38,1,39,1,39,3,
        39,520,8,39,1,39,3,39,523,8,39,1,39,1,39,1,39,1,39,1,39,1,39,1,39,
        1,39,1,39,1,39,1,39,3,39,536,8,39,1,39,3,39,539,8,39,3,39,541,8,
        39,1,40,1,40,1,40,3,40,546,8,40,1,41,1,41,3,41,550,8,41,1,41,1,41,
        1,41,3,41,555,8,41,4,41,557,8,41,11,41,12,41,558,1,42,1,42,1,42,
        1,42,1,42,1,42,3,42,567,8,42,1,42,1,42,1,42,1,43,1,43,1,44,1,44,
        1,44,1,44,1,44,1,45,1,45,1,46,1,46,1,47,1,47,1,48,1,48,1,48,1,48,
        3,48,589,8,48,1,48,1,48,1,49,1,49,1,49,1,49,5,49,597,8,49,10,49,
        12,49,600,9,49,3,49,602,8,49,1,50,1,50,1,50,1,50,1,50,3,50,609,8,
        50,1,51,1,51,1,51,1,51,1,51,1,51,1,51,1,51,1,51,1,51,1,51,1,51,3,
        51,623,8,51,1,52,1,52,1,52,3,52,628,8,52,4,52,630,8,52,11,52,12,
        52,631,1,53,1,53,1,53,1,53,1,54,1,54,1,55,1,55,1,55,1,55,5,55,644,
        8,55,10,55,12,55,647,9,55,1,55,1,55,1,55,3,55,652,8,55,1,56,1,56,
        1,56,3,56,657,8,56,1,57,1,57,1,58,1,58,1,58,1,58,1,58,1,58,1,58,
        1,59,1,59,3,59,670,8,59,1,60,1,60,1,60,1,60,1,60,3,60,677,8,60,1,
        60,1,60,1,60,5,60,682,8,60,10,60,12,60,685,9,60,1,61,1,61,1,61,1,
        62,1,62,1,62,1,62,1,63,1,63,3,63,696,8,63,1,63,1,63,1,64,1,64,1,
        65,1,65,1,65,1,65,1,66,1,66,3,66,708,8,66,1,67,1,67,1,67,5,67,713,
        8,67,10,67,12,67,716,9,67,1,67,3,67,719,8,67,1,68,1,68,1,68,1,68,
        1,68,1,68,1,68,4,68,728,8,68,11,68,12,68,729,1,68,3,68,733,8,68,
        1,68,3,68,736,8,68,1,68,1,68,3,68,740,8,68,1,69,1,69,1,69,1,69,1,
        69,1,69,5,69,748,8,69,10,69,12,69,751,9,69,1,69,3,69,754,8,69,1,
        69,1,69,3,69,758,8,69,1,70,1,70,1,70,1,70,1,70,1,70,1,70,1,70,1,
        70,1,70,1,70,5,70,771,8,70,10,70,12,70,774,9,70,1,70,3,70,777,8,
        70,1,70,1,70,3,70,781,8,70,1,71,1,71,1,72,1,72,1,72,1,72,1,72,1,
        72,5,72,791,8,72,10,72,12,72,794,9,72,1,73,1,73,1,73,1,73,1,73,1,
        73,5,73,802,8,73,10,73,12,73,805,9,73,1,74,1,74,1,74,3,74,810,8,
        74,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,
        75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,
        75,1,75,1,75,5,75,840,8,75,10,75,12,75,843,9,75,1,76,1,76,1,76,1,
        76,1,76,1,76,5,76,851,8,76,10,76,12,76,854,9,76,1,77,1,77,1,77,1,
        77,1,77,1,77,5,77,862,8,77,10,77,12,77,865,9,77,1,78,1,78,1,78,1,
        78,1,78,1,78,5,78,873,8,78,10,78,12,78,876,9,78,1,79,1,79,1,79,1,
        79,1,79,1,79,1,79,1,79,1,79,5,79,887,8,79,10,79,12,79,890,9,79,1,
        80,1,80,1,80,1,80,1,80,1,80,1,80,1,80,1,80,5,80,901,8,80,10,80,12,
        80,904,9,80,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,81,1,
        81,1,81,5,81,918,8,81,10,81,12,81,921,9,81,1,82,1,82,1,82,1,82,1,
        82,1,82,1,82,3,82,930,8,82,1,83,1,83,1,83,1,83,1,83,1,83,5,83,938,
        8,83,10,83,12,83,941,9,83,1,84,1,84,1,84,1,84,1,84,1,85,1,85,1,85,
        1,85,1,85,1,85,1,85,5,85,955,8,85,10,85,12,85,958,9,85,1,85,1,85,
        1,86,1,86,3,86,964,8,86,1,87,1,87,1,87,1,87,1,87,1,87,1,87,1,87,
        1,87,3,87,975,8,87,1,88,1,88,1,89,1,89,1,89,3,89,982,8,89,1,89,0,
        10,144,146,150,152,154,156,158,160,162,166,90,0,2,4,6,8,10,12,14,
        16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,
        60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,
        102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,
        134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,
        166,168,170,172,174,176,178,0,3,2,0,65,65,68,68,3,0,27,34,50,51,
        54,56,1,0,68,72,1038,0,194,1,0,0,0,2,199,1,0,0,0,4,206,1,0,0,0,6,
        211,1,0,0,0,8,214,1,0,0,0,10,231,1,0,0,0,12,272,1,0,0,0,14,274,1,
        0,0,0,16,283,1,0,0,0,18,290,1,0,0,0,20,294,1,0,0,0,22,303,1,0,0,
        0,24,307,1,0,0,0,26,319,1,0,0,0,28,323,1,0,0,0,30,330,1,0,0,0,32,
        338,1,0,0,0,34,341,1,0,0,0,36,352,1,0,0,0,38,360,1,0,0,0,40,364,
        1,0,0,0,42,371,1,0,0,0,44,382,1,0,0,0,46,389,1,0,0,0,48,391,1,0,
        0,0,50,402,1,0,0,0,52,409,1,0,0,0,54,411,1,0,0,0,56,418,1,0,0,0,
        58,424,1,0,0,0,60,428,1,0,0,0,62,438,1,0,0,0,64,462,1,0,0,0,66,477,
        1,0,0,0,68,479,1,0,0,0,70,483,1,0,0,0,72,497,1,0,0,0,74,499,1,0,
        0,0,76,503,1,0,0,0,78,540,1,0,0,0,80,542,1,0,0,0,82,549,1,0,0,0,
        84,566,1,0,0,0,86,571,1,0,0,0,88,573,1,0,0,0,90,578,1,0,0,0,92,580,
        1,0,0,0,94,582,1,0,0,0,96,584,1,0,0,0,98,592,1,0,0,0,100,608,1,0,
        0,0,102,622,1,0,0,0,104,629,1,0,0,0,106,633,1,0,0,0,108,637,1,0,
        0,0,110,639,1,0,0,0,112,653,1,0,0,0,114,658,1,0,0,0,116,660,1,0,
        0,0,118,669,1,0,0,0,120,676,1,0,0,0,122,686,1,0,0,0,124,689,1,0,
        0,0,126,693,1,0,0,0,128,699,1,0,0,0,130,701,1,0,0,0,132,707,1,0,
        0,0,134,709,1,0,0,0,136,739,1,0,0,0,138,757,1,0,0,0,140,780,1,0,
        0,0,142,782,1,0,0,0,144,784,1,0,0,0,146,795,1,0,0,0,148,809,1,0,
        0,0,150,811,1,0,0,0,152,844,1,0,0,0,154,855,1,0,0,0,156,866,1,0,
        0,0,158,877,1,0,0,0,160,891,1,0,0,0,162,905,1,0,0,0,164,929,1,0,
        0,0,166,931,1,0,0,0,168,942,1,0,0,0,170,947,1,0,0,0,172,963,1,0,
        0,0,174,974,1,0,0,0,176,976,1,0,0,0,178,981,1,0,0,0,180,193,5,67,
        0,0,181,193,5,76,0,0,182,193,3,12,6,0,183,193,3,70,35,0,184,193,
        3,76,38,0,185,193,3,14,7,0,186,193,3,22,11,0,187,193,3,50,25,0,188,
        193,3,44,22,0,189,193,3,36,18,0,190,193,3,16,8,0,191,193,5,75,0,
        0,192,180,1,0,0,0,192,181,1,0,0,0,192,182,1,0,0,0,192,183,1,0,0,
        0,192,184,1,0,0,0,192,185,1,0,0,0,192,186,1,0,0,0,192,187,1,0,0,
        0,192,188,1,0,0,0,192,189,1,0,0,0,192,190,1,0,0,0,192,191,1,0,0,
        0,193,196,1,0,0,0,194,192,1,0,0,0,194,195,1,0,0,0,195,197,1,0,0,
        0,196,194,1,0,0,0,197,198,5,0,0,1,198,1,1,0,0,0,199,200,5,65,0,0,
        200,3,1,0,0,0,201,202,3,2,1,0,202,203,5,4,0,0,203,205,1,0,0,0,204,
        201,1,0,0,0,205,208,1,0,0,0,206,204,1,0,0,0,206,207,1,0,0,0,207,
        209,1,0,0,0,208,206,1,0,0,0,209,210,3,2,1,0,210,5,1,0,0,0,211,212,
        5,1,0,0,212,213,5,65,0,0,213,7,1,0,0,0,214,216,3,2,1,0,215,217,3,
        6,3,0,216,215,1,0,0,0,216,217,1,0,0,0,217,225,1,0,0,0,218,219,5,
        5,0,0,219,221,3,2,1,0,220,222,3,6,3,0,221,220,1,0,0,0,221,222,1,
        0,0,0,222,224,1,0,0,0,223,218,1,0,0,0,224,227,1,0,0,0,225,223,1,
        0,0,0,225,226,1,0,0,0,226,229,1,0,0,0,227,225,1,0,0,0,228,230,5,
        5,0,0,229,228,1,0,0,0,229,230,1,0,0,0,230,9,1,0,0,0,231,244,5,2,
        0,0,232,234,5,4,0,0,233,232,1,0,0,0,234,237,1,0,0,0,235,233,1,0,
        0,0,235,236,1,0,0,0,236,238,1,0,0,0,237,235,1,0,0,0,238,245,3,4,
        2,0,239,241,5,4,0,0,240,239,1,0,0,0,241,242,1,0,0,0,242,240,1,0,
        0,0,242,243,1,0,0,0,243,245,1,0,0,0,244,235,1,0,0,0,244,240,1,0,
        0,0,245,11,1,0,0,0,246,250,5,3,0,0,247,249,5,4,0,0,248,247,1,0,0,
        0,249,252,1,0,0,0,250,248,1,0,0,0,250,251,1,0,0,0,251,253,1,0,0,
        0,252,250,1,0,0,0,253,255,3,4,2,0,254,256,3,6,3,0,255,254,1,0,0,
        0,255,256,1,0,0,0,256,273,1,0,0,0,257,258,3,10,5,0,258,264,5,3,0,
        0,259,265,5,6,0,0,260,262,3,2,1,0,261,263,3,6,3,0,262,261,1,0,0,
        0,262,263,1,0,0,0,263,265,1,0,0,0,264,259,1,0,0,0,264,260,1,0,0,
        0,265,273,1,0,0,0,266,267,3,10,5,0,267,268,5,3,0,0,268,269,5,7,0,
        0,269,270,3,8,4,0,270,271,5,8,0,0,271,273,1,0,0,0,272,246,1,0,0,
        0,272,257,1,0,0,0,272,266,1,0,0,0,273,13,1,0,0,0,274,275,5,65,0,
        0,275,276,5,9,0,0,276,277,5,10,0,0,277,278,5,7,0,0,278,279,3,66,
        33,0,279,280,5,8,0,0,280,281,5,11,0,0,281,282,3,118,59,0,282,15,
        1,0,0,0,283,284,5,65,0,0,284,285,5,9,0,0,285,286,5,12,0,0,286,287,
        5,7,0,0,287,288,3,66,33,0,288,289,5,8,0,0,289,17,1,0,0,0,290,291,
        5,65,0,0,291,292,5,9,0,0,292,293,3,66,33,0,293,19,1,0,0,0,294,295,
        5,65,0,0,295,296,5,9,0,0,296,297,5,13,0,0,297,298,5,7,0,0,298,299,
        3,66,33,0,299,300,5,8,0,0,300,21,1,0,0,0,301,304,3,18,9,0,302,304,
        3,20,10,0,303,301,1,0,0,0,303,302,1,0,0,0,304,305,1,0,0,0,305,306,
        5,75,0,0,306,23,1,0,0,0,307,308,5,14,0,0,308,314,5,65,0,0,309,311,
        5,7,0,0,310,312,3,134,67,0,311,310,1,0,0,0,311,312,1,0,0,0,312,313,
        1,0,0,0,313,315,5,8,0,0,314,309,1,0,0,0,314,315,1,0,0,0,315,316,
        1,0,0,0,316,317,5,75,0,0,317,25,1,0,0,0,318,320,3,24,12,0,319,318,
        1,0,0,0,320,321,1,0,0,0,321,319,1,0,0,0,321,322,1,0,0,0,322,27,1,
        0,0,0,323,324,5,65,0,0,324,325,5,9,0,0,325,328,3,66,33,0,326,327,
        5,11,0,0,327,329,3,118,59,0,328,326,1,0,0,0,328,329,1,0,0,0,329,
        29,1,0,0,0,330,335,3,28,14,0,331,332,5,5,0,0,332,334,3,28,14,0,333,
        331,1,0,0,0,334,337,1,0,0,0,335,333,1,0,0,0,335,336,1,0,0,0,336,
        31,1,0,0,0,337,335,1,0,0,0,338,339,5,20,0,0,339,340,3,66,33,0,340,
        33,1,0,0,0,341,342,5,19,0,0,342,343,5,65,0,0,343,345,5,7,0,0,344,
        346,3,30,15,0,345,344,1,0,0,0,345,346,1,0,0,0,346,347,1,0,0,0,347,
        349,5,8,0,0,348,350,3,32,16,0,349,348,1,0,0,0,349,350,1,0,0,0,350,
        35,1,0,0,0,351,353,3,26,13,0,352,351,1,0,0,0,352,353,1,0,0,0,353,
        354,1,0,0,0,354,355,3,34,17,0,355,356,5,9,0,0,356,357,5,77,0,0,357,
        358,3,104,52,0,358,359,5,78,0,0,359,37,1,0,0,0,360,361,5,65,0,0,
        361,362,5,9,0,0,362,363,3,66,33,0,363,39,1,0,0,0,364,365,5,65,0,
        0,365,366,5,9,0,0,366,367,5,15,0,0,367,368,5,7,0,0,368,369,3,66,
        33,0,369,370,5,8,0,0,370,41,1,0,0,0,371,376,5,77,0,0,372,375,3,18,
        9,0,373,375,3,40,20,0,374,372,1,0,0,0,374,373,1,0,0,0,375,377,1,
        0,0,0,376,374,1,0,0,0,377,378,1,0,0,0,378,376,1,0,0,0,378,379,1,
        0,0,0,379,380,1,0,0,0,380,381,5,78,0,0,381,43,1,0,0,0,382,383,5,
        21,0,0,383,384,5,65,0,0,384,387,5,9,0,0,385,388,3,42,21,0,386,388,
        5,35,0,0,387,385,1,0,0,0,387,386,1,0,0,0,388,45,1,0,0,0,389,390,
        5,65,0,0,390,47,1,0,0,0,391,392,5,75,0,0,392,396,5,77,0,0,393,394,
        3,46,23,0,394,395,5,75,0,0,395,397,1,0,0,0,396,393,1,0,0,0,397,398,
        1,0,0,0,398,396,1,0,0,0,398,399,1,0,0,0,399,400,1,0,0,0,400,401,
        5,78,0,0,401,49,1,0,0,0,402,403,5,22,0,0,403,404,5,65,0,0,404,405,
        5,9,0,0,405,406,3,48,24,0,406,51,1,0,0,0,407,410,3,54,27,0,408,410,
        3,56,28,0,409,407,1,0,0,0,409,408,1,0,0,0,410,53,1,0,0,0,411,415,
        5,65,0,0,412,414,3,58,29,0,413,412,1,0,0,0,414,417,1,0,0,0,415,413,
        1,0,0,0,415,416,1,0,0,0,416,55,1,0,0,0,417,415,1,0,0,0,418,420,5,
        18,0,0,419,421,3,60,30,0,420,419,1,0,0,0,421,422,1,0,0,0,422,420,
        1,0,0,0,422,423,1,0,0,0,423,57,1,0,0,0,424,425,5,16,0,0,425,426,
        7,0,0,0,426,427,5,17,0,0,427,59,1,0,0,0,428,432,5,16,0,0,429,433,
        5,65,0,0,430,433,3,54,27,0,431,433,3,56,28,0,432,429,1,0,0,0,432,
        430,1,0,0,0,432,431,1,0,0,0,433,434,1,0,0,0,434,435,5,5,0,0,435,
        436,7,0,0,0,436,437,5,17,0,0,437,61,1,0,0,0,438,443,5,7,0,0,439,
        444,5,65,0,0,440,444,3,52,26,0,441,444,3,56,28,0,442,444,3,62,31,
        0,443,439,1,0,0,0,443,440,1,0,0,0,443,441,1,0,0,0,443,442,1,0,0,
        0,444,454,1,0,0,0,445,450,5,5,0,0,446,451,5,65,0,0,447,451,3,52,
        26,0,448,451,3,56,28,0,449,451,3,62,31,0,450,446,1,0,0,0,450,447,
        1,0,0,0,450,448,1,0,0,0,450,449,1,0,0,0,451,453,1,0,0,0,452,445,
        1,0,0,0,453,456,1,0,0,0,454,452,1,0,0,0,454,455,1,0,0,0,455,458,
        1,0,0,0,456,454,1,0,0,0,457,459,5,5,0,0,458,457,1,0,0,0,458,459,
        1,0,0,0,459,460,1,0,0,0,460,461,5,8,0,0,461,63,1,0,0,0,462,463,5,
        23,0,0,463,466,5,16,0,0,464,467,5,65,0,0,465,467,3,52,26,0,466,464,
        1,0,0,0,466,465,1,0,0,0,467,468,1,0,0,0,468,469,5,5,0,0,469,470,
        3,66,33,0,470,471,5,17,0,0,471,65,1,0,0,0,472,478,5,65,0,0,473,478,
        3,52,26,0,474,478,3,62,31,0,475,478,3,64,32,0,476,478,3,56,28,0,
        477,472,1,0,0,0,477,473,1,0,0,0,477,474,1,0,0,0,477,475,1,0,0,0,
        477,476,1,0,0,0,478,67,1,0,0,0,479,480,5,65,0,0,480,481,5,9,0,0,
        481,482,3,66,33,0,482,69,1,0,0,0,483,484,5,24,0,0,484,485,5,65,0,
        0,485,486,5,9,0,0,486,487,5,75,0,0,487,491,5,77,0,0,488,489,3,68,
        34,0,489,490,5,75,0,0,490,492,1,0,0,0,491,488,1,0,0,0,492,493,1,
        0,0,0,493,491,1,0,0,0,493,494,1,0,0,0,494,495,1,0,0,0,495,496,5,
        78,0,0,496,71,1,0,0,0,497,498,5,65,0,0,498,73,1,0,0,0,499,500,3,
        34,17,0,500,501,5,9,0,0,501,502,3,72,36,0,502,75,1,0,0,0,503,504,
        5,25,0,0,504,505,5,65,0,0,505,506,5,9,0,0,506,507,5,75,0,0,507,511,
        5,77,0,0,508,509,3,74,37,0,509,510,5,75,0,0,510,512,1,0,0,0,511,
        508,1,0,0,0,512,513,1,0,0,0,513,511,1,0,0,0,513,514,1,0,0,0,514,
        515,1,0,0,0,515,516,5,78,0,0,516,77,1,0,0,0,517,520,3,110,55,0,518,
        520,3,116,58,0,519,517,1,0,0,0,519,518,1,0,0,0,520,522,1,0,0,0,521,
        523,5,76,0,0,522,521,1,0,0,0,522,523,1,0,0,0,523,541,1,0,0,0,524,
        536,3,80,40,0,525,536,3,84,42,0,526,536,3,88,44,0,527,536,3,98,49,
        0,528,536,3,90,45,0,529,536,3,92,46,0,530,536,3,94,47,0,531,536,
        3,96,48,0,532,536,3,100,50,0,533,536,3,102,51,0,534,536,3,118,59,
        0,535,524,1,0,0,0,535,525,1,0,0,0,535,526,1,0,0,0,535,527,1,0,0,
        0,535,528,1,0,0,0,535,529,1,0,0,0,535,530,1,0,0,0,535,531,1,0,0,
        0,535,532,1,0,0,0,535,533,1,0,0,0,535,534,1,0,0,0,536,538,1,0,0,
        0,537,539,5,76,0,0,538,537,1,0,0,0,538,539,1,0,0,0,539,541,1,0,0,
        0,540,519,1,0,0,0,540,535,1,0,0,0,541,79,1,0,0,0,542,545,3,18,9,
        0,543,544,5,11,0,0,544,546,3,118,59,0,545,543,1,0,0,0,545,546,1,
        0,0,0,546,81,1,0,0,0,547,550,3,120,60,0,548,550,5,26,0,0,549,547,
        1,0,0,0,549,548,1,0,0,0,550,556,1,0,0,0,551,554,5,5,0,0,552,555,
        3,120,60,0,553,555,5,26,0,0,554,552,1,0,0,0,554,553,1,0,0,0,555,
        557,1,0,0,0,556,551,1,0,0,0,557,558,1,0,0,0,558,556,1,0,0,0,558,
        559,1,0,0,0,559,83,1,0,0,0,560,567,3,120,60,0,561,567,3,82,41,0,
        562,563,5,7,0,0,563,564,3,82,41,0,564,565,5,8,0,0,565,567,1,0,0,
        0,566,560,1,0,0,0,566,561,1,0,0,0,566,562,1,0,0,0,567,568,1,0,0,
        0,568,569,5,11,0,0,569,570,3,118,59,0,570,85,1,0,0,0,571,572,7,1,
        0,0,572,87,1,0,0,0,573,574,3,120,60,0,574,575,3,86,43,0,575,576,
        5,11,0,0,576,577,3,118,59,0,577,89,1,0,0,0,578,579,5,35,0,0,579,
        91,1,0,0,0,580,581,5,36,0,0,581,93,1,0,0,0,582,583,5,37,0,0,583,
        95,1,0,0,0,584,585,5,38,0,0,585,586,5,65,0,0,586,588,5,7,0,0,587,
        589,3,134,67,0,588,587,1,0,0,0,588,589,1,0,0,0,589,590,1,0,0,0,590,
        591,5,8,0,0,591,97,1,0,0,0,592,601,5,39,0,0,593,598,3,118,59,0,594,
        595,5,5,0,0,595,597,3,118,59,0,596,594,1,0,0,0,597,600,1,0,0,0,598,
        596,1,0,0,0,598,599,1,0,0,0,599,602,1,0,0,0,600,598,1,0,0,0,601,
        593,1,0,0,0,601,602,1,0,0,0,602,99,1,0,0,0,603,609,5,40,0,0,604,
        605,5,40,0,0,605,609,3,118,59,0,606,607,5,40,0,0,607,609,5,45,0,
        0,608,603,1,0,0,0,608,604,1,0,0,0,608,606,1,0,0,0,609,101,1,0,0,
        0,610,611,5,41,0,0,611,623,3,118,59,0,612,613,5,41,0,0,613,614,3,
        118,59,0,614,615,5,5,0,0,615,616,3,118,59,0,616,623,1,0,0,0,617,
        618,5,41,0,0,618,619,3,118,59,0,619,620,5,5,0,0,620,621,5,45,0,0,
        621,623,1,0,0,0,622,610,1,0,0,0,622,612,1,0,0,0,622,617,1,0,0,0,
        623,103,1,0,0,0,624,630,5,76,0,0,625,627,3,78,39,0,626,628,5,75,
        0,0,627,626,1,0,0,0,627,628,1,0,0,0,628,630,1,0,0,0,629,624,1,0,
        0,0,629,625,1,0,0,0,630,631,1,0,0,0,631,629,1,0,0,0,631,632,1,0,
        0,0,632,105,1,0,0,0,633,634,3,118,59,0,634,635,5,9,0,0,635,636,3,
        104,52,0,636,107,1,0,0,0,637,638,3,104,52,0,638,109,1,0,0,0,639,
        640,5,42,0,0,640,645,3,106,53,0,641,642,5,44,0,0,642,644,3,106,53,
        0,643,641,1,0,0,0,644,647,1,0,0,0,645,643,1,0,0,0,645,646,1,0,0,
        0,646,651,1,0,0,0,647,645,1,0,0,0,648,649,5,43,0,0,649,650,5,9,0,
        0,650,652,3,108,54,0,651,648,1,0,0,0,651,652,1,0,0,0,652,111,1,0,
        0,0,653,656,5,65,0,0,654,655,5,9,0,0,655,657,5,65,0,0,656,654,1,
        0,0,0,656,657,1,0,0,0,657,113,1,0,0,0,658,659,3,118,59,0,659,115,
        1,0,0,0,660,661,5,46,0,0,661,662,3,112,56,0,662,663,5,47,0,0,663,
        664,3,114,57,0,664,665,5,9,0,0,665,666,3,104,52,0,666,117,1,0,0,
        0,667,670,3,142,71,0,668,670,3,140,70,0,669,667,1,0,0,0,669,668,
        1,0,0,0,670,119,1,0,0,0,671,677,5,65,0,0,672,673,5,7,0,0,673,674,
        3,120,60,0,674,675,5,8,0,0,675,677,1,0,0,0,676,671,1,0,0,0,676,672,
        1,0,0,0,677,683,1,0,0,0,678,682,3,122,61,0,679,682,3,124,62,0,680,
        682,3,126,63,0,681,678,1,0,0,0,681,679,1,0,0,0,681,680,1,0,0,0,682,
        685,1,0,0,0,683,681,1,0,0,0,683,684,1,0,0,0,684,121,1,0,0,0,685,
        683,1,0,0,0,686,687,5,4,0,0,687,688,5,65,0,0,688,123,1,0,0,0,689,
        690,5,16,0,0,690,691,3,118,59,0,691,692,5,17,0,0,692,125,1,0,0,0,
        693,695,5,7,0,0,694,696,3,134,67,0,695,694,1,0,0,0,695,696,1,0,0,
        0,696,697,1,0,0,0,697,698,5,8,0,0,698,127,1,0,0,0,699,700,3,118,
        59,0,700,129,1,0,0,0,701,702,5,65,0,0,702,703,5,11,0,0,703,704,3,
        118,59,0,704,131,1,0,0,0,705,708,3,128,64,0,706,708,3,130,65,0,707,
        705,1,0,0,0,707,706,1,0,0,0,708,133,1,0,0,0,709,714,3,132,66,0,710,
        711,5,5,0,0,711,713,3,132,66,0,712,710,1,0,0,0,713,716,1,0,0,0,714,
        712,1,0,0,0,714,715,1,0,0,0,715,718,1,0,0,0,716,714,1,0,0,0,717,
        719,5,5,0,0,718,717,1,0,0,0,718,719,1,0,0,0,719,135,1,0,0,0,720,
        721,5,7,0,0,721,722,5,5,0,0,722,740,5,8,0,0,723,724,5,7,0,0,724,
        735,3,118,59,0,725,726,5,5,0,0,726,728,3,118,59,0,727,725,1,0,0,
        0,728,729,1,0,0,0,729,727,1,0,0,0,729,730,1,0,0,0,730,732,1,0,0,
        0,731,733,5,5,0,0,732,731,1,0,0,0,732,733,1,0,0,0,733,736,1,0,0,
        0,734,736,5,5,0,0,735,727,1,0,0,0,735,734,1,0,0,0,736,737,1,0,0,
        0,737,738,5,8,0,0,738,740,1,0,0,0,739,720,1,0,0,0,739,723,1,0,0,
        0,740,137,1,0,0,0,741,742,5,16,0,0,742,758,5,17,0,0,743,744,5,16,
        0,0,744,749,3,118,59,0,745,746,5,5,0,0,746,748,3,118,59,0,747,745,
        1,0,0,0,748,751,1,0,0,0,749,747,1,0,0,0,749,750,1,0,0,0,750,753,
        1,0,0,0,751,749,1,0,0,0,752,754,5,5,0,0,753,752,1,0,0,0,753,754,
        1,0,0,0,754,755,1,0,0,0,755,756,5,17,0,0,756,758,1,0,0,0,757,741,
        1,0,0,0,757,743,1,0,0,0,758,139,1,0,0,0,759,760,5,48,0,0,760,781,
        5,49,0,0,761,762,5,48,0,0,762,763,5,65,0,0,763,764,5,9,0,0,764,765,
        3,118,59,0,765,772,1,0,0,0,766,767,5,5,0,0,767,768,5,65,0,0,768,
        769,5,9,0,0,769,771,3,118,59,0,770,766,1,0,0,0,771,774,1,0,0,0,772,
        770,1,0,0,0,772,773,1,0,0,0,773,776,1,0,0,0,774,772,1,0,0,0,775,
        777,5,5,0,0,776,775,1,0,0,0,776,777,1,0,0,0,777,778,1,0,0,0,778,
        779,5,49,0,0,779,781,1,0,0,0,780,759,1,0,0,0,780,761,1,0,0,0,781,
        141,1,0,0,0,782,783,3,144,72,0,783,143,1,0,0,0,784,785,6,72,-1,0,
        785,786,3,146,73,0,786,792,1,0,0,0,787,788,10,1,0,0,788,789,5,51,
        0,0,789,791,3,146,73,0,790,787,1,0,0,0,791,794,1,0,0,0,792,790,1,
        0,0,0,792,793,1,0,0,0,793,145,1,0,0,0,794,792,1,0,0,0,795,796,6,
        73,-1,0,796,797,3,148,74,0,797,803,1,0,0,0,798,799,10,1,0,0,799,
        800,5,50,0,0,800,802,3,148,74,0,801,798,1,0,0,0,802,805,1,0,0,0,
        803,801,1,0,0,0,803,804,1,0,0,0,804,147,1,0,0,0,805,803,1,0,0,0,
        806,810,3,150,75,0,807,808,5,52,0,0,808,810,3,148,74,0,809,806,1,
        0,0,0,809,807,1,0,0,0,810,149,1,0,0,0,811,812,6,75,-1,0,812,813,
        3,152,76,0,813,841,1,0,0,0,814,815,10,8,0,0,815,816,5,61,0,0,816,
        840,3,152,76,0,817,818,10,7,0,0,818,819,5,62,0,0,819,840,3,152,76,
        0,820,821,10,6,0,0,821,822,5,57,0,0,822,840,3,152,76,0,823,824,10,
        5,0,0,824,825,5,58,0,0,825,840,3,152,76,0,826,827,10,4,0,0,827,828,
        5,59,0,0,828,840,3,152,76,0,829,830,10,3,0,0,830,831,5,60,0,0,831,
        840,3,152,76,0,832,833,10,2,0,0,833,834,5,47,0,0,834,840,3,152,76,
        0,835,836,10,1,0,0,836,837,5,52,0,0,837,838,5,47,0,0,838,840,3,152,
        76,0,839,814,1,0,0,0,839,817,1,0,0,0,839,820,1,0,0,0,839,823,1,0,
        0,0,839,826,1,0,0,0,839,829,1,0,0,0,839,832,1,0,0,0,839,835,1,0,
        0,0,840,843,1,0,0,0,841,839,1,0,0,0,841,842,1,0,0,0,842,151,1,0,
        0,0,843,841,1,0,0,0,844,845,6,76,-1,0,845,846,3,154,77,0,846,852,
        1,0,0,0,847,848,10,1,0,0,848,849,5,55,0,0,849,851,3,154,77,0,850,
        847,1,0,0,0,851,854,1,0,0,0,852,850,1,0,0,0,852,853,1,0,0,0,853,
        153,1,0,0,0,854,852,1,0,0,0,855,856,6,77,-1,0,856,857,3,156,78,0,
        857,863,1,0,0,0,858,859,10,1,0,0,859,860,5,56,0,0,860,862,3,156,
        78,0,861,858,1,0,0,0,862,865,1,0,0,0,863,861,1,0,0,0,863,864,1,0,
        0,0,864,155,1,0,0,0,865,863,1,0,0,0,866,867,6,78,-1,0,867,868,3,
        158,79,0,868,874,1,0,0,0,869,870,10,1,0,0,870,871,5,54,0,0,871,873,
        3,158,79,0,872,869,1,0,0,0,873,876,1,0,0,0,874,872,1,0,0,0,874,875,
        1,0,0,0,875,157,1,0,0,0,876,874,1,0,0,0,877,878,6,79,-1,0,878,879,
        3,160,80,0,879,888,1,0,0,0,880,881,10,2,0,0,881,882,5,33,0,0,882,
        887,3,160,80,0,883,884,10,1,0,0,884,885,5,34,0,0,885,887,3,160,80,
        0,886,880,1,0,0,0,886,883,1,0,0,0,887,890,1,0,0,0,888,886,1,0,0,
        0,888,889,1,0,0,0,889,159,1,0,0,0,890,888,1,0,0,0,891,892,6,80,-1,
        0,892,893,3,162,81,0,893,902,1,0,0,0,894,895,10,2,0,0,895,896,5,
        27,0,0,896,901,3,162,81,0,897,898,10,1,0,0,898,899,5,28,0,0,899,
        901,3,162,81,0,900,894,1,0,0,0,900,897,1,0,0,0,901,904,1,0,0,0,902,
        900,1,0,0,0,902,903,1,0,0,0,903,161,1,0,0,0,904,902,1,0,0,0,905,
        906,6,81,-1,0,906,907,3,164,82,0,907,919,1,0,0,0,908,909,10,3,0,
        0,909,910,5,29,0,0,910,918,3,164,82,0,911,912,10,2,0,0,912,913,5,
        30,0,0,913,918,3,164,82,0,914,915,10,1,0,0,915,916,5,31,0,0,916,
        918,3,164,82,0,917,908,1,0,0,0,917,911,1,0,0,0,917,914,1,0,0,0,918,
        921,1,0,0,0,919,917,1,0,0,0,919,920,1,0,0,0,920,163,1,0,0,0,921,
        919,1,0,0,0,922,930,3,166,83,0,923,924,5,27,0,0,924,930,3,166,83,
        0,925,926,5,28,0,0,926,930,3,166,83,0,927,928,5,53,0,0,928,930,3,
        166,83,0,929,922,1,0,0,0,929,923,1,0,0,0,929,925,1,0,0,0,929,927,
        1,0,0,0,930,165,1,0,0,0,931,932,6,83,-1,0,932,933,3,174,87,0,933,
        939,1,0,0,0,934,935,10,1,0,0,935,936,5,32,0,0,936,938,3,174,87,0,
        937,934,1,0,0,0,938,941,1,0,0,0,939,937,1,0,0,0,939,940,1,0,0,0,
        940,167,1,0,0,0,941,939,1,0,0,0,942,943,5,63,0,0,943,944,5,7,0,0,
        944,945,3,66,33,0,945,946,5,8,0,0,946,169,1,0,0,0,947,948,5,64,0,
        0,948,949,5,7,0,0,949,950,3,128,64,0,950,951,5,5,0,0,951,956,3,66,
        33,0,952,953,5,5,0,0,953,955,3,130,65,0,954,952,1,0,0,0,955,958,
        1,0,0,0,956,954,1,0,0,0,956,957,1,0,0,0,957,959,1,0,0,0,958,956,
        1,0,0,0,959,960,5,8,0,0,960,171,1,0,0,0,961,964,3,168,84,0,962,964,
        3,170,85,0,963,961,1,0,0,0,963,962,1,0,0,0,964,173,1,0,0,0,965,975,
        3,120,60,0,966,975,3,178,89,0,967,975,3,172,86,0,968,975,3,136,68,
        0,969,975,3,138,69,0,970,971,5,7,0,0,971,972,3,142,71,0,972,973,
        5,8,0,0,973,975,1,0,0,0,974,965,1,0,0,0,974,966,1,0,0,0,974,967,
        1,0,0,0,974,968,1,0,0,0,974,969,1,0,0,0,974,970,1,0,0,0,975,175,
        1,0,0,0,976,977,7,2,0,0,977,177,1,0,0,0,978,982,3,176,88,0,979,982,
        5,67,0,0,980,982,5,73,0,0,981,978,1,0,0,0,981,979,1,0,0,0,981,980,
        1,0,0,0,982,179,1,0,0,0,99,192,194,206,216,221,225,229,235,242,244,
        250,255,262,264,272,303,311,314,321,328,335,345,349,352,374,378,
        387,398,409,415,422,432,443,450,454,458,466,477,493,513,519,522,
        535,538,540,545,549,554,558,566,588,598,601,608,622,627,629,631,
        645,651,656,669,676,681,683,695,707,714,718,729,732,735,739,749,
        753,757,772,776,780,792,803,809,839,841,852,863,874,886,888,900,
        902,917,919,929,939,956,963,974,981
    ]

class VyperParser ( Parser ):

    grammarFileName = "Vyper.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'as'", "'from'", "'import'", "'.'", "','", 
                     "<INVALID>", "'('", "')'", "':'", "'constant'", "'='", 
                     "'immutable'", "'public'", "'@'", "'indexed'", "'['", 
                     "']'", "'DynArray'", "'def'", "'->'", "'event'", "'enum'", 
                     "'HashMap'", "'struct'", "'interface'", "'_'", "'+'", 
                     "'-'", "<INVALID>", "'/'", "'%'", "'**'", "'<<'", "'>>'", 
                     "'pass'", "'break'", "'continue'", "'log'", "'return'", 
                     "'raise'", "'assert'", "'if'", "'else'", "'elif'", 
                     "'UNREACHABLE'", "'for'", "'in'", "'{'", "'}'", "'and'", 
                     "'or'", "'not'", "'~'", "'&'", "'|'", "'^'", "'=='", 
                     "'!='", "'<='", "'>='", "'<'", "'>'", "'empty'", "'abidecode'" ]

    symbolicNames = [ "<INVALID>", "AS", "FROM", "IMPORT", "DOT", "COMMA", 
                      "WILDCARD", "LParen", "RParen", "COLON", "CONSTANT", 
                      "EQUALITY", "IMMUTABLE", "PUBLIC", "AT", "INDEXED", 
                      "RSquare", "LSquare", "DynArray", "FUNCDECL", "RETURNTYPE", 
                      "EVENTDECL", "ENUMDECL", "MAP", "STRUCTDECL", "INTERFACEDECL", 
                      "SkipAssign", "ADD", "SUB", "MUL", "DIV", "MOD", "POW", 
                      "SHL", "SHR", "PASS", "Break", "CONTINUE", "LOG", 
                      "RETURN", "RAISE", "ASSERT", "If", "Else", "Elif", 
                      "UNREACHABLE", "For", "In", "LCurly", "RCurly", "AND", 
                      "OR", "NOT", "NEG", "BITAND", "BITOR", "BITXOR", "EQ", 
                      "NE", "LE", "GE", "LT", "GT", "Empty", "AbiDecode", 
                      "NAME", "TYPE", "STRING", "DECNUMBER", "HEXNUMBER", 
                      "OCTNUMBER", "BINNUMBER", "FLOATNUMBER", "BOOL", "SPACES", 
                      "NEWLINE", "COMMENT", "INDENT", "DEDENT" ]

    RULE_module = 0
    RULE_importname = 1
    RULE_importpath = 2
    RULE_importalias = 3
    RULE_importlist = 4
    RULE_importfrom = 5
    RULE_import_ = 6
    RULE_constantdef = 7
    RULE_immutabledef = 8
    RULE_variable = 9
    RULE_variablewithgetter = 10
    RULE_variabledef = 11
    RULE_decorator = 12
    RULE_decorators = 13
    RULE_parameter = 14
    RULE_parameters = 15
    RULE_returns_ = 16
    RULE_functionsig = 17
    RULE_functiondef = 18
    RULE_eventmember = 19
    RULE_indexedeventarg = 20
    RULE_eventbody = 21
    RULE_eventdef = 22
    RULE_enummember = 23
    RULE_enumbody = 24
    RULE_enumdef = 25
    RULE_arraydef = 26
    RULE_simple_arraydef = 27
    RULE_dynarraydef = 28
    RULE_index = 29
    RULE_dynindex = 30
    RULE_tupledef = 31
    RULE_mapdef = 32
    RULE_type_ = 33
    RULE_structmember = 34
    RULE_structdef = 35
    RULE_mutability = 36
    RULE_interfacefunction = 37
    RULE_interfacedef = 38
    RULE_stmt = 39
    RULE_declaration = 40
    RULE_multipleassign = 41
    RULE_assign = 42
    RULE_augoperator = 43
    RULE_augassign = 44
    RULE_passstmt = 45
    RULE_breakstmt = 46
    RULE_continuestmt = 47
    RULE_logstmt = 48
    RULE_returnstmt = 49
    RULE_raisestmt = 50
    RULE_assertstmt = 51
    RULE_body = 52
    RULE_condexec = 53
    RULE_defaultexec = 54
    RULE_ifstmt = 55
    RULE_loopvariable = 56
    RULE_loopiterator = 57
    RULE_forstmt = 58
    RULE_expr = 59
    RULE_variableaccess = 60
    RULE_getattr = 61
    RULE_getitem = 62
    RULE_call = 63
    RULE_arg = 64
    RULE_kwarg = 65
    RULE_argument = 66
    RULE_arguments = 67
    RULE_tuple = 68
    RULE_list = 69
    RULE_dict = 70
    RULE_operation = 71
    RULE_boolor = 72
    RULE_booland = 73
    RULE_boolnot = 74
    RULE_comparator = 75
    RULE_bitwiseor = 76
    RULE_bitwisexor = 77
    RULE_bitwiseand = 78
    RULE_shift = 79
    RULE_summation = 80
    RULE_product = 81
    RULE_unary = 82
    RULE_power = 83
    RULE_empty = 84
    RULE_abidecode = 85
    RULE_specialbuiltins = 86
    RULE_atom = 87
    RULE_number = 88
    RULE_literal = 89

    ruleNames =  [ "module", "importname", "importpath", "importalias", 
                   "importlist", "importfrom", "import_", "constantdef", 
                   "immutabledef", "variable", "variablewithgetter", "variabledef", 
                   "decorator", "decorators", "parameter", "parameters", 
                   "returns_", "functionsig", "functiondef", "eventmember", 
                   "indexedeventarg", "eventbody", "eventdef", "enummember", 
                   "enumbody", "enumdef", "arraydef", "simple_arraydef", 
                   "dynarraydef", "index", "dynindex", "tupledef", "mapdef", 
                   "type_", "structmember", "structdef", "mutability", "interfacefunction", 
                   "interfacedef", "stmt", "declaration", "multipleassign", 
                   "assign", "augoperator", "augassign", "passstmt", "breakstmt", 
                   "continuestmt", "logstmt", "returnstmt", "raisestmt", 
                   "assertstmt", "body", "condexec", "defaultexec", "ifstmt", 
                   "loopvariable", "loopiterator", "forstmt", "expr", "variableaccess", 
                   "getattr", "getitem", "call", "arg", "kwarg", "argument", 
                   "arguments", "tuple", "list", "dict", "operation", "boolor", 
                   "booland", "boolnot", "comparator", "bitwiseor", "bitwisexor", 
                   "bitwiseand", "shift", "summation", "product", "unary", 
                   "power", "empty", "abidecode", "specialbuiltins", "atom", 
                   "number", "literal" ]

    EOF = Token.EOF
    AS=1
    FROM=2
    IMPORT=3
    DOT=4
    COMMA=5
    WILDCARD=6
    LParen=7
    RParen=8
    COLON=9
    CONSTANT=10
    EQUALITY=11
    IMMUTABLE=12
    PUBLIC=13
    AT=14
    INDEXED=15
    RSquare=16
    LSquare=17
    DynArray=18
    FUNCDECL=19
    RETURNTYPE=20
    EVENTDECL=21
    ENUMDECL=22
    MAP=23
    STRUCTDECL=24
    INTERFACEDECL=25
    SkipAssign=26
    ADD=27
    SUB=28
    MUL=29
    DIV=30
    MOD=31
    POW=32
    SHL=33
    SHR=34
    PASS=35
    Break=36
    CONTINUE=37
    LOG=38
    RETURN=39
    RAISE=40
    ASSERT=41
    If=42
    Else=43
    Elif=44
    UNREACHABLE=45
    For=46
    In=47
    LCurly=48
    RCurly=49
    AND=50
    OR=51
    NOT=52
    NEG=53
    BITAND=54
    BITOR=55
    BITXOR=56
    EQ=57
    NE=58
    LE=59
    GE=60
    LT=61
    GT=62
    Empty=63
    AbiDecode=64
    NAME=65
    TYPE=66
    STRING=67
    DECNUMBER=68
    HEXNUMBER=69
    OCTNUMBER=70
    BINNUMBER=71
    FLOATNUMBER=72
    BOOL=73
    SPACES=74
    NEWLINE=75
    COMMENT=76
    INDENT=77
    DEDENT=78

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.12.0")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ModuleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(VyperParser.EOF, 0)

        def STRING(self, i:int=None):
            if i is None:
                return self.getTokens(VyperParser.STRING)
            else:
                return self.getToken(VyperParser.STRING, i)

        def COMMENT(self, i:int=None):
            if i is None:
                return self.getTokens(VyperParser.COMMENT)
            else:
                return self.getToken(VyperParser.COMMENT, i)

        def import_(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VyperParser.Import_Context)
            else:
                return self.getTypedRuleContext(VyperParser.Import_Context,i)


        def structdef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VyperParser.StructdefContext)
            else:
                return self.getTypedRuleContext(VyperParser.StructdefContext,i)


        def interfacedef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VyperParser.InterfacedefContext)
            else:
                return self.getTypedRuleContext(VyperParser.InterfacedefContext,i)


        def constantdef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VyperParser.ConstantdefContext)
            else:
                return self.getTypedRuleContext(VyperParser.ConstantdefContext,i)


        def variabledef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VyperParser.VariabledefContext)
            else:
                return self.getTypedRuleContext(VyperParser.VariabledefContext,i)


        def enumdef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VyperParser.EnumdefContext)
            else:
                return self.getTypedRuleContext(VyperParser.EnumdefContext,i)


        def eventdef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VyperParser.EventdefContext)
            else:
                return self.getTypedRuleContext(VyperParser.EventdefContext,i)


        def functiondef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VyperParser.FunctiondefContext)
            else:
                return self.getTypedRuleContext(VyperParser.FunctiondefContext,i)


        def immutabledef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VyperParser.ImmutabledefContext)
            else:
                return self.getTypedRuleContext(VyperParser.ImmutabledefContext,i)


        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(VyperParser.NEWLINE)
            else:
                return self.getToken(VyperParser.NEWLINE, i)

        def getRuleIndex(self):
            return VyperParser.RULE_module

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterModule" ):
                listener.enterModule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitModule" ):
                listener.exitModule(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitModule" ):
                return visitor.visitModule(self)
            else:
                return visitor.visitChildren(self)




    def module(self):

        localctx = VyperParser.ModuleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_module)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 194
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 57163788) != 0) or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & 3077) != 0):
                self.state = 192
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,0,self._ctx)
                if la_ == 1:
                    self.state = 180
                    self.match(VyperParser.STRING)
                    pass

                elif la_ == 2:
                    self.state = 181
                    self.match(VyperParser.COMMENT)
                    pass

                elif la_ == 3:
                    self.state = 182
                    self.import_()
                    pass

                elif la_ == 4:
                    self.state = 183
                    self.structdef()
                    pass

                elif la_ == 5:
                    self.state = 184
                    self.interfacedef()
                    pass

                elif la_ == 6:
                    self.state = 185
                    self.constantdef()
                    pass

                elif la_ == 7:
                    self.state = 186
                    self.variabledef()
                    pass

                elif la_ == 8:
                    self.state = 187
                    self.enumdef()
                    pass

                elif la_ == 9:
                    self.state = 188
                    self.eventdef()
                    pass

                elif la_ == 10:
                    self.state = 189
                    self.functiondef()
                    pass

                elif la_ == 11:
                    self.state = 190
                    self.immutabledef()
                    pass

                elif la_ == 12:
                    self.state = 191
                    self.match(VyperParser.NEWLINE)
                    pass


                self.state = 196
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 197
            self.match(VyperParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ImportnameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NAME(self):
            return self.getToken(VyperParser.NAME, 0)

        def getRuleIndex(self):
            return VyperParser.RULE_importname

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImportname" ):
                listener.enterImportname(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImportname" ):
                listener.exitImportname(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitImportname" ):
                return visitor.visitImportname(self)
            else:
                return visitor.visitChildren(self)




    def importname(self):

        localctx = VyperParser.ImportnameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_importname)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 199
            self.match(VyperParser.NAME)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ImportpathContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def importname(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VyperParser.ImportnameContext)
            else:
                return self.getTypedRuleContext(VyperParser.ImportnameContext,i)


        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(VyperParser.DOT)
            else:
                return self.getToken(VyperParser.DOT, i)

        def getRuleIndex(self):
            return VyperParser.RULE_importpath

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImportpath" ):
                listener.enterImportpath(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImportpath" ):
                listener.exitImportpath(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitImportpath" ):
                return visitor.visitImportpath(self)
            else:
                return visitor.visitChildren(self)




    def importpath(self):

        localctx = VyperParser.ImportpathContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_importpath)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 206
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,2,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 201
                    self.importname()
                    self.state = 202
                    self.match(VyperParser.DOT) 
                self.state = 208
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,2,self._ctx)

            self.state = 209
            self.importname()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ImportaliasContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AS(self):
            return self.getToken(VyperParser.AS, 0)

        def NAME(self):
            return self.getToken(VyperParser.NAME, 0)

        def getRuleIndex(self):
            return VyperParser.RULE_importalias

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImportalias" ):
                listener.enterImportalias(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImportalias" ):
                listener.exitImportalias(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitImportalias" ):
                return visitor.visitImportalias(self)
            else:
                return visitor.visitChildren(self)




    def importalias(self):

        localctx = VyperParser.ImportaliasContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_importalias)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 211
            self.match(VyperParser.AS)
            self.state = 212
            self.match(VyperParser.NAME)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ImportlistContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def importname(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VyperParser.ImportnameContext)
            else:
                return self.getTypedRuleContext(VyperParser.ImportnameContext,i)


        def importalias(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VyperParser.ImportaliasContext)
            else:
                return self.getTypedRuleContext(VyperParser.ImportaliasContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(VyperParser.COMMA)
            else:
                return self.getToken(VyperParser.COMMA, i)

        def getRuleIndex(self):
            return VyperParser.RULE_importlist

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImportlist" ):
                listener.enterImportlist(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImportlist" ):
                listener.exitImportlist(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitImportlist" ):
                return visitor.visitImportlist(self)
            else:
                return visitor.visitChildren(self)




    def importlist(self):

        localctx = VyperParser.ImportlistContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_importlist)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 214
            self.importname()
            self.state = 216
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==1:
                self.state = 215
                self.importalias()


            self.state = 225
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,5,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 218
                    self.match(VyperParser.COMMA)
                    self.state = 219
                    self.importname()
                    self.state = 221
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==1:
                        self.state = 220
                        self.importalias()

             
                self.state = 227
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,5,self._ctx)

            self.state = 229
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==5:
                self.state = 228
                self.match(VyperParser.COMMA)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ImportfromContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FROM(self):
            return self.getToken(VyperParser.FROM, 0)

        def importpath(self):
            return self.getTypedRuleContext(VyperParser.ImportpathContext,0)


        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(VyperParser.DOT)
            else:
                return self.getToken(VyperParser.DOT, i)

        def getRuleIndex(self):
            return VyperParser.RULE_importfrom

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImportfrom" ):
                listener.enterImportfrom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImportfrom" ):
                listener.exitImportfrom(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitImportfrom" ):
                return visitor.visitImportfrom(self)
            else:
                return visitor.visitChildren(self)




    def importfrom(self):

        localctx = VyperParser.ImportfromContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_importfrom)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 231
            self.match(VyperParser.FROM)
            self.state = 244
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,9,self._ctx)
            if la_ == 1:
                self.state = 235
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==4:
                    self.state = 232
                    self.match(VyperParser.DOT)
                    self.state = 237
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 238
                self.importpath()
                pass

            elif la_ == 2:
                self.state = 240 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 239
                    self.match(VyperParser.DOT)
                    self.state = 242 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==4):
                        break

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Import_Context(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IMPORT(self):
            return self.getToken(VyperParser.IMPORT, 0)

        def importpath(self):
            return self.getTypedRuleContext(VyperParser.ImportpathContext,0)


        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(VyperParser.DOT)
            else:
                return self.getToken(VyperParser.DOT, i)

        def importalias(self):
            return self.getTypedRuleContext(VyperParser.ImportaliasContext,0)


        def importfrom(self):
            return self.getTypedRuleContext(VyperParser.ImportfromContext,0)


        def WILDCARD(self):
            return self.getToken(VyperParser.WILDCARD, 0)

        def importname(self):
            return self.getTypedRuleContext(VyperParser.ImportnameContext,0)


        def LParen(self):
            return self.getToken(VyperParser.LParen, 0)

        def importlist(self):
            return self.getTypedRuleContext(VyperParser.ImportlistContext,0)


        def RParen(self):
            return self.getToken(VyperParser.RParen, 0)

        def getRuleIndex(self):
            return VyperParser.RULE_import_

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImport_" ):
                listener.enterImport_(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImport_" ):
                listener.exitImport_(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitImport_" ):
                return visitor.visitImport_(self)
            else:
                return visitor.visitChildren(self)




    def import_(self):

        localctx = VyperParser.Import_Context(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_import_)
        self._la = 0 # Token type
        try:
            self.state = 272
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,14,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 246
                self.match(VyperParser.IMPORT)
                self.state = 250
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==4:
                    self.state = 247
                    self.match(VyperParser.DOT)
                    self.state = 252
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 253
                self.importpath()
                self.state = 255
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==1:
                    self.state = 254
                    self.importalias()


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 257
                self.importfrom()
                self.state = 258
                self.match(VyperParser.IMPORT)
                self.state = 264
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [6]:
                    self.state = 259
                    self.match(VyperParser.WILDCARD)
                    pass
                elif token in [65]:
                    self.state = 260
                    self.importname()
                    self.state = 262
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==1:
                        self.state = 261
                        self.importalias()


                    pass
                else:
                    raise NoViableAltException(self)

                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 266
                self.importfrom()
                self.state = 267
                self.match(VyperParser.IMPORT)
                self.state = 268
                self.match(VyperParser.LParen)
                self.state = 269
                self.importlist()
                self.state = 270
                self.match(VyperParser.RParen)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConstantdefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NAME(self):
            return self.getToken(VyperParser.NAME, 0)

        def COLON(self):
            return self.getToken(VyperParser.COLON, 0)

        def CONSTANT(self):
            return self.getToken(VyperParser.CONSTANT, 0)

        def LParen(self):
            return self.getToken(VyperParser.LParen, 0)

        def type_(self):
            return self.getTypedRuleContext(VyperParser.Type_Context,0)


        def RParen(self):
            return self.getToken(VyperParser.RParen, 0)

        def EQUALITY(self):
            return self.getToken(VyperParser.EQUALITY, 0)

        def expr(self):
            return self.getTypedRuleContext(VyperParser.ExprContext,0)


        def getRuleIndex(self):
            return VyperParser.RULE_constantdef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstantdef" ):
                listener.enterConstantdef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstantdef" ):
                listener.exitConstantdef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstantdef" ):
                return visitor.visitConstantdef(self)
            else:
                return visitor.visitChildren(self)




    def constantdef(self):

        localctx = VyperParser.ConstantdefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_constantdef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 274
            self.match(VyperParser.NAME)
            self.state = 275
            self.match(VyperParser.COLON)
            self.state = 276
            self.match(VyperParser.CONSTANT)
            self.state = 277
            self.match(VyperParser.LParen)
            self.state = 278
            self.type_()
            self.state = 279
            self.match(VyperParser.RParen)
            self.state = 280
            self.match(VyperParser.EQUALITY)
            self.state = 281
            self.expr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ImmutabledefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NAME(self):
            return self.getToken(VyperParser.NAME, 0)

        def COLON(self):
            return self.getToken(VyperParser.COLON, 0)

        def IMMUTABLE(self):
            return self.getToken(VyperParser.IMMUTABLE, 0)

        def LParen(self):
            return self.getToken(VyperParser.LParen, 0)

        def type_(self):
            return self.getTypedRuleContext(VyperParser.Type_Context,0)


        def RParen(self):
            return self.getToken(VyperParser.RParen, 0)

        def getRuleIndex(self):
            return VyperParser.RULE_immutabledef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterImmutabledef" ):
                listener.enterImmutabledef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitImmutabledef" ):
                listener.exitImmutabledef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitImmutabledef" ):
                return visitor.visitImmutabledef(self)
            else:
                return visitor.visitChildren(self)




    def immutabledef(self):

        localctx = VyperParser.ImmutabledefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_immutabledef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 283
            self.match(VyperParser.NAME)
            self.state = 284
            self.match(VyperParser.COLON)
            self.state = 285
            self.match(VyperParser.IMMUTABLE)
            self.state = 286
            self.match(VyperParser.LParen)
            self.state = 287
            self.type_()
            self.state = 288
            self.match(VyperParser.RParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NAME(self):
            return self.getToken(VyperParser.NAME, 0)

        def COLON(self):
            return self.getToken(VyperParser.COLON, 0)

        def type_(self):
            return self.getTypedRuleContext(VyperParser.Type_Context,0)


        def getRuleIndex(self):
            return VyperParser.RULE_variable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariable" ):
                listener.enterVariable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariable" ):
                listener.exitVariable(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariable" ):
                return visitor.visitVariable(self)
            else:
                return visitor.visitChildren(self)




    def variable(self):

        localctx = VyperParser.VariableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_variable)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 290
            self.match(VyperParser.NAME)
            self.state = 291
            self.match(VyperParser.COLON)
            self.state = 292
            self.type_()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariablewithgetterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NAME(self):
            return self.getToken(VyperParser.NAME, 0)

        def COLON(self):
            return self.getToken(VyperParser.COLON, 0)

        def PUBLIC(self):
            return self.getToken(VyperParser.PUBLIC, 0)

        def LParen(self):
            return self.getToken(VyperParser.LParen, 0)

        def type_(self):
            return self.getTypedRuleContext(VyperParser.Type_Context,0)


        def RParen(self):
            return self.getToken(VyperParser.RParen, 0)

        def getRuleIndex(self):
            return VyperParser.RULE_variablewithgetter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariablewithgetter" ):
                listener.enterVariablewithgetter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariablewithgetter" ):
                listener.exitVariablewithgetter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariablewithgetter" ):
                return visitor.visitVariablewithgetter(self)
            else:
                return visitor.visitChildren(self)




    def variablewithgetter(self):

        localctx = VyperParser.VariablewithgetterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_variablewithgetter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 294
            self.match(VyperParser.NAME)
            self.state = 295
            self.match(VyperParser.COLON)
            self.state = 296
            self.match(VyperParser.PUBLIC)
            self.state = 297
            self.match(VyperParser.LParen)
            self.state = 298
            self.type_()
            self.state = 299
            self.match(VyperParser.RParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariabledefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NEWLINE(self):
            return self.getToken(VyperParser.NEWLINE, 0)

        def variable(self):
            return self.getTypedRuleContext(VyperParser.VariableContext,0)


        def variablewithgetter(self):
            return self.getTypedRuleContext(VyperParser.VariablewithgetterContext,0)


        def getRuleIndex(self):
            return VyperParser.RULE_variabledef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariabledef" ):
                listener.enterVariabledef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariabledef" ):
                listener.exitVariabledef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariabledef" ):
                return visitor.visitVariabledef(self)
            else:
                return visitor.visitChildren(self)




    def variabledef(self):

        localctx = VyperParser.VariabledefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_variabledef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 303
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,15,self._ctx)
            if la_ == 1:
                self.state = 301
                self.variable()
                pass

            elif la_ == 2:
                self.state = 302
                self.variablewithgetter()
                pass


            self.state = 305
            self.match(VyperParser.NEWLINE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DecoratorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AT(self):
            return self.getToken(VyperParser.AT, 0)

        def NAME(self):
            return self.getToken(VyperParser.NAME, 0)

        def NEWLINE(self):
            return self.getToken(VyperParser.NEWLINE, 0)

        def LParen(self):
            return self.getToken(VyperParser.LParen, 0)

        def RParen(self):
            return self.getToken(VyperParser.RParen, 0)

        def arguments(self):
            return self.getTypedRuleContext(VyperParser.ArgumentsContext,0)


        def getRuleIndex(self):
            return VyperParser.RULE_decorator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDecorator" ):
                listener.enterDecorator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDecorator" ):
                listener.exitDecorator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDecorator" ):
                return visitor.visitDecorator(self)
            else:
                return visitor.visitChildren(self)




    def decorator(self):

        localctx = VyperParser.DecoratorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_decorator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 307
            self.match(VyperParser.AT)
            self.state = 308
            self.match(VyperParser.NAME)
            self.state = 314
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==7:
                self.state = 309
                self.match(VyperParser.LParen)
                self.state = 311
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & -9209579762593234816) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & 1019) != 0):
                    self.state = 310
                    self.arguments()


                self.state = 313
                self.match(VyperParser.RParen)


            self.state = 316
            self.match(VyperParser.NEWLINE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DecoratorsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def decorator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VyperParser.DecoratorContext)
            else:
                return self.getTypedRuleContext(VyperParser.DecoratorContext,i)


        def getRuleIndex(self):
            return VyperParser.RULE_decorators

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDecorators" ):
                listener.enterDecorators(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDecorators" ):
                listener.exitDecorators(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDecorators" ):
                return visitor.visitDecorators(self)
            else:
                return visitor.visitChildren(self)




    def decorators(self):

        localctx = VyperParser.DecoratorsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_decorators)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 319 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 318
                self.decorator()
                self.state = 321 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==14):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NAME(self):
            return self.getToken(VyperParser.NAME, 0)

        def COLON(self):
            return self.getToken(VyperParser.COLON, 0)

        def type_(self):
            return self.getTypedRuleContext(VyperParser.Type_Context,0)


        def EQUALITY(self):
            return self.getToken(VyperParser.EQUALITY, 0)

        def expr(self):
            return self.getTypedRuleContext(VyperParser.ExprContext,0)


        def getRuleIndex(self):
            return VyperParser.RULE_parameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameter" ):
                listener.enterParameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameter" ):
                listener.exitParameter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameter" ):
                return visitor.visitParameter(self)
            else:
                return visitor.visitChildren(self)




    def parameter(self):

        localctx = VyperParser.ParameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_parameter)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 323
            self.match(VyperParser.NAME)
            self.state = 324
            self.match(VyperParser.COLON)
            self.state = 325
            self.type_()
            self.state = 328
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==11:
                self.state = 326
                self.match(VyperParser.EQUALITY)
                self.state = 327
                self.expr()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParametersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def parameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VyperParser.ParameterContext)
            else:
                return self.getTypedRuleContext(VyperParser.ParameterContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(VyperParser.COMMA)
            else:
                return self.getToken(VyperParser.COMMA, i)

        def getRuleIndex(self):
            return VyperParser.RULE_parameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParameters" ):
                listener.enterParameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParameters" ):
                listener.exitParameters(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParameters" ):
                return visitor.visitParameters(self)
            else:
                return visitor.visitChildren(self)




    def parameters(self):

        localctx = VyperParser.ParametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_parameters)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 330
            self.parameter()
            self.state = 335
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==5:
                self.state = 331
                self.match(VyperParser.COMMA)
                self.state = 332
                self.parameter()
                self.state = 337
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Returns_Context(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RETURNTYPE(self):
            return self.getToken(VyperParser.RETURNTYPE, 0)

        def type_(self):
            return self.getTypedRuleContext(VyperParser.Type_Context,0)


        def getRuleIndex(self):
            return VyperParser.RULE_returns_

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReturns_" ):
                listener.enterReturns_(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReturns_" ):
                listener.exitReturns_(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReturns_" ):
                return visitor.visitReturns_(self)
            else:
                return visitor.visitChildren(self)




    def returns_(self):

        localctx = VyperParser.Returns_Context(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_returns_)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 338
            self.match(VyperParser.RETURNTYPE)
            self.state = 339
            self.type_()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionsigContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FUNCDECL(self):
            return self.getToken(VyperParser.FUNCDECL, 0)

        def NAME(self):
            return self.getToken(VyperParser.NAME, 0)

        def LParen(self):
            return self.getToken(VyperParser.LParen, 0)

        def RParen(self):
            return self.getToken(VyperParser.RParen, 0)

        def parameters(self):
            return self.getTypedRuleContext(VyperParser.ParametersContext,0)


        def returns_(self):
            return self.getTypedRuleContext(VyperParser.Returns_Context,0)


        def getRuleIndex(self):
            return VyperParser.RULE_functionsig

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctionsig" ):
                listener.enterFunctionsig(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctionsig" ):
                listener.exitFunctionsig(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctionsig" ):
                return visitor.visitFunctionsig(self)
            else:
                return visitor.visitChildren(self)




    def functionsig(self):

        localctx = VyperParser.FunctionsigContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_functionsig)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 341
            self.match(VyperParser.FUNCDECL)
            self.state = 342
            self.match(VyperParser.NAME)
            self.state = 343
            self.match(VyperParser.LParen)
            self.state = 345
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==65:
                self.state = 344
                self.parameters()


            self.state = 347
            self.match(VyperParser.RParen)
            self.state = 349
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==20:
                self.state = 348
                self.returns_()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctiondefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def functionsig(self):
            return self.getTypedRuleContext(VyperParser.FunctionsigContext,0)


        def COLON(self):
            return self.getToken(VyperParser.COLON, 0)

        def INDENT(self):
            return self.getToken(VyperParser.INDENT, 0)

        def body(self):
            return self.getTypedRuleContext(VyperParser.BodyContext,0)


        def DEDENT(self):
            return self.getToken(VyperParser.DEDENT, 0)

        def decorators(self):
            return self.getTypedRuleContext(VyperParser.DecoratorsContext,0)


        def getRuleIndex(self):
            return VyperParser.RULE_functiondef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunctiondef" ):
                listener.enterFunctiondef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunctiondef" ):
                listener.exitFunctiondef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunctiondef" ):
                return visitor.visitFunctiondef(self)
            else:
                return visitor.visitChildren(self)




    def functiondef(self):

        localctx = VyperParser.FunctiondefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_functiondef)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 352
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==14:
                self.state = 351
                self.decorators()


            self.state = 354
            self.functionsig()
            self.state = 355
            self.match(VyperParser.COLON)
            self.state = 356
            self.match(VyperParser.INDENT)
            self.state = 357
            self.body()
            self.state = 358
            self.match(VyperParser.DEDENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EventmemberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NAME(self):
            return self.getToken(VyperParser.NAME, 0)

        def COLON(self):
            return self.getToken(VyperParser.COLON, 0)

        def type_(self):
            return self.getTypedRuleContext(VyperParser.Type_Context,0)


        def getRuleIndex(self):
            return VyperParser.RULE_eventmember

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEventmember" ):
                listener.enterEventmember(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEventmember" ):
                listener.exitEventmember(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEventmember" ):
                return visitor.visitEventmember(self)
            else:
                return visitor.visitChildren(self)




    def eventmember(self):

        localctx = VyperParser.EventmemberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_eventmember)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 360
            self.match(VyperParser.NAME)
            self.state = 361
            self.match(VyperParser.COLON)
            self.state = 362
            self.type_()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IndexedeventargContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NAME(self):
            return self.getToken(VyperParser.NAME, 0)

        def COLON(self):
            return self.getToken(VyperParser.COLON, 0)

        def INDEXED(self):
            return self.getToken(VyperParser.INDEXED, 0)

        def LParen(self):
            return self.getToken(VyperParser.LParen, 0)

        def type_(self):
            return self.getTypedRuleContext(VyperParser.Type_Context,0)


        def RParen(self):
            return self.getToken(VyperParser.RParen, 0)

        def getRuleIndex(self):
            return VyperParser.RULE_indexedeventarg

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndexedeventarg" ):
                listener.enterIndexedeventarg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndexedeventarg" ):
                listener.exitIndexedeventarg(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIndexedeventarg" ):
                return visitor.visitIndexedeventarg(self)
            else:
                return visitor.visitChildren(self)




    def indexedeventarg(self):

        localctx = VyperParser.IndexedeventargContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_indexedeventarg)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 364
            self.match(VyperParser.NAME)
            self.state = 365
            self.match(VyperParser.COLON)
            self.state = 366
            self.match(VyperParser.INDEXED)
            self.state = 367
            self.match(VyperParser.LParen)
            self.state = 368
            self.type_()
            self.state = 369
            self.match(VyperParser.RParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EventbodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INDENT(self):
            return self.getToken(VyperParser.INDENT, 0)

        def DEDENT(self):
            return self.getToken(VyperParser.DEDENT, 0)

        def variable(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VyperParser.VariableContext)
            else:
                return self.getTypedRuleContext(VyperParser.VariableContext,i)


        def indexedeventarg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VyperParser.IndexedeventargContext)
            else:
                return self.getTypedRuleContext(VyperParser.IndexedeventargContext,i)


        def getRuleIndex(self):
            return VyperParser.RULE_eventbody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEventbody" ):
                listener.enterEventbody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEventbody" ):
                listener.exitEventbody(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEventbody" ):
                return visitor.visitEventbody(self)
            else:
                return visitor.visitChildren(self)




    def eventbody(self):

        localctx = VyperParser.EventbodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_eventbody)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 371
            self.match(VyperParser.INDENT)
            self.state = 376 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 374
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,24,self._ctx)
                if la_ == 1:
                    self.state = 372
                    self.variable()
                    pass

                elif la_ == 2:
                    self.state = 373
                    self.indexedeventarg()
                    pass


                self.state = 378 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==65):
                    break

            self.state = 380
            self.match(VyperParser.DEDENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EventdefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EVENTDECL(self):
            return self.getToken(VyperParser.EVENTDECL, 0)

        def NAME(self):
            return self.getToken(VyperParser.NAME, 0)

        def COLON(self):
            return self.getToken(VyperParser.COLON, 0)

        def eventbody(self):
            return self.getTypedRuleContext(VyperParser.EventbodyContext,0)


        def PASS(self):
            return self.getToken(VyperParser.PASS, 0)

        def getRuleIndex(self):
            return VyperParser.RULE_eventdef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEventdef" ):
                listener.enterEventdef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEventdef" ):
                listener.exitEventdef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEventdef" ):
                return visitor.visitEventdef(self)
            else:
                return visitor.visitChildren(self)




    def eventdef(self):

        localctx = VyperParser.EventdefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_eventdef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 382
            self.match(VyperParser.EVENTDECL)
            self.state = 383
            self.match(VyperParser.NAME)
            self.state = 384
            self.match(VyperParser.COLON)
            self.state = 387
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [77]:
                self.state = 385
                self.eventbody()
                pass
            elif token in [35]:
                self.state = 386
                self.match(VyperParser.PASS)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EnummemberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NAME(self):
            return self.getToken(VyperParser.NAME, 0)

        def getRuleIndex(self):
            return VyperParser.RULE_enummember

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnummember" ):
                listener.enterEnummember(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnummember" ):
                listener.exitEnummember(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnummember" ):
                return visitor.visitEnummember(self)
            else:
                return visitor.visitChildren(self)




    def enummember(self):

        localctx = VyperParser.EnummemberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_enummember)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 389
            self.match(VyperParser.NAME)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EnumbodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(VyperParser.NEWLINE)
            else:
                return self.getToken(VyperParser.NEWLINE, i)

        def INDENT(self):
            return self.getToken(VyperParser.INDENT, 0)

        def DEDENT(self):
            return self.getToken(VyperParser.DEDENT, 0)

        def enummember(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VyperParser.EnummemberContext)
            else:
                return self.getTypedRuleContext(VyperParser.EnummemberContext,i)


        def getRuleIndex(self):
            return VyperParser.RULE_enumbody

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumbody" ):
                listener.enterEnumbody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumbody" ):
                listener.exitEnumbody(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumbody" ):
                return visitor.visitEnumbody(self)
            else:
                return visitor.visitChildren(self)




    def enumbody(self):

        localctx = VyperParser.EnumbodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_enumbody)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 391
            self.match(VyperParser.NEWLINE)
            self.state = 392
            self.match(VyperParser.INDENT)
            self.state = 396 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 393
                self.enummember()
                self.state = 394
                self.match(VyperParser.NEWLINE)
                self.state = 398 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==65):
                    break

            self.state = 400
            self.match(VyperParser.DEDENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EnumdefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ENUMDECL(self):
            return self.getToken(VyperParser.ENUMDECL, 0)

        def NAME(self):
            return self.getToken(VyperParser.NAME, 0)

        def COLON(self):
            return self.getToken(VyperParser.COLON, 0)

        def enumbody(self):
            return self.getTypedRuleContext(VyperParser.EnumbodyContext,0)


        def getRuleIndex(self):
            return VyperParser.RULE_enumdef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnumdef" ):
                listener.enterEnumdef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnumdef" ):
                listener.exitEnumdef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnumdef" ):
                return visitor.visitEnumdef(self)
            else:
                return visitor.visitChildren(self)




    def enumdef(self):

        localctx = VyperParser.EnumdefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_enumdef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 402
            self.match(VyperParser.ENUMDECL)
            self.state = 403
            self.match(VyperParser.NAME)
            self.state = 404
            self.match(VyperParser.COLON)
            self.state = 405
            self.enumbody()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArraydefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def simple_arraydef(self):
            return self.getTypedRuleContext(VyperParser.Simple_arraydefContext,0)


        def dynarraydef(self):
            return self.getTypedRuleContext(VyperParser.DynarraydefContext,0)


        def getRuleIndex(self):
            return VyperParser.RULE_arraydef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArraydef" ):
                listener.enterArraydef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArraydef" ):
                listener.exitArraydef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArraydef" ):
                return visitor.visitArraydef(self)
            else:
                return visitor.visitChildren(self)




    def arraydef(self):

        localctx = VyperParser.ArraydefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_arraydef)
        try:
            self.state = 409
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [65]:
                self.enterOuterAlt(localctx, 1)
                self.state = 407
                self.simple_arraydef()
                pass
            elif token in [18]:
                self.enterOuterAlt(localctx, 2)
                self.state = 408
                self.dynarraydef()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Simple_arraydefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NAME(self):
            return self.getToken(VyperParser.NAME, 0)

        def index(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VyperParser.IndexContext)
            else:
                return self.getTypedRuleContext(VyperParser.IndexContext,i)


        def getRuleIndex(self):
            return VyperParser.RULE_simple_arraydef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimple_arraydef" ):
                listener.enterSimple_arraydef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimple_arraydef" ):
                listener.exitSimple_arraydef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimple_arraydef" ):
                return visitor.visitSimple_arraydef(self)
            else:
                return visitor.visitChildren(self)




    def simple_arraydef(self):

        localctx = VyperParser.Simple_arraydefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_simple_arraydef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 411
            self.match(VyperParser.NAME)
            self.state = 415
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,29,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 412
                    self.index() 
                self.state = 417
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,29,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DynarraydefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DynArray(self):
            return self.getToken(VyperParser.DynArray, 0)

        def dynindex(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VyperParser.DynindexContext)
            else:
                return self.getTypedRuleContext(VyperParser.DynindexContext,i)


        def getRuleIndex(self):
            return VyperParser.RULE_dynarraydef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDynarraydef" ):
                listener.enterDynarraydef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDynarraydef" ):
                listener.exitDynarraydef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDynarraydef" ):
                return visitor.visitDynarraydef(self)
            else:
                return visitor.visitChildren(self)




    def dynarraydef(self):

        localctx = VyperParser.DynarraydefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_dynarraydef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 418
            self.match(VyperParser.DynArray)
            self.state = 420 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 419
                    self.dynindex()

                else:
                    raise NoViableAltException(self)
                self.state = 422 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,30,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IndexContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RSquare(self):
            return self.getToken(VyperParser.RSquare, 0)

        def LSquare(self):
            return self.getToken(VyperParser.LSquare, 0)

        def DECNUMBER(self):
            return self.getToken(VyperParser.DECNUMBER, 0)

        def NAME(self):
            return self.getToken(VyperParser.NAME, 0)

        def getRuleIndex(self):
            return VyperParser.RULE_index

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndex" ):
                listener.enterIndex(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndex" ):
                listener.exitIndex(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIndex" ):
                return visitor.visitIndex(self)
            else:
                return visitor.visitChildren(self)




    def index(self):

        localctx = VyperParser.IndexContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_index)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 424
            self.match(VyperParser.RSquare)
            self.state = 425
            _la = self._input.LA(1)
            if not(_la==65 or _la==68):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 426
            self.match(VyperParser.LSquare)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DynindexContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RSquare(self):
            return self.getToken(VyperParser.RSquare, 0)

        def COMMA(self):
            return self.getToken(VyperParser.COMMA, 0)

        def LSquare(self):
            return self.getToken(VyperParser.LSquare, 0)

        def DECNUMBER(self):
            return self.getToken(VyperParser.DECNUMBER, 0)

        def NAME(self, i:int=None):
            if i is None:
                return self.getTokens(VyperParser.NAME)
            else:
                return self.getToken(VyperParser.NAME, i)

        def simple_arraydef(self):
            return self.getTypedRuleContext(VyperParser.Simple_arraydefContext,0)


        def dynarraydef(self):
            return self.getTypedRuleContext(VyperParser.DynarraydefContext,0)


        def getRuleIndex(self):
            return VyperParser.RULE_dynindex

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDynindex" ):
                listener.enterDynindex(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDynindex" ):
                listener.exitDynindex(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDynindex" ):
                return visitor.visitDynindex(self)
            else:
                return visitor.visitChildren(self)




    def dynindex(self):

        localctx = VyperParser.DynindexContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_dynindex)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 428
            self.match(VyperParser.RSquare)
            self.state = 432
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,31,self._ctx)
            if la_ == 1:
                self.state = 429
                self.match(VyperParser.NAME)
                pass

            elif la_ == 2:
                self.state = 430
                self.simple_arraydef()
                pass

            elif la_ == 3:
                self.state = 431
                self.dynarraydef()
                pass


            self.state = 434
            self.match(VyperParser.COMMA)
            self.state = 435
            _la = self._input.LA(1)
            if not(_la==65 or _la==68):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 436
            self.match(VyperParser.LSquare)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TupledefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LParen(self):
            return self.getToken(VyperParser.LParen, 0)

        def RParen(self):
            return self.getToken(VyperParser.RParen, 0)

        def NAME(self, i:int=None):
            if i is None:
                return self.getTokens(VyperParser.NAME)
            else:
                return self.getToken(VyperParser.NAME, i)

        def arraydef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VyperParser.ArraydefContext)
            else:
                return self.getTypedRuleContext(VyperParser.ArraydefContext,i)


        def dynarraydef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VyperParser.DynarraydefContext)
            else:
                return self.getTypedRuleContext(VyperParser.DynarraydefContext,i)


        def tupledef(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VyperParser.TupledefContext)
            else:
                return self.getTypedRuleContext(VyperParser.TupledefContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(VyperParser.COMMA)
            else:
                return self.getToken(VyperParser.COMMA, i)

        def getRuleIndex(self):
            return VyperParser.RULE_tupledef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTupledef" ):
                listener.enterTupledef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTupledef" ):
                listener.exitTupledef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTupledef" ):
                return visitor.visitTupledef(self)
            else:
                return visitor.visitChildren(self)




    def tupledef(self):

        localctx = VyperParser.TupledefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_tupledef)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 438
            self.match(VyperParser.LParen)
            self.state = 443
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,32,self._ctx)
            if la_ == 1:
                self.state = 439
                self.match(VyperParser.NAME)
                pass

            elif la_ == 2:
                self.state = 440
                self.arraydef()
                pass

            elif la_ == 3:
                self.state = 441
                self.dynarraydef()
                pass

            elif la_ == 4:
                self.state = 442
                self.tupledef()
                pass


            self.state = 454
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,34,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 445
                    self.match(VyperParser.COMMA)
                    self.state = 450
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,33,self._ctx)
                    if la_ == 1:
                        self.state = 446
                        self.match(VyperParser.NAME)
                        pass

                    elif la_ == 2:
                        self.state = 447
                        self.arraydef()
                        pass

                    elif la_ == 3:
                        self.state = 448
                        self.dynarraydef()
                        pass

                    elif la_ == 4:
                        self.state = 449
                        self.tupledef()
                        pass

             
                self.state = 456
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,34,self._ctx)

            self.state = 458
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==5:
                self.state = 457
                self.match(VyperParser.COMMA)


            self.state = 460
            self.match(VyperParser.RParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MapdefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MAP(self):
            return self.getToken(VyperParser.MAP, 0)

        def RSquare(self):
            return self.getToken(VyperParser.RSquare, 0)

        def COMMA(self):
            return self.getToken(VyperParser.COMMA, 0)

        def type_(self):
            return self.getTypedRuleContext(VyperParser.Type_Context,0)


        def LSquare(self):
            return self.getToken(VyperParser.LSquare, 0)

        def NAME(self):
            return self.getToken(VyperParser.NAME, 0)

        def arraydef(self):
            return self.getTypedRuleContext(VyperParser.ArraydefContext,0)


        def getRuleIndex(self):
            return VyperParser.RULE_mapdef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMapdef" ):
                listener.enterMapdef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMapdef" ):
                listener.exitMapdef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMapdef" ):
                return visitor.visitMapdef(self)
            else:
                return visitor.visitChildren(self)




    def mapdef(self):

        localctx = VyperParser.MapdefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_mapdef)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 462
            self.match(VyperParser.MAP)
            self.state = 463
            self.match(VyperParser.RSquare)
            self.state = 466
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,36,self._ctx)
            if la_ == 1:
                self.state = 464
                self.match(VyperParser.NAME)
                pass

            elif la_ == 2:
                self.state = 465
                self.arraydef()
                pass


            self.state = 468
            self.match(VyperParser.COMMA)
            self.state = 469
            self.type_()
            self.state = 470
            self.match(VyperParser.LSquare)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Type_Context(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NAME(self):
            return self.getToken(VyperParser.NAME, 0)

        def arraydef(self):
            return self.getTypedRuleContext(VyperParser.ArraydefContext,0)


        def tupledef(self):
            return self.getTypedRuleContext(VyperParser.TupledefContext,0)


        def mapdef(self):
            return self.getTypedRuleContext(VyperParser.MapdefContext,0)


        def dynarraydef(self):
            return self.getTypedRuleContext(VyperParser.DynarraydefContext,0)


        def getRuleIndex(self):
            return VyperParser.RULE_type_

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterType_" ):
                listener.enterType_(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitType_" ):
                listener.exitType_(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitType_" ):
                return visitor.visitType_(self)
            else:
                return visitor.visitChildren(self)




    def type_(self):

        localctx = VyperParser.Type_Context(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_type_)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 477
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,37,self._ctx)
            if la_ == 1:
                self.state = 472
                self.match(VyperParser.NAME)
                pass

            elif la_ == 2:
                self.state = 473
                self.arraydef()
                pass

            elif la_ == 3:
                self.state = 474
                self.tupledef()
                pass

            elif la_ == 4:
                self.state = 475
                self.mapdef()
                pass

            elif la_ == 5:
                self.state = 476
                self.dynarraydef()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StructmemberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NAME(self):
            return self.getToken(VyperParser.NAME, 0)

        def COLON(self):
            return self.getToken(VyperParser.COLON, 0)

        def type_(self):
            return self.getTypedRuleContext(VyperParser.Type_Context,0)


        def getRuleIndex(self):
            return VyperParser.RULE_structmember

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStructmember" ):
                listener.enterStructmember(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStructmember" ):
                listener.exitStructmember(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStructmember" ):
                return visitor.visitStructmember(self)
            else:
                return visitor.visitChildren(self)




    def structmember(self):

        localctx = VyperParser.StructmemberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_structmember)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 479
            self.match(VyperParser.NAME)
            self.state = 480
            self.match(VyperParser.COLON)
            self.state = 481
            self.type_()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StructdefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRUCTDECL(self):
            return self.getToken(VyperParser.STRUCTDECL, 0)

        def NAME(self):
            return self.getToken(VyperParser.NAME, 0)

        def COLON(self):
            return self.getToken(VyperParser.COLON, 0)

        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(VyperParser.NEWLINE)
            else:
                return self.getToken(VyperParser.NEWLINE, i)

        def INDENT(self):
            return self.getToken(VyperParser.INDENT, 0)

        def DEDENT(self):
            return self.getToken(VyperParser.DEDENT, 0)

        def structmember(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VyperParser.StructmemberContext)
            else:
                return self.getTypedRuleContext(VyperParser.StructmemberContext,i)


        def getRuleIndex(self):
            return VyperParser.RULE_structdef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStructdef" ):
                listener.enterStructdef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStructdef" ):
                listener.exitStructdef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStructdef" ):
                return visitor.visitStructdef(self)
            else:
                return visitor.visitChildren(self)




    def structdef(self):

        localctx = VyperParser.StructdefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_structdef)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 483
            self.match(VyperParser.STRUCTDECL)
            self.state = 484
            self.match(VyperParser.NAME)
            self.state = 485
            self.match(VyperParser.COLON)
            self.state = 486
            self.match(VyperParser.NEWLINE)
            self.state = 487
            self.match(VyperParser.INDENT)
            self.state = 491 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 488
                self.structmember()
                self.state = 489
                self.match(VyperParser.NEWLINE)
                self.state = 493 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==65):
                    break

            self.state = 495
            self.match(VyperParser.DEDENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MutabilityContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NAME(self):
            return self.getToken(VyperParser.NAME, 0)

        def getRuleIndex(self):
            return VyperParser.RULE_mutability

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMutability" ):
                listener.enterMutability(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMutability" ):
                listener.exitMutability(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMutability" ):
                return visitor.visitMutability(self)
            else:
                return visitor.visitChildren(self)




    def mutability(self):

        localctx = VyperParser.MutabilityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_mutability)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 497
            self.match(VyperParser.NAME)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InterfacefunctionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def functionsig(self):
            return self.getTypedRuleContext(VyperParser.FunctionsigContext,0)


        def COLON(self):
            return self.getToken(VyperParser.COLON, 0)

        def mutability(self):
            return self.getTypedRuleContext(VyperParser.MutabilityContext,0)


        def getRuleIndex(self):
            return VyperParser.RULE_interfacefunction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInterfacefunction" ):
                listener.enterInterfacefunction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInterfacefunction" ):
                listener.exitInterfacefunction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInterfacefunction" ):
                return visitor.visitInterfacefunction(self)
            else:
                return visitor.visitChildren(self)




    def interfacefunction(self):

        localctx = VyperParser.InterfacefunctionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_interfacefunction)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 499
            self.functionsig()
            self.state = 500
            self.match(VyperParser.COLON)
            self.state = 501
            self.mutability()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InterfacedefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTERFACEDECL(self):
            return self.getToken(VyperParser.INTERFACEDECL, 0)

        def NAME(self):
            return self.getToken(VyperParser.NAME, 0)

        def COLON(self):
            return self.getToken(VyperParser.COLON, 0)

        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(VyperParser.NEWLINE)
            else:
                return self.getToken(VyperParser.NEWLINE, i)

        def INDENT(self):
            return self.getToken(VyperParser.INDENT, 0)

        def DEDENT(self):
            return self.getToken(VyperParser.DEDENT, 0)

        def interfacefunction(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VyperParser.InterfacefunctionContext)
            else:
                return self.getTypedRuleContext(VyperParser.InterfacefunctionContext,i)


        def getRuleIndex(self):
            return VyperParser.RULE_interfacedef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInterfacedef" ):
                listener.enterInterfacedef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInterfacedef" ):
                listener.exitInterfacedef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInterfacedef" ):
                return visitor.visitInterfacedef(self)
            else:
                return visitor.visitChildren(self)




    def interfacedef(self):

        localctx = VyperParser.InterfacedefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_interfacedef)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 503
            self.match(VyperParser.INTERFACEDECL)
            self.state = 504
            self.match(VyperParser.NAME)
            self.state = 505
            self.match(VyperParser.COLON)
            self.state = 506
            self.match(VyperParser.NEWLINE)
            self.state = 507
            self.match(VyperParser.INDENT)
            self.state = 511 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 508
                self.interfacefunction()
                self.state = 509
                self.match(VyperParser.NEWLINE)
                self.state = 513 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==19):
                    break

            self.state = 515
            self.match(VyperParser.DEDENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ifstmt(self):
            return self.getTypedRuleContext(VyperParser.IfstmtContext,0)


        def forstmt(self):
            return self.getTypedRuleContext(VyperParser.ForstmtContext,0)


        def COMMENT(self):
            return self.getToken(VyperParser.COMMENT, 0)

        def declaration(self):
            return self.getTypedRuleContext(VyperParser.DeclarationContext,0)


        def assign(self):
            return self.getTypedRuleContext(VyperParser.AssignContext,0)


        def augassign(self):
            return self.getTypedRuleContext(VyperParser.AugassignContext,0)


        def returnstmt(self):
            return self.getTypedRuleContext(VyperParser.ReturnstmtContext,0)


        def passstmt(self):
            return self.getTypedRuleContext(VyperParser.PassstmtContext,0)


        def breakstmt(self):
            return self.getTypedRuleContext(VyperParser.BreakstmtContext,0)


        def continuestmt(self):
            return self.getTypedRuleContext(VyperParser.ContinuestmtContext,0)


        def logstmt(self):
            return self.getTypedRuleContext(VyperParser.LogstmtContext,0)


        def raisestmt(self):
            return self.getTypedRuleContext(VyperParser.RaisestmtContext,0)


        def assertstmt(self):
            return self.getTypedRuleContext(VyperParser.AssertstmtContext,0)


        def expr(self):
            return self.getTypedRuleContext(VyperParser.ExprContext,0)


        def getRuleIndex(self):
            return VyperParser.RULE_stmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStmt" ):
                listener.enterStmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStmt" ):
                listener.exitStmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStmt" ):
                return visitor.visitStmt(self)
            else:
                return visitor.visitChildren(self)




    def stmt(self):

        localctx = VyperParser.StmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_stmt)
        try:
            self.state = 540
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [42, 46]:
                self.enterOuterAlt(localctx, 1)
                self.state = 519
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [42]:
                    self.state = 517
                    self.ifstmt()
                    pass
                elif token in [46]:
                    self.state = 518
                    self.forstmt()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 522
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,41,self._ctx)
                if la_ == 1:
                    self.state = 521
                    self.match(VyperParser.COMMENT)


                pass
            elif token in [7, 16, 26, 27, 28, 35, 36, 37, 38, 39, 40, 41, 48, 52, 53, 63, 64, 65, 67, 68, 69, 70, 71, 72, 73]:
                self.enterOuterAlt(localctx, 2)
                self.state = 535
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,42,self._ctx)
                if la_ == 1:
                    self.state = 524
                    self.declaration()
                    pass

                elif la_ == 2:
                    self.state = 525
                    self.assign()
                    pass

                elif la_ == 3:
                    self.state = 526
                    self.augassign()
                    pass

                elif la_ == 4:
                    self.state = 527
                    self.returnstmt()
                    pass

                elif la_ == 5:
                    self.state = 528
                    self.passstmt()
                    pass

                elif la_ == 6:
                    self.state = 529
                    self.breakstmt()
                    pass

                elif la_ == 7:
                    self.state = 530
                    self.continuestmt()
                    pass

                elif la_ == 8:
                    self.state = 531
                    self.logstmt()
                    pass

                elif la_ == 9:
                    self.state = 532
                    self.raisestmt()
                    pass

                elif la_ == 10:
                    self.state = 533
                    self.assertstmt()
                    pass

                elif la_ == 11:
                    self.state = 534
                    self.expr()
                    pass


                self.state = 538
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,43,self._ctx)
                if la_ == 1:
                    self.state = 537
                    self.match(VyperParser.COMMENT)


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variable(self):
            return self.getTypedRuleContext(VyperParser.VariableContext,0)


        def EQUALITY(self):
            return self.getToken(VyperParser.EQUALITY, 0)

        def expr(self):
            return self.getTypedRuleContext(VyperParser.ExprContext,0)


        def getRuleIndex(self):
            return VyperParser.RULE_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeclaration" ):
                listener.enterDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeclaration" ):
                listener.exitDeclaration(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeclaration" ):
                return visitor.visitDeclaration(self)
            else:
                return visitor.visitChildren(self)




    def declaration(self):

        localctx = VyperParser.DeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_declaration)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 542
            self.variable()
            self.state = 545
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==11:
                self.state = 543
                self.match(VyperParser.EQUALITY)
                self.state = 544
                self.expr()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MultipleassignContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variableaccess(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VyperParser.VariableaccessContext)
            else:
                return self.getTypedRuleContext(VyperParser.VariableaccessContext,i)


        def SkipAssign(self, i:int=None):
            if i is None:
                return self.getTokens(VyperParser.SkipAssign)
            else:
                return self.getToken(VyperParser.SkipAssign, i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(VyperParser.COMMA)
            else:
                return self.getToken(VyperParser.COMMA, i)

        def getRuleIndex(self):
            return VyperParser.RULE_multipleassign

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMultipleassign" ):
                listener.enterMultipleassign(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMultipleassign" ):
                listener.exitMultipleassign(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMultipleassign" ):
                return visitor.visitMultipleassign(self)
            else:
                return visitor.visitChildren(self)




    def multipleassign(self):

        localctx = VyperParser.MultipleassignContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_multipleassign)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 549
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [7, 65]:
                self.state = 547
                self.variableaccess()
                pass
            elif token in [26]:
                self.state = 548
                self.match(VyperParser.SkipAssign)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 556 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 551
                self.match(VyperParser.COMMA)
                self.state = 554
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [7, 65]:
                    self.state = 552
                    self.variableaccess()
                    pass
                elif token in [26]:
                    self.state = 553
                    self.match(VyperParser.SkipAssign)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 558 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==5):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssignContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQUALITY(self):
            return self.getToken(VyperParser.EQUALITY, 0)

        def expr(self):
            return self.getTypedRuleContext(VyperParser.ExprContext,0)


        def variableaccess(self):
            return self.getTypedRuleContext(VyperParser.VariableaccessContext,0)


        def multipleassign(self):
            return self.getTypedRuleContext(VyperParser.MultipleassignContext,0)


        def LParen(self):
            return self.getToken(VyperParser.LParen, 0)

        def RParen(self):
            return self.getToken(VyperParser.RParen, 0)

        def getRuleIndex(self):
            return VyperParser.RULE_assign

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign" ):
                listener.enterAssign(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign" ):
                listener.exitAssign(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssign" ):
                return visitor.visitAssign(self)
            else:
                return visitor.visitChildren(self)




    def assign(self):

        localctx = VyperParser.AssignContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_assign)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 566
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,49,self._ctx)
            if la_ == 1:
                self.state = 560
                self.variableaccess()
                pass

            elif la_ == 2:
                self.state = 561
                self.multipleassign()
                pass

            elif la_ == 3:
                self.state = 562
                self.match(VyperParser.LParen)
                self.state = 563
                self.multipleassign()
                self.state = 564
                self.match(VyperParser.RParen)
                pass


            self.state = 568
            self.match(VyperParser.EQUALITY)
            self.state = 569
            self.expr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AugoperatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ADD(self):
            return self.getToken(VyperParser.ADD, 0)

        def SUB(self):
            return self.getToken(VyperParser.SUB, 0)

        def MUL(self):
            return self.getToken(VyperParser.MUL, 0)

        def DIV(self):
            return self.getToken(VyperParser.DIV, 0)

        def MOD(self):
            return self.getToken(VyperParser.MOD, 0)

        def POW(self):
            return self.getToken(VyperParser.POW, 0)

        def SHL(self):
            return self.getToken(VyperParser.SHL, 0)

        def SHR(self):
            return self.getToken(VyperParser.SHR, 0)

        def BITAND(self):
            return self.getToken(VyperParser.BITAND, 0)

        def BITOR(self):
            return self.getToken(VyperParser.BITOR, 0)

        def BITXOR(self):
            return self.getToken(VyperParser.BITXOR, 0)

        def AND(self):
            return self.getToken(VyperParser.AND, 0)

        def OR(self):
            return self.getToken(VyperParser.OR, 0)

        def getRuleIndex(self):
            return VyperParser.RULE_augoperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAugoperator" ):
                listener.enterAugoperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAugoperator" ):
                listener.exitAugoperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAugoperator" ):
                return visitor.visitAugoperator(self)
            else:
                return visitor.visitChildren(self)




    def augoperator(self):

        localctx = VyperParser.AugoperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_augoperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 571
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 129478523512422400) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AugassignContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variableaccess(self):
            return self.getTypedRuleContext(VyperParser.VariableaccessContext,0)


        def augoperator(self):
            return self.getTypedRuleContext(VyperParser.AugoperatorContext,0)


        def EQUALITY(self):
            return self.getToken(VyperParser.EQUALITY, 0)

        def expr(self):
            return self.getTypedRuleContext(VyperParser.ExprContext,0)


        def getRuleIndex(self):
            return VyperParser.RULE_augassign

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAugassign" ):
                listener.enterAugassign(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAugassign" ):
                listener.exitAugassign(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAugassign" ):
                return visitor.visitAugassign(self)
            else:
                return visitor.visitChildren(self)




    def augassign(self):

        localctx = VyperParser.AugassignContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_augassign)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 573
            self.variableaccess()
            self.state = 574
            self.augoperator()
            self.state = 575
            self.match(VyperParser.EQUALITY)
            self.state = 576
            self.expr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PassstmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PASS(self):
            return self.getToken(VyperParser.PASS, 0)

        def getRuleIndex(self):
            return VyperParser.RULE_passstmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPassstmt" ):
                listener.enterPassstmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPassstmt" ):
                listener.exitPassstmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPassstmt" ):
                return visitor.visitPassstmt(self)
            else:
                return visitor.visitChildren(self)




    def passstmt(self):

        localctx = VyperParser.PassstmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_passstmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 578
            self.match(VyperParser.PASS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BreakstmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Break(self):
            return self.getToken(VyperParser.Break, 0)

        def getRuleIndex(self):
            return VyperParser.RULE_breakstmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBreakstmt" ):
                listener.enterBreakstmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBreakstmt" ):
                listener.exitBreakstmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBreakstmt" ):
                return visitor.visitBreakstmt(self)
            else:
                return visitor.visitChildren(self)




    def breakstmt(self):

        localctx = VyperParser.BreakstmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_breakstmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 580
            self.match(VyperParser.Break)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ContinuestmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CONTINUE(self):
            return self.getToken(VyperParser.CONTINUE, 0)

        def getRuleIndex(self):
            return VyperParser.RULE_continuestmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterContinuestmt" ):
                listener.enterContinuestmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitContinuestmt" ):
                listener.exitContinuestmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitContinuestmt" ):
                return visitor.visitContinuestmt(self)
            else:
                return visitor.visitChildren(self)




    def continuestmt(self):

        localctx = VyperParser.ContinuestmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_continuestmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 582
            self.match(VyperParser.CONTINUE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LogstmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LOG(self):
            return self.getToken(VyperParser.LOG, 0)

        def NAME(self):
            return self.getToken(VyperParser.NAME, 0)

        def LParen(self):
            return self.getToken(VyperParser.LParen, 0)

        def RParen(self):
            return self.getToken(VyperParser.RParen, 0)

        def arguments(self):
            return self.getTypedRuleContext(VyperParser.ArgumentsContext,0)


        def getRuleIndex(self):
            return VyperParser.RULE_logstmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLogstmt" ):
                listener.enterLogstmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLogstmt" ):
                listener.exitLogstmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLogstmt" ):
                return visitor.visitLogstmt(self)
            else:
                return visitor.visitChildren(self)




    def logstmt(self):

        localctx = VyperParser.LogstmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_logstmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 584
            self.match(VyperParser.LOG)
            self.state = 585
            self.match(VyperParser.NAME)
            self.state = 586
            self.match(VyperParser.LParen)
            self.state = 588
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & -9209579762593234816) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & 1019) != 0):
                self.state = 587
                self.arguments()


            self.state = 590
            self.match(VyperParser.RParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ReturnstmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RETURN(self):
            return self.getToken(VyperParser.RETURN, 0)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VyperParser.ExprContext)
            else:
                return self.getTypedRuleContext(VyperParser.ExprContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(VyperParser.COMMA)
            else:
                return self.getToken(VyperParser.COMMA, i)

        def getRuleIndex(self):
            return VyperParser.RULE_returnstmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReturnstmt" ):
                listener.enterReturnstmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReturnstmt" ):
                listener.exitReturnstmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReturnstmt" ):
                return visitor.visitReturnstmt(self)
            else:
                return visitor.visitChildren(self)




    def returnstmt(self):

        localctx = VyperParser.ReturnstmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_returnstmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 592
            self.match(VyperParser.RETURN)
            self.state = 601
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,52,self._ctx)
            if la_ == 1:
                self.state = 593
                self.expr()
                self.state = 598
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==5:
                    self.state = 594
                    self.match(VyperParser.COMMA)
                    self.state = 595
                    self.expr()
                    self.state = 600
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RaisestmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RAISE(self):
            return self.getToken(VyperParser.RAISE, 0)

        def expr(self):
            return self.getTypedRuleContext(VyperParser.ExprContext,0)


        def UNREACHABLE(self):
            return self.getToken(VyperParser.UNREACHABLE, 0)

        def getRuleIndex(self):
            return VyperParser.RULE_raisestmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRaisestmt" ):
                listener.enterRaisestmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRaisestmt" ):
                listener.exitRaisestmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRaisestmt" ):
                return visitor.visitRaisestmt(self)
            else:
                return visitor.visitChildren(self)




    def raisestmt(self):

        localctx = VyperParser.RaisestmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_raisestmt)
        try:
            self.state = 608
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,53,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 603
                self.match(VyperParser.RAISE)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 604
                self.match(VyperParser.RAISE)
                self.state = 605
                self.expr()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 606
                self.match(VyperParser.RAISE)
                self.state = 607
                self.match(VyperParser.UNREACHABLE)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssertstmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ASSERT(self):
            return self.getToken(VyperParser.ASSERT, 0)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VyperParser.ExprContext)
            else:
                return self.getTypedRuleContext(VyperParser.ExprContext,i)


        def COMMA(self):
            return self.getToken(VyperParser.COMMA, 0)

        def UNREACHABLE(self):
            return self.getToken(VyperParser.UNREACHABLE, 0)

        def getRuleIndex(self):
            return VyperParser.RULE_assertstmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssertstmt" ):
                listener.enterAssertstmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssertstmt" ):
                listener.exitAssertstmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssertstmt" ):
                return visitor.visitAssertstmt(self)
            else:
                return visitor.visitChildren(self)




    def assertstmt(self):

        localctx = VyperParser.AssertstmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_assertstmt)
        try:
            self.state = 622
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,54,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 610
                self.match(VyperParser.ASSERT)
                self.state = 611
                self.expr()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 612
                self.match(VyperParser.ASSERT)
                self.state = 613
                self.expr()
                self.state = 614
                self.match(VyperParser.COMMA)
                self.state = 615
                self.expr()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 617
                self.match(VyperParser.ASSERT)
                self.state = 618
                self.expr()
                self.state = 619
                self.match(VyperParser.COMMA)
                self.state = 620
                self.match(VyperParser.UNREACHABLE)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COMMENT(self, i:int=None):
            if i is None:
                return self.getTokens(VyperParser.COMMENT)
            else:
                return self.getToken(VyperParser.COMMENT, i)

        def stmt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VyperParser.StmtContext)
            else:
                return self.getTypedRuleContext(VyperParser.StmtContext,i)


        def NEWLINE(self, i:int=None):
            if i is None:
                return self.getTokens(VyperParser.NEWLINE)
            else:
                return self.getToken(VyperParser.NEWLINE, i)

        def getRuleIndex(self):
            return VyperParser.RULE_body

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBody" ):
                listener.enterBody(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBody" ):
                listener.exitBody(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBody" ):
                return visitor.visitBody(self)
            else:
                return visitor.visitChildren(self)




    def body(self):

        localctx = VyperParser.BodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_body)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 629 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 629
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [76]:
                        self.state = 624
                        self.match(VyperParser.COMMENT)
                        pass
                    elif token in [7, 16, 26, 27, 28, 35, 36, 37, 38, 39, 40, 41, 42, 46, 48, 52, 53, 63, 64, 65, 67, 68, 69, 70, 71, 72, 73]:
                        self.state = 625
                        self.stmt()
                        self.state = 627
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,55,self._ctx)
                        if la_ == 1:
                            self.state = 626
                            self.match(VyperParser.NEWLINE)


                        pass
                    else:
                        raise NoViableAltException(self)


                else:
                    raise NoViableAltException(self)
                self.state = 631 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,57,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CondexecContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self):
            return self.getTypedRuleContext(VyperParser.ExprContext,0)


        def COLON(self):
            return self.getToken(VyperParser.COLON, 0)

        def body(self):
            return self.getTypedRuleContext(VyperParser.BodyContext,0)


        def getRuleIndex(self):
            return VyperParser.RULE_condexec

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCondexec" ):
                listener.enterCondexec(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCondexec" ):
                listener.exitCondexec(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCondexec" ):
                return visitor.visitCondexec(self)
            else:
                return visitor.visitChildren(self)




    def condexec(self):

        localctx = VyperParser.CondexecContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_condexec)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 633
            self.expr()
            self.state = 634
            self.match(VyperParser.COLON)
            self.state = 635
            self.body()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DefaultexecContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def body(self):
            return self.getTypedRuleContext(VyperParser.BodyContext,0)


        def getRuleIndex(self):
            return VyperParser.RULE_defaultexec

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefaultexec" ):
                listener.enterDefaultexec(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefaultexec" ):
                listener.exitDefaultexec(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefaultexec" ):
                return visitor.visitDefaultexec(self)
            else:
                return visitor.visitChildren(self)




    def defaultexec(self):

        localctx = VyperParser.DefaultexecContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_defaultexec)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 637
            self.body()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfstmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def If(self):
            return self.getToken(VyperParser.If, 0)

        def condexec(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VyperParser.CondexecContext)
            else:
                return self.getTypedRuleContext(VyperParser.CondexecContext,i)


        def Elif(self, i:int=None):
            if i is None:
                return self.getTokens(VyperParser.Elif)
            else:
                return self.getToken(VyperParser.Elif, i)

        def Else(self):
            return self.getToken(VyperParser.Else, 0)

        def COLON(self):
            return self.getToken(VyperParser.COLON, 0)

        def defaultexec(self):
            return self.getTypedRuleContext(VyperParser.DefaultexecContext,0)


        def getRuleIndex(self):
            return VyperParser.RULE_ifstmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfstmt" ):
                listener.enterIfstmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfstmt" ):
                listener.exitIfstmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIfstmt" ):
                return visitor.visitIfstmt(self)
            else:
                return visitor.visitChildren(self)




    def ifstmt(self):

        localctx = VyperParser.IfstmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_ifstmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 639
            self.match(VyperParser.If)
            self.state = 640
            self.condexec()
            self.state = 645
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,58,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 641
                    self.match(VyperParser.Elif)
                    self.state = 642
                    self.condexec() 
                self.state = 647
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,58,self._ctx)

            self.state = 651
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,59,self._ctx)
            if la_ == 1:
                self.state = 648
                self.match(VyperParser.Else)
                self.state = 649
                self.match(VyperParser.COLON)
                self.state = 650
                self.defaultexec()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoopvariableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NAME(self, i:int=None):
            if i is None:
                return self.getTokens(VyperParser.NAME)
            else:
                return self.getToken(VyperParser.NAME, i)

        def COLON(self):
            return self.getToken(VyperParser.COLON, 0)

        def getRuleIndex(self):
            return VyperParser.RULE_loopvariable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoopvariable" ):
                listener.enterLoopvariable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoopvariable" ):
                listener.exitLoopvariable(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoopvariable" ):
                return visitor.visitLoopvariable(self)
            else:
                return visitor.visitChildren(self)




    def loopvariable(self):

        localctx = VyperParser.LoopvariableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_loopvariable)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 653
            self.match(VyperParser.NAME)
            self.state = 656
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==9:
                self.state = 654
                self.match(VyperParser.COLON)
                self.state = 655
                self.match(VyperParser.NAME)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LoopiteratorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self):
            return self.getTypedRuleContext(VyperParser.ExprContext,0)


        def getRuleIndex(self):
            return VyperParser.RULE_loopiterator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoopiterator" ):
                listener.enterLoopiterator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoopiterator" ):
                listener.exitLoopiterator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLoopiterator" ):
                return visitor.visitLoopiterator(self)
            else:
                return visitor.visitChildren(self)




    def loopiterator(self):

        localctx = VyperParser.LoopiteratorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_loopiterator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 658
            self.expr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ForstmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def For(self):
            return self.getToken(VyperParser.For, 0)

        def loopvariable(self):
            return self.getTypedRuleContext(VyperParser.LoopvariableContext,0)


        def In(self):
            return self.getToken(VyperParser.In, 0)

        def loopiterator(self):
            return self.getTypedRuleContext(VyperParser.LoopiteratorContext,0)


        def COLON(self):
            return self.getToken(VyperParser.COLON, 0)

        def body(self):
            return self.getTypedRuleContext(VyperParser.BodyContext,0)


        def getRuleIndex(self):
            return VyperParser.RULE_forstmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForstmt" ):
                listener.enterForstmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForstmt" ):
                listener.exitForstmt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitForstmt" ):
                return visitor.visitForstmt(self)
            else:
                return visitor.visitChildren(self)




    def forstmt(self):

        localctx = VyperParser.ForstmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_forstmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 660
            self.match(VyperParser.For)
            self.state = 661
            self.loopvariable()
            self.state = 662
            self.match(VyperParser.In)
            self.state = 663
            self.loopiterator()
            self.state = 664
            self.match(VyperParser.COLON)
            self.state = 665
            self.body()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def operation(self):
            return self.getTypedRuleContext(VyperParser.OperationContext,0)


        def dict_(self):
            return self.getTypedRuleContext(VyperParser.DictContext,0)


        def getRuleIndex(self):
            return VyperParser.RULE_expr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExpr" ):
                listener.enterExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExpr" ):
                listener.exitExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpr" ):
                return visitor.visitExpr(self)
            else:
                return visitor.visitChildren(self)




    def expr(self):

        localctx = VyperParser.ExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_expr)
        try:
            self.state = 669
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [7, 16, 27, 28, 52, 53, 63, 64, 65, 67, 68, 69, 70, 71, 72, 73]:
                self.enterOuterAlt(localctx, 1)
                self.state = 667
                self.operation()
                pass
            elif token in [48]:
                self.enterOuterAlt(localctx, 2)
                self.state = 668
                self.dict_()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VariableaccessContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NAME(self):
            return self.getToken(VyperParser.NAME, 0)

        def LParen(self):
            return self.getToken(VyperParser.LParen, 0)

        def variableaccess(self):
            return self.getTypedRuleContext(VyperParser.VariableaccessContext,0)


        def RParen(self):
            return self.getToken(VyperParser.RParen, 0)

        def getattr_(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VyperParser.GetattrContext)
            else:
                return self.getTypedRuleContext(VyperParser.GetattrContext,i)


        def getitem(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VyperParser.GetitemContext)
            else:
                return self.getTypedRuleContext(VyperParser.GetitemContext,i)


        def call(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VyperParser.CallContext)
            else:
                return self.getTypedRuleContext(VyperParser.CallContext,i)


        def getRuleIndex(self):
            return VyperParser.RULE_variableaccess

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVariableaccess" ):
                listener.enterVariableaccess(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVariableaccess" ):
                listener.exitVariableaccess(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVariableaccess" ):
                return visitor.visitVariableaccess(self)
            else:
                return visitor.visitChildren(self)




    def variableaccess(self):

        localctx = VyperParser.VariableaccessContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_variableaccess)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 676
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [65]:
                self.state = 671
                self.match(VyperParser.NAME)
                pass
            elif token in [7]:
                self.state = 672
                self.match(VyperParser.LParen)
                self.state = 673
                self.variableaccess()
                self.state = 674
                self.match(VyperParser.RParen)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 683
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,64,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 681
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [4]:
                        self.state = 678
                        self.getattr_()
                        pass
                    elif token in [16]:
                        self.state = 679
                        self.getitem()
                        pass
                    elif token in [7]:
                        self.state = 680
                        self.call()
                        pass
                    else:
                        raise NoViableAltException(self)
             
                self.state = 685
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,64,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GetattrContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DOT(self):
            return self.getToken(VyperParser.DOT, 0)

        def NAME(self):
            return self.getToken(VyperParser.NAME, 0)

        def getRuleIndex(self):
            return VyperParser.RULE_getattr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGetattr" ):
                listener.enterGetattr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGetattr" ):
                listener.exitGetattr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGetattr" ):
                return visitor.visitGetattr(self)
            else:
                return visitor.visitChildren(self)




    def getattr_(self):

        localctx = VyperParser.GetattrContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_getattr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 686
            self.match(VyperParser.DOT)
            self.state = 687
            self.match(VyperParser.NAME)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GetitemContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RSquare(self):
            return self.getToken(VyperParser.RSquare, 0)

        def expr(self):
            return self.getTypedRuleContext(VyperParser.ExprContext,0)


        def LSquare(self):
            return self.getToken(VyperParser.LSquare, 0)

        def getRuleIndex(self):
            return VyperParser.RULE_getitem

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGetitem" ):
                listener.enterGetitem(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGetitem" ):
                listener.exitGetitem(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGetitem" ):
                return visitor.visitGetitem(self)
            else:
                return visitor.visitChildren(self)




    def getitem(self):

        localctx = VyperParser.GetitemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_getitem)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 689
            self.match(VyperParser.RSquare)
            self.state = 690
            self.expr()
            self.state = 691
            self.match(VyperParser.LSquare)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CallContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LParen(self):
            return self.getToken(VyperParser.LParen, 0)

        def RParen(self):
            return self.getToken(VyperParser.RParen, 0)

        def arguments(self):
            return self.getTypedRuleContext(VyperParser.ArgumentsContext,0)


        def getRuleIndex(self):
            return VyperParser.RULE_call

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCall" ):
                listener.enterCall(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCall" ):
                listener.exitCall(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCall" ):
                return visitor.visitCall(self)
            else:
                return visitor.visitChildren(self)




    def call(self):

        localctx = VyperParser.CallContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_call)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 693
            self.match(VyperParser.LParen)

            self.state = 695
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & -9209579762593234816) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & 1019) != 0):
                self.state = 694
                self.arguments()


            self.state = 697
            self.match(VyperParser.RParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArgContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self):
            return self.getTypedRuleContext(VyperParser.ExprContext,0)


        def getRuleIndex(self):
            return VyperParser.RULE_arg

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArg" ):
                listener.enterArg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArg" ):
                listener.exitArg(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArg" ):
                return visitor.visitArg(self)
            else:
                return visitor.visitChildren(self)




    def arg(self):

        localctx = VyperParser.ArgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_arg)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 699
            self.expr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class KwargContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NAME(self):
            return self.getToken(VyperParser.NAME, 0)

        def EQUALITY(self):
            return self.getToken(VyperParser.EQUALITY, 0)

        def expr(self):
            return self.getTypedRuleContext(VyperParser.ExprContext,0)


        def getRuleIndex(self):
            return VyperParser.RULE_kwarg

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKwarg" ):
                listener.enterKwarg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKwarg" ):
                listener.exitKwarg(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitKwarg" ):
                return visitor.visitKwarg(self)
            else:
                return visitor.visitChildren(self)




    def kwarg(self):

        localctx = VyperParser.KwargContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_kwarg)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 701
            self.match(VyperParser.NAME)
            self.state = 702
            self.match(VyperParser.EQUALITY)
            self.state = 703
            self.expr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArgumentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def arg(self):
            return self.getTypedRuleContext(VyperParser.ArgContext,0)


        def kwarg(self):
            return self.getTypedRuleContext(VyperParser.KwargContext,0)


        def getRuleIndex(self):
            return VyperParser.RULE_argument

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArgument" ):
                listener.enterArgument(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArgument" ):
                listener.exitArgument(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArgument" ):
                return visitor.visitArgument(self)
            else:
                return visitor.visitChildren(self)




    def argument(self):

        localctx = VyperParser.ArgumentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_argument)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 707
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,66,self._ctx)
            if la_ == 1:
                self.state = 705
                self.arg()
                pass

            elif la_ == 2:
                self.state = 706
                self.kwarg()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArgumentsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def argument(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VyperParser.ArgumentContext)
            else:
                return self.getTypedRuleContext(VyperParser.ArgumentContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(VyperParser.COMMA)
            else:
                return self.getToken(VyperParser.COMMA, i)

        def getRuleIndex(self):
            return VyperParser.RULE_arguments

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArguments" ):
                listener.enterArguments(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArguments" ):
                listener.exitArguments(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitArguments" ):
                return visitor.visitArguments(self)
            else:
                return visitor.visitChildren(self)




    def arguments(self):

        localctx = VyperParser.ArgumentsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_arguments)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 709
            self.argument()
            self.state = 714
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,67,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 710
                    self.match(VyperParser.COMMA)
                    self.state = 711
                    self.argument() 
                self.state = 716
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,67,self._ctx)

            self.state = 718
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==5:
                self.state = 717
                self.match(VyperParser.COMMA)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TupleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LParen(self):
            return self.getToken(VyperParser.LParen, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(VyperParser.COMMA)
            else:
                return self.getToken(VyperParser.COMMA, i)

        def RParen(self):
            return self.getToken(VyperParser.RParen, 0)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VyperParser.ExprContext)
            else:
                return self.getTypedRuleContext(VyperParser.ExprContext,i)


        def getRuleIndex(self):
            return VyperParser.RULE_tuple

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTuple" ):
                listener.enterTuple(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTuple" ):
                listener.exitTuple(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTuple" ):
                return visitor.visitTuple(self)
            else:
                return visitor.visitChildren(self)




    def tuple_(self):

        localctx = VyperParser.TupleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_tuple)
        self._la = 0 # Token type
        try:
            self.state = 739
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,72,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 720
                self.match(VyperParser.LParen)
                self.state = 721
                self.match(VyperParser.COMMA)
                self.state = 722
                self.match(VyperParser.RParen)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 723
                self.match(VyperParser.LParen)
                self.state = 724
                self.expr()
                self.state = 735
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,71,self._ctx)
                if la_ == 1:
                    self.state = 727 
                    self._errHandler.sync(self)
                    _alt = 1
                    while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                        if _alt == 1:
                            self.state = 725
                            self.match(VyperParser.COMMA)
                            self.state = 726
                            self.expr()

                        else:
                            raise NoViableAltException(self)
                        self.state = 729 
                        self._errHandler.sync(self)
                        _alt = self._interp.adaptivePredict(self._input,69,self._ctx)

                    self.state = 732
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==5:
                        self.state = 731
                        self.match(VyperParser.COMMA)


                    pass

                elif la_ == 2:
                    self.state = 734
                    self.match(VyperParser.COMMA)
                    pass


                self.state = 737
                self.match(VyperParser.RParen)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RSquare(self):
            return self.getToken(VyperParser.RSquare, 0)

        def LSquare(self):
            return self.getToken(VyperParser.LSquare, 0)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VyperParser.ExprContext)
            else:
                return self.getTypedRuleContext(VyperParser.ExprContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(VyperParser.COMMA)
            else:
                return self.getToken(VyperParser.COMMA, i)

        def getRuleIndex(self):
            return VyperParser.RULE_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterList" ):
                listener.enterList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitList" ):
                listener.exitList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitList" ):
                return visitor.visitList(self)
            else:
                return visitor.visitChildren(self)




    def list_(self):

        localctx = VyperParser.ListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_list)
        self._la = 0 # Token type
        try:
            self.state = 757
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,75,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 741
                self.match(VyperParser.RSquare)
                self.state = 742
                self.match(VyperParser.LSquare)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 743
                self.match(VyperParser.RSquare)
                self.state = 744
                self.expr()
                self.state = 749
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,73,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 745
                        self.match(VyperParser.COMMA)
                        self.state = 746
                        self.expr() 
                    self.state = 751
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,73,self._ctx)

                self.state = 753
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==5:
                    self.state = 752
                    self.match(VyperParser.COMMA)


                self.state = 755
                self.match(VyperParser.LSquare)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DictContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LCurly(self):
            return self.getToken(VyperParser.LCurly, 0)

        def RCurly(self):
            return self.getToken(VyperParser.RCurly, 0)

        def NAME(self, i:int=None):
            if i is None:
                return self.getTokens(VyperParser.NAME)
            else:
                return self.getToken(VyperParser.NAME, i)

        def COLON(self, i:int=None):
            if i is None:
                return self.getTokens(VyperParser.COLON)
            else:
                return self.getToken(VyperParser.COLON, i)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VyperParser.ExprContext)
            else:
                return self.getTypedRuleContext(VyperParser.ExprContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(VyperParser.COMMA)
            else:
                return self.getToken(VyperParser.COMMA, i)

        def getRuleIndex(self):
            return VyperParser.RULE_dict

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDict" ):
                listener.enterDict(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDict" ):
                listener.exitDict(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDict" ):
                return visitor.visitDict(self)
            else:
                return visitor.visitChildren(self)




    def dict_(self):

        localctx = VyperParser.DictContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_dict)
        self._la = 0 # Token type
        try:
            self.state = 780
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,78,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 759
                self.match(VyperParser.LCurly)
                self.state = 760
                self.match(VyperParser.RCurly)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 761
                self.match(VyperParser.LCurly)

                self.state = 762
                self.match(VyperParser.NAME)
                self.state = 763
                self.match(VyperParser.COLON)
                self.state = 764
                self.expr()
                self.state = 772
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,76,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 766
                        self.match(VyperParser.COMMA)

                        self.state = 767
                        self.match(VyperParser.NAME)
                        self.state = 768
                        self.match(VyperParser.COLON)
                        self.state = 769
                        self.expr() 
                    self.state = 774
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,76,self._ctx)

                self.state = 776
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==5:
                    self.state = 775
                    self.match(VyperParser.COMMA)


                self.state = 778
                self.match(VyperParser.RCurly)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OperationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def boolor(self):
            return self.getTypedRuleContext(VyperParser.BoolorContext,0)


        def getRuleIndex(self):
            return VyperParser.RULE_operation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOperation" ):
                listener.enterOperation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOperation" ):
                listener.exitOperation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOperation" ):
                return visitor.visitOperation(self)
            else:
                return visitor.visitChildren(self)




    def operation(self):

        localctx = VyperParser.OperationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 142, self.RULE_operation)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 782
            self.boolor(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BoolorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def booland(self):
            return self.getTypedRuleContext(VyperParser.BoolandContext,0)


        def boolor(self):
            return self.getTypedRuleContext(VyperParser.BoolorContext,0)


        def OR(self):
            return self.getToken(VyperParser.OR, 0)

        def getRuleIndex(self):
            return VyperParser.RULE_boolor

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBoolor" ):
                listener.enterBoolor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBoolor" ):
                listener.exitBoolor(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBoolor" ):
                return visitor.visitBoolor(self)
            else:
                return visitor.visitChildren(self)



    def boolor(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = VyperParser.BoolorContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 144
        self.enterRecursionRule(localctx, 144, self.RULE_boolor, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 785
            self.booland(0)
            self._ctx.stop = self._input.LT(-1)
            self.state = 792
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,79,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = VyperParser.BoolorContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_boolor)
                    self.state = 787
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 788
                    self.match(VyperParser.OR)
                    self.state = 789
                    self.booland(0) 
                self.state = 794
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,79,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class BoolandContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def boolnot(self):
            return self.getTypedRuleContext(VyperParser.BoolnotContext,0)


        def booland(self):
            return self.getTypedRuleContext(VyperParser.BoolandContext,0)


        def AND(self):
            return self.getToken(VyperParser.AND, 0)

        def getRuleIndex(self):
            return VyperParser.RULE_booland

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBooland" ):
                listener.enterBooland(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBooland" ):
                listener.exitBooland(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBooland" ):
                return visitor.visitBooland(self)
            else:
                return visitor.visitChildren(self)



    def booland(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = VyperParser.BoolandContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 146
        self.enterRecursionRule(localctx, 146, self.RULE_booland, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 796
            self.boolnot()
            self._ctx.stop = self._input.LT(-1)
            self.state = 803
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,80,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = VyperParser.BoolandContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_booland)
                    self.state = 798
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 799
                    self.match(VyperParser.AND)
                    self.state = 800
                    self.boolnot() 
                self.state = 805
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,80,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class BoolnotContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def comparator(self):
            return self.getTypedRuleContext(VyperParser.ComparatorContext,0)


        def NOT(self):
            return self.getToken(VyperParser.NOT, 0)

        def boolnot(self):
            return self.getTypedRuleContext(VyperParser.BoolnotContext,0)


        def getRuleIndex(self):
            return VyperParser.RULE_boolnot

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBoolnot" ):
                listener.enterBoolnot(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBoolnot" ):
                listener.exitBoolnot(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBoolnot" ):
                return visitor.visitBoolnot(self)
            else:
                return visitor.visitChildren(self)




    def boolnot(self):

        localctx = VyperParser.BoolnotContext(self, self._ctx, self.state)
        self.enterRule(localctx, 148, self.RULE_boolnot)
        try:
            self.state = 809
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [7, 16, 27, 28, 53, 63, 64, 65, 67, 68, 69, 70, 71, 72, 73]:
                self.enterOuterAlt(localctx, 1)
                self.state = 806
                self.comparator(0)
                pass
            elif token in [52]:
                self.enterOuterAlt(localctx, 2)
                self.state = 807
                self.match(VyperParser.NOT)
                self.state = 808
                self.boolnot()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComparatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def bitwiseor(self):
            return self.getTypedRuleContext(VyperParser.BitwiseorContext,0)


        def comparator(self):
            return self.getTypedRuleContext(VyperParser.ComparatorContext,0)


        def LT(self):
            return self.getToken(VyperParser.LT, 0)

        def GT(self):
            return self.getToken(VyperParser.GT, 0)

        def EQ(self):
            return self.getToken(VyperParser.EQ, 0)

        def NE(self):
            return self.getToken(VyperParser.NE, 0)

        def LE(self):
            return self.getToken(VyperParser.LE, 0)

        def GE(self):
            return self.getToken(VyperParser.GE, 0)

        def In(self):
            return self.getToken(VyperParser.In, 0)

        def NOT(self):
            return self.getToken(VyperParser.NOT, 0)

        def getRuleIndex(self):
            return VyperParser.RULE_comparator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComparator" ):
                listener.enterComparator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComparator" ):
                listener.exitComparator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitComparator" ):
                return visitor.visitComparator(self)
            else:
                return visitor.visitChildren(self)



    def comparator(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = VyperParser.ComparatorContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 150
        self.enterRecursionRule(localctx, 150, self.RULE_comparator, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 812
            self.bitwiseor(0)
            self._ctx.stop = self._input.LT(-1)
            self.state = 841
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,83,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 839
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,82,self._ctx)
                    if la_ == 1:
                        localctx = VyperParser.ComparatorContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_comparator)
                        self.state = 814
                        if not self.precpred(self._ctx, 8):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 8)")
                        self.state = 815
                        self.match(VyperParser.LT)
                        self.state = 816
                        self.bitwiseor(0)
                        pass

                    elif la_ == 2:
                        localctx = VyperParser.ComparatorContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_comparator)
                        self.state = 817
                        if not self.precpred(self._ctx, 7):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 7)")
                        self.state = 818
                        self.match(VyperParser.GT)
                        self.state = 819
                        self.bitwiseor(0)
                        pass

                    elif la_ == 3:
                        localctx = VyperParser.ComparatorContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_comparator)
                        self.state = 820
                        if not self.precpred(self._ctx, 6):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 6)")
                        self.state = 821
                        self.match(VyperParser.EQ)
                        self.state = 822
                        self.bitwiseor(0)
                        pass

                    elif la_ == 4:
                        localctx = VyperParser.ComparatorContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_comparator)
                        self.state = 823
                        if not self.precpred(self._ctx, 5):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 5)")
                        self.state = 824
                        self.match(VyperParser.NE)
                        self.state = 825
                        self.bitwiseor(0)
                        pass

                    elif la_ == 5:
                        localctx = VyperParser.ComparatorContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_comparator)
                        self.state = 826
                        if not self.precpred(self._ctx, 4):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 4)")
                        self.state = 827
                        self.match(VyperParser.LE)
                        self.state = 828
                        self.bitwiseor(0)
                        pass

                    elif la_ == 6:
                        localctx = VyperParser.ComparatorContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_comparator)
                        self.state = 829
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 830
                        self.match(VyperParser.GE)
                        self.state = 831
                        self.bitwiseor(0)
                        pass

                    elif la_ == 7:
                        localctx = VyperParser.ComparatorContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_comparator)
                        self.state = 832
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 833
                        self.match(VyperParser.In)
                        self.state = 834
                        self.bitwiseor(0)
                        pass

                    elif la_ == 8:
                        localctx = VyperParser.ComparatorContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_comparator)
                        self.state = 835
                        if not self.precpred(self._ctx, 1):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                        self.state = 836
                        self.match(VyperParser.NOT)
                        self.state = 837
                        self.match(VyperParser.In)
                        self.state = 838
                        self.bitwiseor(0)
                        pass

             
                self.state = 843
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,83,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class BitwiseorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def bitwisexor(self):
            return self.getTypedRuleContext(VyperParser.BitwisexorContext,0)


        def bitwiseor(self):
            return self.getTypedRuleContext(VyperParser.BitwiseorContext,0)


        def BITOR(self):
            return self.getToken(VyperParser.BITOR, 0)

        def getRuleIndex(self):
            return VyperParser.RULE_bitwiseor

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBitwiseor" ):
                listener.enterBitwiseor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBitwiseor" ):
                listener.exitBitwiseor(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBitwiseor" ):
                return visitor.visitBitwiseor(self)
            else:
                return visitor.visitChildren(self)



    def bitwiseor(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = VyperParser.BitwiseorContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 152
        self.enterRecursionRule(localctx, 152, self.RULE_bitwiseor, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 845
            self.bitwisexor(0)
            self._ctx.stop = self._input.LT(-1)
            self.state = 852
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,84,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = VyperParser.BitwiseorContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_bitwiseor)
                    self.state = 847
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 848
                    self.match(VyperParser.BITOR)
                    self.state = 849
                    self.bitwisexor(0) 
                self.state = 854
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,84,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class BitwisexorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def bitwiseand(self):
            return self.getTypedRuleContext(VyperParser.BitwiseandContext,0)


        def bitwisexor(self):
            return self.getTypedRuleContext(VyperParser.BitwisexorContext,0)


        def BITXOR(self):
            return self.getToken(VyperParser.BITXOR, 0)

        def getRuleIndex(self):
            return VyperParser.RULE_bitwisexor

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBitwisexor" ):
                listener.enterBitwisexor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBitwisexor" ):
                listener.exitBitwisexor(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBitwisexor" ):
                return visitor.visitBitwisexor(self)
            else:
                return visitor.visitChildren(self)



    def bitwisexor(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = VyperParser.BitwisexorContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 154
        self.enterRecursionRule(localctx, 154, self.RULE_bitwisexor, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 856
            self.bitwiseand(0)
            self._ctx.stop = self._input.LT(-1)
            self.state = 863
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,85,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = VyperParser.BitwisexorContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_bitwisexor)
                    self.state = 858
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 859
                    self.match(VyperParser.BITXOR)
                    self.state = 860
                    self.bitwiseand(0) 
                self.state = 865
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,85,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class BitwiseandContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def shift(self):
            return self.getTypedRuleContext(VyperParser.ShiftContext,0)


        def bitwiseand(self):
            return self.getTypedRuleContext(VyperParser.BitwiseandContext,0)


        def BITAND(self):
            return self.getToken(VyperParser.BITAND, 0)

        def getRuleIndex(self):
            return VyperParser.RULE_bitwiseand

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBitwiseand" ):
                listener.enterBitwiseand(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBitwiseand" ):
                listener.exitBitwiseand(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBitwiseand" ):
                return visitor.visitBitwiseand(self)
            else:
                return visitor.visitChildren(self)



    def bitwiseand(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = VyperParser.BitwiseandContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 156
        self.enterRecursionRule(localctx, 156, self.RULE_bitwiseand, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 867
            self.shift(0)
            self._ctx.stop = self._input.LT(-1)
            self.state = 874
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,86,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = VyperParser.BitwiseandContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_bitwiseand)
                    self.state = 869
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 870
                    self.match(VyperParser.BITAND)
                    self.state = 871
                    self.shift(0) 
                self.state = 876
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,86,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class ShiftContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def summation(self):
            return self.getTypedRuleContext(VyperParser.SummationContext,0)


        def shift(self):
            return self.getTypedRuleContext(VyperParser.ShiftContext,0)


        def SHL(self):
            return self.getToken(VyperParser.SHL, 0)

        def SHR(self):
            return self.getToken(VyperParser.SHR, 0)

        def getRuleIndex(self):
            return VyperParser.RULE_shift

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShift" ):
                listener.enterShift(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShift" ):
                listener.exitShift(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitShift" ):
                return visitor.visitShift(self)
            else:
                return visitor.visitChildren(self)



    def shift(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = VyperParser.ShiftContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 158
        self.enterRecursionRule(localctx, 158, self.RULE_shift, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 878
            self.summation(0)
            self._ctx.stop = self._input.LT(-1)
            self.state = 888
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,88,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 886
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,87,self._ctx)
                    if la_ == 1:
                        localctx = VyperParser.ShiftContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_shift)
                        self.state = 880
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 881
                        self.match(VyperParser.SHL)
                        self.state = 882
                        self.summation(0)
                        pass

                    elif la_ == 2:
                        localctx = VyperParser.ShiftContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_shift)
                        self.state = 883
                        if not self.precpred(self._ctx, 1):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                        self.state = 884
                        self.match(VyperParser.SHR)
                        self.state = 885
                        self.summation(0)
                        pass

             
                self.state = 890
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,88,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class SummationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def product(self):
            return self.getTypedRuleContext(VyperParser.ProductContext,0)


        def summation(self):
            return self.getTypedRuleContext(VyperParser.SummationContext,0)


        def ADD(self):
            return self.getToken(VyperParser.ADD, 0)

        def SUB(self):
            return self.getToken(VyperParser.SUB, 0)

        def getRuleIndex(self):
            return VyperParser.RULE_summation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSummation" ):
                listener.enterSummation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSummation" ):
                listener.exitSummation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSummation" ):
                return visitor.visitSummation(self)
            else:
                return visitor.visitChildren(self)



    def summation(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = VyperParser.SummationContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 160
        self.enterRecursionRule(localctx, 160, self.RULE_summation, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 892
            self.product(0)
            self._ctx.stop = self._input.LT(-1)
            self.state = 902
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,90,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 900
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,89,self._ctx)
                    if la_ == 1:
                        localctx = VyperParser.SummationContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_summation)
                        self.state = 894
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 895
                        self.match(VyperParser.ADD)
                        self.state = 896
                        self.product(0)
                        pass

                    elif la_ == 2:
                        localctx = VyperParser.SummationContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_summation)
                        self.state = 897
                        if not self.precpred(self._ctx, 1):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                        self.state = 898
                        self.match(VyperParser.SUB)
                        self.state = 899
                        self.product(0)
                        pass

             
                self.state = 904
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,90,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class ProductContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unary(self):
            return self.getTypedRuleContext(VyperParser.UnaryContext,0)


        def product(self):
            return self.getTypedRuleContext(VyperParser.ProductContext,0)


        def MUL(self):
            return self.getToken(VyperParser.MUL, 0)

        def DIV(self):
            return self.getToken(VyperParser.DIV, 0)

        def MOD(self):
            return self.getToken(VyperParser.MOD, 0)

        def getRuleIndex(self):
            return VyperParser.RULE_product

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProduct" ):
                listener.enterProduct(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProduct" ):
                listener.exitProduct(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProduct" ):
                return visitor.visitProduct(self)
            else:
                return visitor.visitChildren(self)



    def product(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = VyperParser.ProductContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 162
        self.enterRecursionRule(localctx, 162, self.RULE_product, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 906
            self.unary()
            self._ctx.stop = self._input.LT(-1)
            self.state = 919
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,92,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 917
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,91,self._ctx)
                    if la_ == 1:
                        localctx = VyperParser.ProductContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_product)
                        self.state = 908
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 909
                        self.match(VyperParser.MUL)
                        self.state = 910
                        self.unary()
                        pass

                    elif la_ == 2:
                        localctx = VyperParser.ProductContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_product)
                        self.state = 911
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 912
                        self.match(VyperParser.DIV)
                        self.state = 913
                        self.unary()
                        pass

                    elif la_ == 3:
                        localctx = VyperParser.ProductContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_product)
                        self.state = 914
                        if not self.precpred(self._ctx, 1):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                        self.state = 915
                        self.match(VyperParser.MOD)
                        self.state = 916
                        self.unary()
                        pass

             
                self.state = 921
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,92,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class UnaryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def power(self):
            return self.getTypedRuleContext(VyperParser.PowerContext,0)


        def ADD(self):
            return self.getToken(VyperParser.ADD, 0)

        def SUB(self):
            return self.getToken(VyperParser.SUB, 0)

        def NEG(self):
            return self.getToken(VyperParser.NEG, 0)

        def getRuleIndex(self):
            return VyperParser.RULE_unary

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnary" ):
                listener.enterUnary(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnary" ):
                listener.exitUnary(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnary" ):
                return visitor.visitUnary(self)
            else:
                return visitor.visitChildren(self)




    def unary(self):

        localctx = VyperParser.UnaryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 164, self.RULE_unary)
        try:
            self.state = 929
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [7, 16, 63, 64, 65, 67, 68, 69, 70, 71, 72, 73]:
                self.enterOuterAlt(localctx, 1)
                self.state = 922
                self.power(0)
                pass
            elif token in [27]:
                self.enterOuterAlt(localctx, 2)
                self.state = 923
                self.match(VyperParser.ADD)
                self.state = 924
                self.power(0)
                pass
            elif token in [28]:
                self.enterOuterAlt(localctx, 3)
                self.state = 925
                self.match(VyperParser.SUB)
                self.state = 926
                self.power(0)
                pass
            elif token in [53]:
                self.enterOuterAlt(localctx, 4)
                self.state = 927
                self.match(VyperParser.NEG)
                self.state = 928
                self.power(0)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PowerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def atom(self):
            return self.getTypedRuleContext(VyperParser.AtomContext,0)


        def power(self):
            return self.getTypedRuleContext(VyperParser.PowerContext,0)


        def POW(self):
            return self.getToken(VyperParser.POW, 0)

        def getRuleIndex(self):
            return VyperParser.RULE_power

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPower" ):
                listener.enterPower(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPower" ):
                listener.exitPower(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPower" ):
                return visitor.visitPower(self)
            else:
                return visitor.visitChildren(self)



    def power(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = VyperParser.PowerContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 166
        self.enterRecursionRule(localctx, 166, self.RULE_power, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 932
            self.atom()
            self._ctx.stop = self._input.LT(-1)
            self.state = 939
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,94,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = VyperParser.PowerContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_power)
                    self.state = 934
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 935
                    self.match(VyperParser.POW)
                    self.state = 936
                    self.atom() 
                self.state = 941
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,94,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class EmptyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Empty(self):
            return self.getToken(VyperParser.Empty, 0)

        def LParen(self):
            return self.getToken(VyperParser.LParen, 0)

        def type_(self):
            return self.getTypedRuleContext(VyperParser.Type_Context,0)


        def RParen(self):
            return self.getToken(VyperParser.RParen, 0)

        def getRuleIndex(self):
            return VyperParser.RULE_empty

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEmpty" ):
                listener.enterEmpty(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEmpty" ):
                listener.exitEmpty(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEmpty" ):
                return visitor.visitEmpty(self)
            else:
                return visitor.visitChildren(self)




    def empty(self):

        localctx = VyperParser.EmptyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 168, self.RULE_empty)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 942
            self.match(VyperParser.Empty)
            self.state = 943
            self.match(VyperParser.LParen)
            self.state = 944
            self.type_()
            self.state = 945
            self.match(VyperParser.RParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AbidecodeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AbiDecode(self):
            return self.getToken(VyperParser.AbiDecode, 0)

        def LParen(self):
            return self.getToken(VyperParser.LParen, 0)

        def arg(self):
            return self.getTypedRuleContext(VyperParser.ArgContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(VyperParser.COMMA)
            else:
                return self.getToken(VyperParser.COMMA, i)

        def type_(self):
            return self.getTypedRuleContext(VyperParser.Type_Context,0)


        def RParen(self):
            return self.getToken(VyperParser.RParen, 0)

        def kwarg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(VyperParser.KwargContext)
            else:
                return self.getTypedRuleContext(VyperParser.KwargContext,i)


        def getRuleIndex(self):
            return VyperParser.RULE_abidecode

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAbidecode" ):
                listener.enterAbidecode(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAbidecode" ):
                listener.exitAbidecode(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAbidecode" ):
                return visitor.visitAbidecode(self)
            else:
                return visitor.visitChildren(self)




    def abidecode(self):

        localctx = VyperParser.AbidecodeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 170, self.RULE_abidecode)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 947
            self.match(VyperParser.AbiDecode)
            self.state = 948
            self.match(VyperParser.LParen)
            self.state = 949
            self.arg()
            self.state = 950
            self.match(VyperParser.COMMA)
            self.state = 951
            self.type_()
            self.state = 956
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==5:
                self.state = 952
                self.match(VyperParser.COMMA)
                self.state = 953
                self.kwarg()
                self.state = 958
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 959
            self.match(VyperParser.RParen)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SpecialbuiltinsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def empty(self):
            return self.getTypedRuleContext(VyperParser.EmptyContext,0)


        def abidecode(self):
            return self.getTypedRuleContext(VyperParser.AbidecodeContext,0)


        def getRuleIndex(self):
            return VyperParser.RULE_specialbuiltins

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpecialbuiltins" ):
                listener.enterSpecialbuiltins(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpecialbuiltins" ):
                listener.exitSpecialbuiltins(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSpecialbuiltins" ):
                return visitor.visitSpecialbuiltins(self)
            else:
                return visitor.visitChildren(self)




    def specialbuiltins(self):

        localctx = VyperParser.SpecialbuiltinsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 172, self.RULE_specialbuiltins)
        try:
            self.state = 963
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [63]:
                self.enterOuterAlt(localctx, 1)
                self.state = 961
                self.empty()
                pass
            elif token in [64]:
                self.enterOuterAlt(localctx, 2)
                self.state = 962
                self.abidecode()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AtomContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def variableaccess(self):
            return self.getTypedRuleContext(VyperParser.VariableaccessContext,0)


        def literal(self):
            return self.getTypedRuleContext(VyperParser.LiteralContext,0)


        def specialbuiltins(self):
            return self.getTypedRuleContext(VyperParser.SpecialbuiltinsContext,0)


        def tuple_(self):
            return self.getTypedRuleContext(VyperParser.TupleContext,0)


        def list_(self):
            return self.getTypedRuleContext(VyperParser.ListContext,0)


        def LParen(self):
            return self.getToken(VyperParser.LParen, 0)

        def operation(self):
            return self.getTypedRuleContext(VyperParser.OperationContext,0)


        def RParen(self):
            return self.getToken(VyperParser.RParen, 0)

        def getRuleIndex(self):
            return VyperParser.RULE_atom

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtom" ):
                listener.enterAtom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtom" ):
                listener.exitAtom(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAtom" ):
                return visitor.visitAtom(self)
            else:
                return visitor.visitChildren(self)




    def atom(self):

        localctx = VyperParser.AtomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 174, self.RULE_atom)
        try:
            self.state = 974
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,97,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 965
                self.variableaccess()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 966
                self.literal()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 967
                self.specialbuiltins()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 968
                self.tuple_()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 969
                self.list_()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 970
                self.match(VyperParser.LParen)
                self.state = 971
                self.operation()
                self.state = 972
                self.match(VyperParser.RParen)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DECNUMBER(self):
            return self.getToken(VyperParser.DECNUMBER, 0)

        def HEXNUMBER(self):
            return self.getToken(VyperParser.HEXNUMBER, 0)

        def BINNUMBER(self):
            return self.getToken(VyperParser.BINNUMBER, 0)

        def OCTNUMBER(self):
            return self.getToken(VyperParser.OCTNUMBER, 0)

        def FLOATNUMBER(self):
            return self.getToken(VyperParser.FLOATNUMBER, 0)

        def getRuleIndex(self):
            return VyperParser.RULE_number

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumber" ):
                listener.enterNumber(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumber" ):
                listener.exitNumber(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumber" ):
                return visitor.visitNumber(self)
            else:
                return visitor.visitChildren(self)




    def number(self):

        localctx = VyperParser.NumberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 176, self.RULE_number)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 976
            _la = self._input.LA(1)
            if not(((((_la - 68)) & ~0x3f) == 0 and ((1 << (_la - 68)) & 31) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LiteralContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def number(self):
            return self.getTypedRuleContext(VyperParser.NumberContext,0)


        def STRING(self):
            return self.getToken(VyperParser.STRING, 0)

        def BOOL(self):
            return self.getToken(VyperParser.BOOL, 0)

        def getRuleIndex(self):
            return VyperParser.RULE_literal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLiteral" ):
                listener.enterLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLiteral" ):
                listener.exitLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLiteral" ):
                return visitor.visitLiteral(self)
            else:
                return visitor.visitChildren(self)




    def literal(self):

        localctx = VyperParser.LiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 178, self.RULE_literal)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 981
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [68, 69, 70, 71, 72]:
                self.state = 978
                self.number()
                pass
            elif token in [67]:
                self.state = 979
                self.match(VyperParser.STRING)
                pass
            elif token in [73]:
                self.state = 980
                self.match(VyperParser.BOOL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[72] = self.boolor_sempred
        self._predicates[73] = self.booland_sempred
        self._predicates[75] = self.comparator_sempred
        self._predicates[76] = self.bitwiseor_sempred
        self._predicates[77] = self.bitwisexor_sempred
        self._predicates[78] = self.bitwiseand_sempred
        self._predicates[79] = self.shift_sempred
        self._predicates[80] = self.summation_sempred
        self._predicates[81] = self.product_sempred
        self._predicates[83] = self.power_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def boolor_sempred(self, localctx:BoolorContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 1)
         

    def booland_sempred(self, localctx:BoolandContext, predIndex:int):
            if predIndex == 1:
                return self.precpred(self._ctx, 1)
         

    def comparator_sempred(self, localctx:ComparatorContext, predIndex:int):
            if predIndex == 2:
                return self.precpred(self._ctx, 8)
         

            if predIndex == 3:
                return self.precpred(self._ctx, 7)
         

            if predIndex == 4:
                return self.precpred(self._ctx, 6)
         

            if predIndex == 5:
                return self.precpred(self._ctx, 5)
         

            if predIndex == 6:
                return self.precpred(self._ctx, 4)
         

            if predIndex == 7:
                return self.precpred(self._ctx, 3)
         

            if predIndex == 8:
                return self.precpred(self._ctx, 2)
         

            if predIndex == 9:
                return self.precpred(self._ctx, 1)
         

    def bitwiseor_sempred(self, localctx:BitwiseorContext, predIndex:int):
            if predIndex == 10:
                return self.precpred(self._ctx, 1)
         

    def bitwisexor_sempred(self, localctx:BitwisexorContext, predIndex:int):
            if predIndex == 11:
                return self.precpred(self._ctx, 1)
         

    def bitwiseand_sempred(self, localctx:BitwiseandContext, predIndex:int):
            if predIndex == 12:
                return self.precpred(self._ctx, 1)
         

    def shift_sempred(self, localctx:ShiftContext, predIndex:int):
            if predIndex == 13:
                return self.precpred(self._ctx, 2)
         

            if predIndex == 14:
                return self.precpred(self._ctx, 1)
         

    def summation_sempred(self, localctx:SummationContext, predIndex:int):
            if predIndex == 15:
                return self.precpred(self._ctx, 2)
         

            if predIndex == 16:
                return self.precpred(self._ctx, 1)
         

    def product_sempred(self, localctx:ProductContext, predIndex:int):
            if predIndex == 17:
                return self.precpred(self._ctx, 3)
         

            if predIndex == 18:
                return self.precpred(self._ctx, 2)
         

            if predIndex == 19:
                return self.precpred(self._ctx, 1)
         

    def power_sempred(self, localctx:PowerContext, predIndex:int):
            if predIndex == 20:
                return self.precpred(self._ctx, 1)
         




